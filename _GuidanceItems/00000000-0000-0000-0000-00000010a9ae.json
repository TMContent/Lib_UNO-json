{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "0",
      "Content_Hash": "0"
    },
    "Metadata": [
      {
        "Id": [
          "00000000-0000-0000-0000-00000010a9ae"
        ],
        "Id_History": [
          "00000000-0000-0000-0000-00000010a9ae,2844ec7f-b3ec-490b-8f56-1b4a3fbc6368,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "Encryption Keys Are Stored Using Protected Storage APIs"
        ],
        "Category": [
          "Cryptography"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          "PHP"
        ],
        "Type": [
          "Checklist Item"
        ],
        "DirectLink": [
          "Encryption Keys Are Stored Using Protected Storage APIs"
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "false",
          "DataType": "wikitext"
        },
        "Data": [
          "==Applies To==\r\n\r\n* PHP\r\n\r\n==What to Check For==\r\n\r\nCryptographic keys should be stored using protected storage APIs, but there is no practical way to do this with PHP. Examine your application's key storage solution and be aware of its limitations to deploy defense in depth measures effectively.\r\n\r\n==Why==\r\n\r\nEncryption is a defense in depth measure. Data encrypted with strong encryption is of no interest to an attacker. If, however, the attacker compromises the encryption keys and gains access to encrypted data, it is trivial for him to break the encryption and obtain original information. Additional measures should be put in place to protect the encryption keys besides those that are used to protect the encrypted data. These additional measures usually involve a protected key store provided by the platform.\r\n\r\n==How to Check==\r\n\r\nTo examine cryptographic key storage:\r\n\r\n# **Define key storage requirements.** Define what encryption algorithms your application should use, what strength of encryption keys, how the keys should be stored, etc. These requirements may be spelled out by policy or by compliance requirements.\r\n# **Identify key storage mechanisms.** Find out all the details about how the application stores and manages the encryption keys from documentation and from the developers.\r\n# **Examine the key storage mechanisms.** Using the information about the application's key storage mechanisms, examine their implementation to find out how exactly key storage is implemented. Make sure that encryption keys and encrypted data are stored separately. Consider the key store from the attacker's perspective - what options are available to the attacker to gain access to both the encrypted data and to the encryption keys.\r\n\r\n==How to Fix==\r\n\r\nThe following options are available for storing encryption keys in PHP:\r\n\r\n# **Encrypt the encryption keys with the user's password.** If data that needs to be encrypted is specific to a user, the encryption key may be encrypted with the user's password. The user password should then be stored as a salted hash. When the user logs in, the application checks the entered password against the salted hash. If the entered password matches the salted hash, the application authenticates the user and decrypts the encryption key. The authenticated user is then able to access the encrypted data. If an attacker downloads the stored encryption key and the encrypted data, he won't be able to easily decrypt the data without knowing the user's password. Therefore, this option is viable for applications where encrypted data is user-specific. Because each user has a separate encryption key, encrypted data has to be stored separately for each user. There also needs to be a storage location for all the users' encryption keys. When using this solution, it is important to be aware of how encryption keys and decrypted data are stored in memory. It is best to remove sensitive data and encryption keys from memory as soon as possible, to prevent attackers from recovering this information from the system RAM. This solution will not work if the data needs to be accessed by someone other than the user. \r\n# **Encrypt the encryption keys with a master key.** It is possible to encrypt the encryption keys with a master key. When the application is started, the administrator enters the master key. The application uses the master key to decrypt stored encryption keys and loads them into memory. The application is then able to decrypt stored encrypted data. This solution prevents attackers from recovering stored encryption keys. This solution keeps the encryption keys in memory for the time the application is running. Therefore, if an attacker gains access to system RAM, or the paged memory, the key can be compromised. To prevent this, keep the keys stored in a non-paged memory pool, disable core dumps(unix/linux) and memory dumps(windows) and physically secure the system to prevent Cold Boot Attacks. The main disadvantage of this solution is that it requires the master key to be entered when the application is first started. This makes the encrypted data inaccessible if the application is restarted and there is no one around to enter the master key.\r\n# **Store the encryption keys on another server.** A common, insecure solution is to store the encryption keys on another server. It is a misconception that this makes it harder for an attacker to recover the encryption keys if the application is compromised. , If the attacker controls the application, he can do anything that the application can do, including recovering the encryption keys. This solution is not recommended. It's mentioned here for reference. It is possible to store encryption keys on another server and encrypt them with the user's password or with a master key (entered at startup by administrator), in which case it becomes reasonably secure. Simply storing the encryption keys on another server is not actually secure though.\r\n# **Store the encryption keys in a file.** Another common insecure solution is to store the encryption keys in a file. If the attacker is able to download the encrypted data, he can probably download the file with the encryption keys as well. This solution is not recommended and is only mentioned here for reference.\r\n# **The users store the encryption keys.** A simple and reasonably secure solution is to let the users manage their encryption keys and never store them on the server. This is similar to encrypting the key with the userâ€™s password. The users can store their encryption keys as certificates or remember them as pass-phrases. Whenever the application needs to access encrypted data, it can ask the user for the key. If the key is valid, the application decrypts the data for the user. If an attacker takes over the application and downloads the encrypted data, he still won't have access to the encryption keys. This solution will not work if the data needs to be accessed by someone other than the user. "
        ]
      }
    ]
  }
}