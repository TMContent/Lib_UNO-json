{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "0",
      "Content_Hash": "0"
    },
    "Metadata": [
      {
        "Id": [
          "00000000-0000-0000-0000-00000016b3b2"
        ],
        "Id_History": [
          "00000000-0000-0000-0000-00000016b3b2,0b3ddffc-d52b-43af-bcdb-09aeaa1495e9,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "Validate All Input Passed to the Database"
        ],
        "Category": [
          "Input and Data Validation"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          "Scala Play"
        ],
        "Type": [
          "Guideline"
        ],
        "DirectLink": [
          "Validate All Input Passed to the Database"
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "false",
          "DataType": "html"
        },
        "Data": [
          "<h1>Applies to</h1>\n  <p>\n  Applications written using Scala and Play Framework 2.1.0 that interact with a database</p>\n  <ul>\n  </ul>\n  <h1>What to Do</h1>\n  <p>Validate all input before it is passed to the database.</p>\n  <h1>Why</h1>\n  <p>Unvalidated input can lead to persistent cross-site scripting, SQL/NoSQL injection and other vulnerabilities which could allow an attacker to \ngain unauthorized access to sensitive data.</p>\n  <h1>When</h1>\n  <p>If your application uses a back-end database server, then validate all input before it is passed to the database.</p>\n  <h1>How</h1>\n  <p>To properly validate input passed to database:</p>\n  <ol>\n    <li>\n      <strong>Identify database entry points. </strong>Identify all locations within your application that interface with the database servers. Potential sources of input include:<br /><ul><li style=\"margin: 0px; padding: 0px;\">URL based parameters</li><li style=\"margin: 0px; padding: 0px;\">Form based parameters</li><li style=\"margin: 0px; padding: 0px;\">Hidden fields</li><li style=\"margin: 0px; padding: 0px;\">Cookies</li><li style=\"margin: 0px; padding: 0px;\">HTTP headers (Host, accept types, www authentication, cache settings, encodings, etc)</li><li style=\"margin: 0px; padding: 0px;\">Local filesystem</li><li style=\"margin: 0px; padding: 0px;\">Database</li><li style=\"margin: 0px; padding: 0px;\">Other services running on the system</li><li style=\"margin: 0px; padding: 0px;\">JavaScript variables</li><li style=\"margin: 0px; padding: 0px;\">File upload and attributes (filename, size, data, etc)</li><li style=\"margin: 0px; padding: 0px;\">DNS results or host names</li><li style=\"margin: 0px; padding: 0px;\">External component call return values (AJAX, etc)</li></ul></li>\n    <li>\n      <p>\n        <strong>Create a set of validators. </strong>Build\n a set of validators that work with the database-specific language. \nDetermine the appropriate validation at each validator. Centralize the \nvalidators--this helps strengthen your code by limiting the amount of \nscattered validation code throughout the component. Place the validators\n along the database entry points. All data should pass through the \nvalidators before being transmitted to the database servers.</p>\n    </li>\n    <li>\n      <p>\n        <strong>Use type safe SQL parameters in queries. </strong>Stored procedures and parameterized queries improve your application's robustness against SQL injection based attacks.&nbsp;Play Framework supports Anorm to access the database. According to the Play Framework source code <a href=\"https://github.com/playframework/Play20/blob/master/framework/src/anorm/src/main/scala/anorm/Anorm.scala\">here</a>, Anorm builds only <a href=\"http://docs.oracle.com/javase/6/docs/api/java/sql/PreparedStatement.html\">java.sql.PreparedStatements</a>, which prevents SQL injection attacks.</p>\n    </li>\n  </ol>\n  <h1>Problem Example</h1>\n  <p>The following code allows the user to query a database. \nUnfortunately, the application fails to validate the user's input. Therefore, an attacker can access the back-end database on behalf of the \napplication through the use of SQL injection. </p>\n  <p />\n  <p>For example, say a MongoDB collection contains some documents that represent books, some that represent movies, and some that represent music albums. This JavaScript query function will select all the documents in the specified collection that were written, filmed, or recorded in the specified year:</p>\n  <p>If the developer were building this application using a given programming language, the source code might look like this:</p>\n  <div>\n    <pre>$query = 'function() {var search_year = \\'' .\n\n$_GET['year'] . '\\';' .\n\n'return this.publicationYear == search_year || ' .\n\n' this.filmingYear == search_year || ' .\n\n' this.recordingYear == search_year;}';\n\n$cursor = $collection-&gt;find(array('$where' =&gt; $query));</pre>\n  </div>\n  <div>This code uses the value of the request parameter “year” as the search parameter. Just as in a traditional SQL injection attack, since the query syntax is being constructed in an ad-hoc fashion (i.e. query syntax concatenated along with user input), this code is vulnerable to a server-side JavaScript injection attack. For example, the following request would be an effective DoS attack against the system:</div>\n  <div>\n    <pre>http://server/app?year=1995';while(1);var%20foo='bar</pre>\n  </div>\n  <p />\n  <h1>Fix</h1>\n  <p />\n  <p>Strong input validation can be used to prevent SQL/NoSQL Injection attacks on an application. Prepared Statements must be used. Additionally, precompiled queries can also be used to prevent these attacks.</p>\n  <p>Care should be taken while using precompiled queries to make sure that the internal queries do not contain dynamic content.</p>\n  <p />\n  <p />\n  <p>Bind parameters are the best way to pass data to the database. Instead of putting the values directly into the SQL statement, you just use a placeholder like ?, :name or @name and provide the actual values using a separate API call.</p>\n  <p>Below example shows a secure implementation of using Bind variable in Play Framework:</p>\n  <p>\n  </p>\n  <pre>public static void searchString(String keyword) {\n\nString trimedkeyword = keyword.trim();\n\nString keypattern = \"%\"+trimedkeyword+\"%\";\n\nString query=\"select distinct item from Item where item.name like :keypattern\";\n\nList<item> items = Item.find(query).bind(\"keypattern\", keypattern).fetch();\n\n...\n\n}</item></pre>\n  <p />\n  <p />\n  <p />\n  <p>Play Framework supports “Anorm” to access database. According to the Play Framework source code&nbsp;<a href=\"https://github.com/playframework/Play20/blob/master/framework/src/anorm/src/main/scala/anorm/Anorm.scala\">here</a>,&nbsp;Anorm&nbsp;builds only&nbsp;<a href=\"http://docs.oracle.com/javase/6/docs/api/java/sql/PreparedStatement.html\">java.sql.PreparedStatements</a>, which prevents SQL injection attack.</p>\n  <p>Below is an example of how&nbsp;Anorm&nbsp;can be used safely in Play Framework:</p>\n  <p>\n  </p>\n  <pre>object Person {\n\ndef save(p:Person) {\n\nDB.withConnection (\"default\") { implicit connection =&gt;\n\nSQL(\"\"\"\n\nINSERT INTO person(firstName,lastName)\n\nvalues ({firstName}, {lastName})\n\n\"\"\"\n\n).on(\n\n\"firstName\" -&gt; p.firstName,\n\n\"lastName\" -&gt; p.lastName\n\n).executeUpdate()\n\n}\n\n}\n\n}</pre>\n  <p />\n  <p />\n  <p />\n  <p />\n  <p>NOTE: Though there are many&nbsp;<a href=\"http://media.blackhat.com/bh-us-11/Sullivan/BH_US_11_Sullivan_Server_Side_WP.pdf\">reported</a>&nbsp;instances of NoSQL injection using a language like PHP, but NoSQL injection in Play Framework does not have facts to prove the existence for this vulnerability. However, for Defense in Depth, the mitigations mentioned above along with input sanitization should always be followed as a best coding practice.</p>\n  <ul>\n  </ul>\n  <br />"
        ]
      }
    ]
  }
}