{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "-1117535555",
      "Content_Hash": "541924453"
    },
    "Metadata": [
      {
        "Id": [
          "88d5cf55-9858-4bef-b059-2f9c90bf3082"
        ],
        "Id_History": [
          "88d5cf55-9858-4bef-b059-2f9c90bf3082,619cf270-6a78-412e-8c28-1941c0561a3c,"
        ],
        "Library_Id": [
          "26bd1a04-beed-4a66-917d-b6ab0a7d634c"
        ],
        "Title": [
          "The Application Is Partitioned Between Public And Private Domains"
        ],
        "Category": [
          "Communication Security"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          ".NET"
        ],
        "Type": [
          "Checklist Item"
        ],
        "DirectLink": [
          "The Application Is Partitioned Between Public And Private Domains"
        ],
        "Tag": [
          "ASP.NET,ASP.NET 4.0,ASP"
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<h1>Applies To</h1>\r\n  <ul>\r\n    <li>ASP.NET 4.0</li>\r\n  </ul>\r\n  <h1>What to Check For</h1>\r\n  <p>Ensure that there is a boundary defined to separate public and restricted content in both the URL namespace and file system namespace. </p>\r\n  <h1>Why</h1>\r\n  <p>Defining a boundary between public and restricted content simplifies the task of user authorization and is generally less prone to error. When the content is separated, server configuration can be used to automatically apply authorization rules without relying on the developer to explicitly add checks in the code.</p>\r\n  <h1>How To Check</h1>\r\n  <p>Take the following steps to ensure your application is partitioned into public and restricted domains:</p>\r\n  <ol>\r\n    <li>\r\n      <p>\r\n        <strong>Enumerate all web accessible resources.</strong>&nbsp;Identify the protected resources from the public resources. Common protected resources include, but are not limited to:</p>\r\n      <ul>\r\n        <li>Resources that require authentication </li>\r\n        <li>Critical application resources </li>\r\n        <li>Sensitive/confidential data</li>\r\n      </ul>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Check the structure of the URL namespace.</strong> Ensure that your application's URL namespace is structured properly according to the level of protection and security needs of each resource. Verify that transitions between URL namespaces is performed using absolute URLs. </p>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Check if there is separation on disk between public and protected resources. </strong>Examine the local filesystem structure. Ensure that protected resources are not located inside a public directory and vice versa. </p>\r\n    </li>\r\n    <li>\r\n      <strong>Verify the local system permissions for all resources.</strong> For each resource, check that the local filesystem permissions are set accordingly. If the resource is public, verify that anonymous users can access it. If the resource is protected, verify that only authorized users can access it.</li>\r\n  </ol>\r\n  <h1>How To Fix</h1>\r\n  <p>Defining the boundary requires: </p>\r\n  <ol>\r\n    <li>\r\n      <p>\r\n        <strong>Determine roles.</strong> Define the various types of user and their rights. Build a security policy that documents the rights required to access each page of your application.</p>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Determine pages that should require SSL.</strong> This would include pages that transmit credentials, unprotected authentication cookies, or sensitive user information such as credit card or social security numbers. Such pages should be transmitted using SSL only.</p>\r\n      <p>It should be noted that the Forms Authentication cookie is unprotected in the sense that it is vulnerable to HTTP Replay Attacks. As such, any page in a Forms Auth ASP.Net application that requires an authenticated user should only be accessible via SSL.</p>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Structure the URL namespace.</strong> Structure the application URL namespace to first separate the pages that require SSL from those that do not. Then define separate directories according to the various roles defined for your application. For instance you might have the following directories under your application root:</p>\r\n      <pre>//secure/usr/secure/admin</pre>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Use absolute URLs to transition to or from the sensitive portion of the namespace</strong>: Relative links use the same protocol (HTTP or HTTPS) as the current page. This can result in broken links that point to pages within your application that require SSL. It can also lead to unnecessary use of SSL, which does have an associated performance hit.</p>\r\n      <p>The fix for both of these issues is to use absolute URLs that explicitly specify the protocol instead of relative URLs. An example redirection using an absolute URL is shown below.</p>\r\n      <pre>private void btnLogon_Click(object sender, System.EventArgs e){<br />// Form an absolute path using the server name and virtual directory<br />namestring serverName =<br /> HttpUtility.UrlEncode(Request.ServerVariables[\"SERVER_NAME\"]);<br />string vdirName = Request.ApplicationPath;<br />Response.Redirect(<a>https://</a>+serverName+vdirName+\"/Restricted/Login.aspx\");}</pre>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Use URL Authorization Restrict Access</strong>: Use an <em>&lt;authorization&gt;</em> element to ensure that only authenticated users can access secure pages. Place this element beneath the closing <em>&lt;/system.web&gt;</em> tag, as shown here.</p>\r\n      <pre>&lt;!-- The secure folder is for authenticated and SSL access only. --&gt;<br />&lt;location path=\"Secure\" &gt;<br />  &lt;system.web&gt;<br />    &lt;authorization&gt;<br />      &lt;deny users=\"?\" /&gt;<br />    &lt;/authorization&gt;<br />  &lt;/system.web&gt;<br />&lt;/location&gt;</pre>\r\n      <p>Additionally, the following configuration ensures that unauthenticated users are allowed to access pages in the application's root directory. Place this configuration in the main <em>&lt;system.web&gt;</em> element.</p>\r\n      <pre>&lt;system.web&gt;<br />  &lt;!-- The virtual directory root folder contains general pages.<br />       Unauthenticated users can view them and they do not need<br />        to be secured with SSL. --&gt;<br />  &lt;authorization&gt;<br />    &lt;allow users=\"*\" /&gt;<br />  &lt;/authorization&gt;<br />&lt;/system.web&gt;</pre>\r\n      <p>\r\n        <strong>Note:</strong> If you use this type of site structure, your application must not rely on the user's identity on the non-SSL pages. In the preceding configuration, no forms authentication ticket is sent for requests for non-SSL pages. As a result, the user is considered anonymous. This has implications for related features, such as personalization, that require the user name.</p>\r\n    </li>\r\n  </ol>\r\n  <h1>Related Items</h1>\r\n  <em>You may find these additional articles useful</em>\r\n  <ul>\r\n    <li>\r\n      <a href=\"/article/0084ad05-fb00-4519-84b3-b983a9b0aee9\">Partition Application Between Public and Private Domains</a>\r\n    </li>\r\n  </ul>\r\n  <hr />\r\n  <p>Adapted from Microsoft patterns & practices guidance. </p>\r\n  <h1>\r\n  </h1>\r\n  <h1>\r\n  </h1>"
        ]
      }
    ]
  }
}