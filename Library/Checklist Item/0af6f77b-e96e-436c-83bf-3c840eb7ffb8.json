{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "1896533276",
      "Content_Hash": "864336511"
    },
    "Metadata": [
      {
        "Id": [
          "0af6f77b-e96e-436c-83bf-3c840eb7ffb8"
        ],
        "Id_History": [
          "0af6f77b-e96e-436c-83bf-3c840eb7ffb8,ff2144e7-12c6-407a-a1c3-ba1c70aaf443,"
        ],
        "Library_Id": [
          "26bd1a04-beed-4a66-917d-b6ab0a7d634c"
        ],
        "Title": [
          "ViewStateUserKey Is Used to Prevent Cross-Site Request Forgery"
        ],
        "Category": [
          "Session Management"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          ".NET"
        ],
        "Type": [
          "Checklist Item"
        ],
        "DirectLink": [
          "ViewStateUserKey Is Used to Prevent Cross-Site Request Forgery"
        ],
        "Tag": [
          ""
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<h1>Applies To</h1>\r\n  <ul>\r\n    <li>ASP.NET 4.0</li>\r\n  </ul>\r\n  <h1>What to Check For</h1>\r\n  <p>Check to ensure that all forms that require authentication or can be used to trigger important functionality are protected with <em>ViewStateUserKey</em>.</p>\r\n  <h1>Why</h1>\r\n  <p>A Cross-Site Request Forgery/one-click attack consists of posting a malicious HTTP form to a known, vulnerable Web site. It is called \"one-click\" because it usually begins with an unaware victim clicking on an alluring link received through e-mail or found when navigating a crowded forum.&nbsp; By following the link, the user inadvertently triggers a remote process that ends up submitting the malicious form to a site.&nbsp; This allows an attacker to perform any action caused by the vulnerable form with the credentials of the victim.</p>\r\n  <p>\r\n    <em>ViewStateUserKey</em> makes it much harder for hackers to use the content of the client-side view state to prepare malicious posts against the site.&nbsp; Each time a form is invoked, a unique key is generated.&nbsp; The key contains encrypted time and session information, and the form submission is rejected if it is used in another session or after the session timeout has expired. </p>\r\n  <h1>How To Check</h1>\r\n  <p>Use the following steps to check whether <em>ViewStateUserKey</em> is used properly:</p>\r\n  <ol>\r\n    <li>\r\n      <p>\r\n        <strong>Identify pages that should be protected. </strong>Review your application and make a list of all the forms that should be protected with <em>ViewStateUserKey</em>.&nbsp; Forms that meet either of the following criteria should be protected:</p>\r\n      <ul>\r\n        <li>The form requires authentication </li>\r\n        <li>The form triggers important application behavior or a write operation to a persistent store (eg. SQL database)</li>\r\n      </ul>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Check to see if the pages are protected. </strong>\r\n        <em>ViewStateUserKey</em> can be set per page or in the <em>OnInit</em> virtual method of the page-derived class.&nbsp; </p>\r\n      <ol>\r\n        <li>First check <em>OnInit</em>, if you find protection there, then all of your pages are covered.<br /><br /><pre>protected override OnInit(EventArgs e) {<br />&nbsp;&nbsp; base.OnInit(e); <br />&nbsp;&nbsp; ViewStateUserKey = Session.SessionID;<br />}</pre></li>\r\n        <li>Next check the individual pages, for instance:<br /><br /><pre>void Page_Init (object sender, EventArgs e) {<br />&nbsp;&nbsp; ViewStateUserKey = Session.SessionID;<br />}</pre></li>\r\n      </ol>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Ensure ViewStateUserKey is set properly. </strong>Setting <em>ViewStateUserKey</em> to a constant string—the same for all users—is like leaving it blank.&nbsp; It must be set to something that varies for each user—such as user ID or, better yet, session ID.&nbsp; For a number of technical and social reasons, session ID is a much better fit because a session ID is unpredictable, times out, and varies on a per-user basis. </p>\r\n    </li>\r\n  </ol>\r\n  <h1>How To Fix</h1>\r\n  <p>The&nbsp;following code added to each&nbsp;of your pages will set the key based on SessionID.</p>\r\n  <pre>void Page_Init (object sender, EventArgs e) {<br />   ViewStateUserKey = Session.SessionID;<br />}</pre>\r\n  <p>Alternatively, you can add this code to the <em>OnInit</em> virtual method of the <em>Page</em>-derived class.&nbsp; (Note that you must set this property in the <em>Page.Init</em> event).&nbsp; This will allow you to write the code once rather than per page.</p>\r\n  <pre>protected override OnInit(EventArgs e) {<br />   base.OnInit(e); <br />   ViewStateUserKey = Session.SessionID;<br />}</pre>\r\n  <h1>Related Items</h1>\r\n  <em>You may find these additional articles useful</em>\r\n  <ul>\r\n    <li>\r\n      <a href=\"/article/8f39bcc9-619b-479e-94b7-af822c7cc5fe\">Use Page ViewState User Key to Prevent CSRF</a>\r\n    </li>\r\n  </ul>\r\n  <hr />\r\n  <p>Adapted from Microsoft patterns & practices guidance. </p>"
        ]
      }
    ]
  }
}