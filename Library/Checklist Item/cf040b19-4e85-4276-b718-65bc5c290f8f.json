{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "-444390788",
      "Content_Hash": "-736737635"
    },
    "Metadata": [
      {
        "Id": [
          "cf040b19-4e85-4276-b718-65bc5c290f8f"
        ],
        "Id_History": [
          "cf040b19-4e85-4276-b718-65bc5c290f8f,a1484f9d-bc43-4145-827a-4025758df826,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "Parameterized APIs Are Used for Database Access"
        ],
        "Category": [
          "Database Security"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          ".NET"
        ],
        "Type": [
          "Checklist Item"
        ],
        "DirectLink": [
          "Parameterized APIs Are Used for Database Access"
        ],
        "Tag": [
          "ASP.NET,ASP.NET 4.0,ASP"
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "markdown"
        },
        "Data": [
          "## Applies To ##\r\n\r\n- ASP.NET 4.0\r\n\r\n\r\n## What to Check For ##\r\n\r\nEnsure that type-safe parameters are used when constructing dynamic SQL queries or when passing parameters to stored procedures.\r\n\r\n\r\n## Why ##\r\n\r\nIf you use the Parameters collection, SQL treats the input is as a literal value rather than as executable code. The Parameters collection can be used to enforce type and length constraints on input data. Values outside of the range trigger an exception.\r\n\r\nIf type-safe SQL parameters are not used, attackers might be able to execute injection attacks that are embedded in the unfiltered input.\r\n\r\n\r\n## How To Check ##\r\n\r\nTo check if parameterized queries are used:\r\n\r\n1. **Identify all database transactions.** Locate all SQL queries throughout your application. Example: `select user from myappUsers where user = ? and pass = ?;`\r\n\r\n2. **Verify that each transaction uses Stored Procedures where possible.** Verify that your application interacts with the backend database through the use of Stored Procedures. Ensure that SQL queries look like:\r\n\r\n        SqlCommand myCommand = new SqlCommand(\"sp_SelectUser\", myConnection);\r\n        //Specify our command is a stored procedure\r\n        myCommand.CommandType = CommandType.StoredProcedure; \r\n\r\n    and not like:\r\n\r\n        string SQLstr = \"SELECT * from users\r\n                 WHERE username = '\" + un.Text + \"'\r\n                 AND password = '\" + pass.Text + \"'\";\r\n        SqlCommand myCommand = new SqlCommand(SQLstr, myConnection);\r\n\r\n3. **Verify that type-safe parameters are used.** Verify that type-safe parameters are used in the dynamic SQL queries or stored procedures by using the SqlParameterCollection class. Example:\r\n\r\n        using (SqlConnection connection = new SqlConnection(connectionString))\r\n        {\r\n          connection.Open();\r\n          SqlDataAdapter myDataAdapter = new SqlDataAdapter(\r\n                 \"SELECT * from users WHERE username = '@uname'\r\n                  AND password = '@pwd'\", connection);\r\n          myCommand.SelectCommand.Parameters.Add(\"@uname\", SqlDbType.VarChar, 24);\r\n          myCommand.SelectCommand.Parameters.Add(\"@pwd\", SqlDbType.VarChar, 16);\r\n          myCommand.SelectCommand.Parameters[\"@uname\"].Value = un.Text;\r\n          myCommand.SelectCommand.Parameters[\"@pwd\"].Value = pass.Text;\r\n          myDataAdapter.Fill(userDataset);\r\n            ...\r\n          connection.Close();\r\n        }\r\n\r\n\r\n## How To Fix ##\r\n\r\nYou have two options for avoiding user input in dynamic SQL queries:\r\n\r\n1. **Use parameters with stored procedures.** Stored procedures alone will not prevent SQL injection. Lack of parameter usage means that stored procedures will be susceptible to SQL injection, especially if they use unfiltered input. The following code shows how to use SqlParameterCollection when calling a stored procedure:\r\n\r\n        using System.Data;\r\n        using System.Data.SqlClient;\r\n        using (SqlConnection connection = new SqlConnection(connectionString))\r\n        {\r\n          DataSet userDataset = new DataSet();\r\n          SqlDataAdapter myCommand = new SqlDataAdapter( \r\n                     \"LoginStoredProcedure\", connection);\r\n          myCommand.SelectCommand.CommandType = CommandType.StoredProcedure;\r\n          myCommand.SelectCommand.Parameters.Add(\"@au_id\", SqlDbType.VarChar, 11);\r\n          myCommand.SelectCommand.Parameters[\"@au_id\"].Value = AuthId.Text;\r\n          myCommand.Fill(userDataset);\r\n        }\r\n\t\r\n    In this case, the @au_id parameter is treated as a literal value and not as executable code. Also, the parameter is checked for type and length. In the preceding code example, the input value cannot be longer than 11 characters. If the data does not conform to the type or length defined by the parameter, the SqlParameter class throws an exception.\r\n\r\n2. **Use parameters with dynamic SQL.** If stored procedures are unavailable, use parameters when constructing dynamic SQL statements. The following code shows how to use SqlParametersCollection with dynamic SQL:\r\n\r\n        using System.Data;\r\n        using System.Data.SqlClient;\r\n        using (SqlConnection connection = new SqlConnection(connectionString))\r\n        {\r\n          DataSet userDataset = new DataSet();\r\n          SqlDataAdapter myDataAdapter = new SqlDataAdapter(\r\n                 \"SELECT au_lname, au_fname FROM Authors WHERE au_id = @au_id\", \r\n                 connection);                \r\n          myCommand.SelectCommand.Parameters.Add(\"@au_id\", SqlDbType.VarChar, 11);\r\n          myCommand.SelectCommand.Parameters[\"@au_id\"].Value = AuthId.Text;\r\n          myDataAdapter.Fill(userDataset);\r\n        }\r\n\r\n---\r\n\r\nAdapted from Microsoft patterns & practices guidance."
        ]
      }
    ]
  }
}