{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "26037445",
      "Content_Hash": "338443372"
    },
    "Metadata": [
      {
        "Id": [
          "bb200ff1-9bfb-4d7a-a048-575051c8c798"
        ],
        "Id_History": [
          "bb200ff1-9bfb-4d7a-a048-575051c8c798,400179a8-c124-4d82-b334-7d4ca6151f94,"
        ],
        "Library_Id": [
          "92718d53-36b2-47bc-b6f5-e60994385f46"
        ],
        "Title": [
          "Passwords Are Not Left in Memory"
        ],
        "Category": [
          "Authentication"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          ".NET 3.5"
        ],
        "Type": [
          "Checklist Item"
        ],
        "DirectLink": [
          "Passwords Are Not Left in Memory"
        ],
        "Tag": [
          ""
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          "2"
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<h1>What to Check For</h1>\r\n  <p>Ensure that passwords are cleared from memory after their use.</p>\r\n  <h1>Why</h1>\r\n  <p>Passwords are sensitive data that are used to establish a trust relationship. Leaving them in memory after their use can expose them to an attacker.</p>\r\n  <h1>How to Check</h1>\r\n  <ol>\r\n    <li>\r\n      <p>\r\n        <strong>Identify all password use. </strong>Examine your application and identify all places inside its code base that handle user passwords. Common places include:</p>\r\n      <ul>\r\n        <li>Creating new users </li>\r\n        <li>Modifying existing users </li>\r\n        <li>Changing credentials for existing users </li>\r\n        <li>Authenticating users</li>\r\n      </ul>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Verify that passwords are stored in mutable objects.</strong> Each identified password should be stored in a mutable object, such as a character array. This allows the password to be overwritten in memory and not rely on the garbage collector. Verify that passwords are not stored in immutable objects, such as .NET strings, that do not allow their memory space to be modified after being allocated.</p>\r\n      <p>Ensure that the memory containing the password is overwritten as quickly after use as possible. Ensure that passwords are not passed between function, class, or object boundaries except when absolutely necessary. Note in the examples below the difference between <strong>Byte</strong> and <strong>byte</strong>. .NET cannot guarantee that it will overwrite the same memory location in the heap that is already occupied by a <strong>Byte</strong>. However, if you overwrite a <strong>byte</strong> variable or an element inside a <strong>byte[]</strong>, then you have overwritten the same memory location that contains the actual data.</p>\r\n      <p>Examples of Mutable objects:</p>\r\n      <ul>\r\n        <li>char </li>\r\n        <li>char[] </li>\r\n        <li>byte </li>\r\n        <li>byte[]</li>\r\n      </ul>\r\n      <p>Examples of Immutable objects:</p>\r\n      <ul>\r\n        <li>string </li>\r\n        <li>Byte </li>\r\n        <li>Byte[] </li>\r\n        <li>Char</li>\r\n      </ul>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Verify that all password instances are cleared.</strong> Ensure that all the memory locations where passwords have been stored are cleared or overwritten after their use. Setting a pointer to NULL does not clear or overwrite the memory- a new value must be assigned to it. For a character array, setting each char to a new value, such as a space or a zero, will overwrite the value stored in memory. </p>\r\n      <p />Example of improper password removal: <p /><pre>char[] pass = GetPassword();<br />...<br />//insufficient for removing a password from memory<br />pass = null;</pre><p>Example of proper password removal:</p><pre>char[] pass = GetPassword();<br />...<br />//proper clearing of character array to remove data from memory<br />for(int i=0; i&lt;pass.Length; i++){<br />      pass[i] = ' ';<br />}<br />pass = null;</pre></li>\r\n  </ol>\r\n  <h1>Problem Example</h1>\r\n  <p>The following code makes a use of a password. Although the pointer to the string is removed and garbage collection is called, .NET does not guarantee the data will be erased.</p>\r\n  <p />\r\n  <pre>string pass = GetPassword();<br />...<br />pass = null;<br />GC.Collect();</pre>\r\n  <h1>Additional Resources</h1>\r\n  <ul>\r\n    <li>To learn more about .NET data types, visit: <a href=\"http://msdn.microsoft.com/en-us/magazine/cc301569.aspx\">.NET Type Fundamentals</a>.</li>\r\n  </ul>\r\n  <h1>Related Guideline</h1>\r\n  <ul>\r\n    <li>\r\n      <a href=\"/article/2120b3fe-34c6-47bf-be83-d9756e512d02\">Guideline: Do Not Leave Passwords in Memory&nbsp;</a>\r\n    </li>\r\n  </ul>\r\n  <hr />\r\n  <p>Adapted from Microsoft patterns & practices guidance. </p>"
        ]
      }
    ]
  }
}