{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "-997215159",
      "Content_Hash": "1632553163"
    },
    "Metadata": [
      {
        "Id": [
          "bc10306c-f37c-4780-a096-847070ae67da"
        ],
        "Id_History": [
          "bc10306c-f37c-4780-a096-847070ae67da,d3ab5eef-ce2f-47fd-a1e6-c28b09b47291,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "[SINK] Structured Exception Handling Is Used"
        ],
        "Category": [
          "Error and Exception Management"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          ".NET 3.5"
        ],
        "Type": [
          "Checklist Item"
        ],
        "DirectLink": [
          "Structured Exception Handling Is Used"
        ],
        "Tag": [
          "ASP.NET,ASP.NET 3.5,ASP"
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          "2"
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<h1>What to Check For</h1>\n  <p>Check to ensure structured exception handling is used to catch error conditions.</p>\n  <h1>Why</h1>\n  <p>Using exception handling helps to protect your application from denial of service attacks and&amp;nbsp;can be used to fail securely.&amp;nbsp;For instance, when using impersonation you can use exception handling to return to a lower privilege level in the event of an error.&amp;nbsp;Exception handling&amp;nbsp;also simplifies and de-clutters the application code, which improves robustness.</p>\n  <h1>How to Check</h1>\n  <p>All code in your application that may fail should either&amp;nbsp;be enclosed in a Try/Catch/Finally block or caught by a global exception handler.&amp;nbsp; While you should not catch exceptions that can not handle, catching exceptions close to the source can improve error messages both for user experience and debugging purposes.&amp;nbsp;&amp;nbsp;</p>\n  <p>The code that may fail should be enclosed in a Try statement such as:</p>\n  <p />\n  <pre>Try<br />&amp;#123;<br />    //error prone code<br />&amp;#125;</pre>\n  <p />\n  <p>A Catch block may follow the Try block if you want to execute error handling code including resource cleanup necessary in an error condition and any work needed to fail to a secure state.&amp;nbsp; Catch blocks are the right place to do exception logging and&amp;nbsp;add more information to the existing exception.&amp;nbsp; In most cases you should rethrown the exception so that exception handlers above your code can react appropriately.&amp;nbsp;You should only consume an exception if you can handle the error completely:</p>\n  <p />\n  <pre>Catch(SomeExceptionClass e)<br />&amp;#123;<br />    //error handling code<br />&amp;#125;</pre>\n  <p />\n  <p>It is ok to use Try/Finally without a Catch block, especially when you cannot handle the exception and just need to make sure cleanup code is run.&amp;nbsp; You should next create a Finally block that performs cleanup or any other operations that should occur regardless of whether the code succeeds or fails</p>\n  <p />\n  <pre>Finally<br />&amp;#123;<br />    //resource cleanup code<br />&amp;#125;</pre>\n  <h1>How to Fix</h1>\n  <p>Use Try/Catch/Finally blocks to catch exceptions thrown by code that may fail.&amp;nbsp; Use Try/Finally to ensure resources are disposed properly regardless of an error condition. Use a global error handler to catch exceptions not caught directly in the code.</p>\n  <h1>Problem Example</h1>\n  <p>An ASP.NET application has code to connect to a SQL database.&amp;nbsp; However, the code is not wrapped with an exception handler and when the connection times out the application fails, then displays exception details to the user including sensitive SQL database information.</p>\n  <pre>  protected void Page_Load(object sender, EventArgs e)<br />  &amp;#123;<br />      using (SqlConnection cn = new SqlConnection(ConfigurationManager.ConnectionStrings&amp;#91;\"MyDbConn\"&amp;#93;.ToString()))<br />      &amp;#123;<br />          SqlCommand cmd = new SqlCommand(\"SELECT COUNT(&amp;#42;) FROM authors\", cn);<br />          cn.Open();<br />          SqlDataReader rdr = cmd.ExecuteReader(CommandBehavior.CloseConnection);<br />          rdr.Read();<br />          Response.Write(rdr&amp;#91;0&amp;#93;.ToString());<br />&amp;#9; //read a value<br />      &amp;#125;<br />  &amp;#125;&amp;nbsp;</pre>\n  <h1>Solution Example</h1>\n  <p>An ASP.NET application has code to connect to a SQL database.&amp;nbsp; The code is wrapped with an exception handler and when the connection times out the application handles the error gracefully.</p>\n  <pre>using System.Data.SqlClient;<br />using System.Security;<br />SqlConnection conn = new SqlConnection(\"...\");<br />try&amp;#123;<br />    conn.Open();<br />    // Do some operation that might cause an exception.<br />    // Calling Close as early as possible.<br />    conn.Close();<br />    // ... other potentially long operations.<br />&amp;#125;<br />finally&amp;#123;<br />    if (conn.State==ConnectionState.Open)<br />        conn.Close();<br />  // ensure that the connection is closed.<br />&amp;#125;</pre>\n  <h1>Related Items</h1>\n  <ul>\n    <li>\n      <a href=\"/article/2e16a65a-25d2-4ea9-a513-e020d2408241\">Global Error Handlers are used to Catch Unhandled Exceptions</a>\n      <li>\n        <a href=\"/article/9557bf26-cc8e-4bcc-8588-3e07d127b4fc\">Use Structured Exception Handling</a>\n        <li>\n          <a href=\"/article/33a894ce-2061-4741-be92-1d063c9cf057\">Use a Global Exception Handler for Unhandled Exceptions</a>\n        </li>\n      </li>\n    </li>\n  </ul>\n  <hr />\n  <p>Adapted from Microsoft patterns &amp; practices guidance. </p>"
        ]
      }
    ]
  }
}