{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "-1135052223",
      "Content_Hash": "15474628"
    },
    "Metadata": [
      {
        "Id": [
          "a61487db-d1e1-4304-89b1-44bb8c88b1e3"
        ],
        "Id_History": [
          "a61487db-d1e1-4304-89b1-44bb8c88b1e3,a5256e2d-27bd-4915-8e41-c36ea3b7bfa9,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "All Data Passed Between Native And Java Code Is Validated"
        ],
        "Category": [
          "Unmanaged Code"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          "Java"
        ],
        "Type": [
          "Checklist Item"
        ],
        "DirectLink": [
          "All Data Passed Between Native And Java Code Is Validated"
        ],
        "Tag": [
          ""
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          "2"
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "markdown"
        },
        "Data": [
          "## Applies To ##\n\n- Java\n\n\n## What to Check For ##\n\nVerify that your application validates all data that is passed between Java code and native code.\n\n\n## Why ##\n\nUnchecked input passed to native code can lead to buffer overflows and other vulnerabilities that are typical for non-managed code.\n\n\n## How to Check ##\n\nDue to the security risk posed by the use of native code, verify that your application validates data that is passed between native code and Java:\n\n1. **Check if language boundaries are clearly defined.** If your Java application needs to use native code, ensure that you have identified all the locations where the Java code interacts with native code. As your application moves between Java code and native code, special attention needs to be given to error handling routines, so that no security holes are introduced in your application by its native component.\n\n2. **Verify the quality of your application's validators.** Verify that your application's data is properly validated for length, range, format and type.\n\n3. **Verify that all data is validated.** Verify that all data passing through the locations identified in Step 1 is validated.\n\n4. **Ensure that data validation code is centralized.** It is better that all validation routines in your application are centralized for cleaner and better control. Shared validation routines are better than creating many spread throughout your application's code base. Every time your application accepts external data as input, it should first pass through this set of validation routines.\n\n\n## How to Fix ##\n\nThere are several things to consider when validating input/output between native and Java code:\n\n1. **Check language barriers.** Distinguishing the boundaries between native and Java code is very important. Because the Java sandbox provides multiple security checks to its code, it is important to know the boundary between where the Java sandbox ends and the compiled code begins to interact directly with the CPU, so you can compensate for the lack of such checks inside the native code.\n\n2. **Validate for length, range, format and type.** After discovering the language boundaries, determine the type, format and structure of the data that is passed between Java and native code. Build a validator for each type of data that is passed between the two environments.\n\n3. **Construct a set of validators.** Centralize your application's validators as it helps strengthen the code by limiting the amount of scattered validation code throughout your application. Place the set of validators on the language barriers. Your application should pass data between native and Java code only through its set of validators.\n\n\n## Problem Example ##\n\nThe following segment shows a JNI code that utilizes a COM object. Making the assumption that the Java code will handle data validation, the JNI segment does not verify that the passed input is a valid GUID. Since invalid GUIDs may cause unhandled exceptions, an attacker can force the application to disclose its call stack and possibly its source filenames.\n\n\t#include <jni.h>\n\t#include <sys/types.h>\n\t#include <fcntl.h>\n\t#include <stdio.h>\n\t#include <atlbase.h>\n\t#include <windows.h>\n\t#include <wtypes.h>\n\tJNIEXPORT jboolean\n\tJNICALL Java_Identifier_invokeObject\n\t\t  (JNIEnv * env, jobject jobj, jstring jguid)\n\t{\n\t\t  HRESULT result;\n\t\t  CLSID clsid;\n\t\t  IUnknown *pIunkn;\n\t\t  LPWSTR guid;\n\t\t  jboolean iscopy;\n\t\t  jboolean ret = false;\n\t\t  char* temp_guid = (*env)->GetStringUTFChars(env, jguid, &iscopy);\n\t\t  //The application fails to verify that the GUID is valid\n\t\t  guid = SysAllocStringLen(0, 38);\n\t\t  MultiByteToWideChar(CP_ACP, 0, temp_guid, -1, guid, 38);\n\t\t  result = GUIDFromString(guid, &clsid);\n\t\t  ...\n\t\t  return ret;\n\t}\n\n\t\n## Solution Example ##\n\nThe following segment shows a JNI code that utilizes a COM object. Because the passed input is validated as being a GUID, the application reduces the risk of unhandled exceptions.\n\n\t#include <jni.h>\n\t#include <sys/types.h>\n\t#include <fcntl.h>\n\t#include <stdio.h>\n\t#include <atlbase.h>\n\t#include <windows.h>\n\t#include <wtypes.h>  \n\tJNIEXPORT jboolean \n\tJNICALL Java_Identifier_invokeObject\n\t\t  (JNIEnv * env, jobject jobj, jstring jguid)\n\t{\n\t\t  HRESULT result;\n\t\t  CLSID clsid;\n\t\t  IUnknown *pIunkn;\n\t\t  LPWSTR guid;\n\t\t  jboolean iscopy;\n\t\t  jboolean ret = false;\n\t\t  char* temp_guid = (*env)->GetStringUTFChars(env, jguid, &iscopy);\n\t\t  // The application verifies that the input matches the criteria for a GUID\n\t\t  if(!validGUID(temp_guid))\n\t\t  {\n\t\t\t\treturn ret;\n\t\t  }\n\t\t  guid = SysAllocStringLen(0, 38);\n\t\t  MultiByteToWideChar(CP_ACP, 0, temp_guid, -1, guid, 38);\n\t\t  result = GUIDFromString(guid, &clsid);\n\t\t   ...\n\t\t  return ret;\n\t}\n\n\tbool validGUID(char *guid)\n\t{\n\t\t  // Check that GUID is of right length\n\t\t  if(strlen(guid) != 38) return false;\n\t\t  // Sample GUID: {1EF4A023-143A-4e0e-AD72-69C2C68C2D70\n\t}\n\t\t  if(guid[0]  != '{') return false;\n\t\t  if(guid[9]  != '-') return false;\n\t\t  if(guid[14] != '-') return false;\n\t\t  if(guid[19] != '-') return false;\n\t\t  if(guid[24] != '-') return false;\n\t\t  if(guid[37] != '}') return false;\n\t\t  int i=1;\n\t\t  while(i<37)\n\t\t  {\n\t\t\t\tif((guid[i] >= 'a' && guid[i] <= 'f')\n\t\t\t\t\t  || (guid[i] >= 'A' && guid[i] <= 'F')\n\t\t\t\t\t  || (guid[i] >= '0' && guid[i] <= '9')\n\t\t\t\t{\n\t\t\t\t\t  // GUID is valid\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t  return false;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t\tif(i == 9 || i == 14 || i == 19 || i == 24)\n\t\t\t\t{\n\t\t\t\t\t  i++;\n\t\t\t\t}\n\t\t  }\n\n\t\t  return true;\n\t}"
        ]
      }
    ]
  }
}