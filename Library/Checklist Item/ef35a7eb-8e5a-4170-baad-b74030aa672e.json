{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "-231959563",
      "Content_Hash": "510090509"
    },
    "Metadata": [
      {
        "Id": [
          "ef35a7eb-8e5a-4170-baad-b74030aa672e"
        ],
        "Id_History": [
          "ef35a7eb-8e5a-4170-baad-b74030aa672e,6f8f6066-c42c-4804-a6e6-7bed3675354f,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "[SINK] Where Appropriate, SecureString Is Used Rather than System.String."
        ],
        "Category": [
          "Cryptography"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          ".NET 3.5"
        ],
        "Type": [
          "Checklist Item"
        ],
        "DirectLink": [
          "Where Appropriate, SecureString Is Used Rather than System.String."
        ],
        "Tag": [
          ""
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<h1>What to Check For</h1>\r\n  <p>Check to ensure that SecureString is used to help protect secrets in memory&amp;nbsp;rather than using System.String.</p>\r\n  <p />\r\n  <h1>How to Fix</h1>\r\n  <p>Consider using the <b>System.Security.SecureString</b> type to help protect secrets in memory. <b>SecureString</b> objects use DPAPI encryption to store data in an encrypted format in memory. They are only decrypted when they are accessed. Although you have to decrypt the data to use it, by using <b>SecureString</b> instead of <b>System.String</b> you gain a number of benefits: </p>\r\n  <ul>\r\n    <li>You help to minimize the number of copies of the secret held in memory, which reduces the attack surface. <li>You reduce the amount of time that the secret is visible to an attacker who has access either to your process memory address space or to the page file. <li>You increase the likelihood that an encrypted version of the secret rather than a clear text version will end up in a dump file if your process crashes. </li></li></li>\r\n  </ul>\r\n  <blockquote>\r\n    <b>Note</b>&amp;nbsp;&amp;nbsp;&amp;nbsp;Unfortunately, in many scenarios you are forced to convert the <b>SecureString</b> to a <b>System.String</b> before you can use it. For example, few .NET Framework API methods currently provide overloads that support <b>SecureString</b>. Use of <b>SecureString</b> is less appropriate in ASP.NET applications. For example, It is unlikely you can take a credit card number from a Web page without the number at some point passing through a <b>System.String</b> because most of the form-related APIs do not have function overloads that permit use of <b>SecureString</b> instead of <b>System.String</b>.</blockquote>\r\n  <h3>Creating a SecureString</h3>\r\n  <p>You can create a <b>SecureString</b> by supplying a pointer to a character array and supplying the length of that array. When constructed this way, the <b>SecureString</b> type takes a copy of your array. You should replace your source array with zeros as soon as the <b>SecureString</b> is constructed. A <b>SecureString</b> can also be constructed without an existing character array, and data can be copied one character at a time. The following code sample shows how to use the <b>AppendChar</b> method to create a secure string one character at a time.</p>\r\n  <div>\r\n    <pre>using System.Security;<br />...<br />SecureString securePassword = new SecureString();<br /> Console.WriteLine(\"Enter Password....\");<br /> while (true)<br /> &amp;#123;<br />  ConsoleKeyInfo conKeyInfo = Console.ReadKey(true);<br />  if (conKeyInfo.Key == ConsoleKey.Enter)<br />      break;<br />  else if (conKeyInfo.Key == ConsoleKey.Escape)<br />      return;<br />  else if (conKeyInfo.Key == ConsoleKey.Backspace)<br />  &amp;#123;<br />     if (securePassword.Length &amp;#33;= 0)<br />        securePassword.RemoveAt(securePassword.Length - 1);<br />  &amp;#125;<br />  else<br />     securePassword.AppendChar(conKeyInfo.KeyChar);<br />&amp;#125;<br />Console.WriteLine(securePassword.Length.ToString());  </pre>\r\n  </div>\r\n  <h3>Retrieving Data from a SecureString</h3>\r\n  <p>You retrieve data from a <b>SecureString</b> by using the marshaller. The <b>Marshal</b> class has been extended to provide methods that convert a <b>SecureString</b> into a <b>BSTR</b> data type or a raw block of ANSI or Unicode memory. When you have finished using the unprotected string, you should erase that copy by calling <b>Marshal.ZeroFreeBSTR</b>, as shown in the following example.<b></b></p>\r\n  <div>\r\n    <pre>using System.Security;using System.Runtime.InteropServices;<br />...<br />void UseSecretData(SecureString secret)<br />&amp;#123;<br />  IntPtr bstr = Marshal.SecureStringToBSTR(secret);<br />  try<br />  &amp;#123;<br />    // Use the bstr here<br />  &amp;#125;<br />  finally<br />  &amp;#123;<br />    // Make sure that the clear text data is zeroed out<br />    Marshal.ZeroFreeBSTR(bstr);<br />  &amp;#125;<br />&amp;#125;  </pre>\r\n  </div>\r\n  <h3>Why Not Use System.String?</h3>\r\n  <p>Using <b>System.String</b> for storing sensitive information is not recommended for the following reasons: </p>\r\n  <ul>\r\n    <li>It is not pinned, which means that the garbage collector can move it around and leave the data in memory for indeterminate amounts of time. <li>It is not encrypted; therefore, the data can be read from process memory or from the swap file. <li>It is immutable; therefore, there is no effective way of clearing the data after use. Modification leaves both the old copy and a new copy in memory.</li></li></li>\r\n  </ul>\r\n  <hr />\r\n  <p>Adapted from Microsoft patterns &amp; practices guidance.</p>"
        ]
      }
    ]
  }
}