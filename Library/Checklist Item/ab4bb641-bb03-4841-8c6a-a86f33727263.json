{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "1273973815",
      "Content_Hash": "-1327884921"
    },
    "Metadata": [
      {
        "Id": [
          "ab4bb641-bb03-4841-8c6a-a86f33727263"
        ],
        "Id_History": [
          "ab4bb641-bb03-4841-8c6a-a86f33727263,585828bc-06d7-4f7d-94fc-46d6939abe45,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "0sink Client-Side Validation Is Not Relied On"
        ],
        "Category": [
          "Input and Data Validation"
        ],
        "Phase": [
          "Design"
        ],
        "Technology": [
          ".NET 3.5"
        ],
        "Type": [
          "Checklist Item"
        ],
        "DirectLink": [
          "Client-Side Validation Is Not Relied On"
        ],
        "Tag": [
          "ASP.NET,ASP.NET 3.5,ASP"
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          "1"
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<h1>What to Check For</h1>\r\n  <p>Verify that the same or more rigorous checks are performed on the server as on&amp;nbsp;the client. Verify that client-side validation is used only for usability and to reduce the number of posts to the server.</p>\r\n  <h1>Why</h1>\r\n  <p>Client-side validation can be easily bypassed. For example, a malicious user could disable the client-side script routines by disabling JavaScript. Users may also construct their own form posts using custom HTML, or using an HTTP proxy to modify form posts. If developers rely on the controls in the client's user interface and do not validate all results on the back end, an attacker may be able to inject malicious data into the system,&amp;nbsp;potentially&amp;nbsp;leading to a range of security issues, including cross site scripting and SQL injection.</p>\r\n  <h1>How to Check</h1>\r\n  <p>Client-side validation should only be used to reduce round trips to the server and to improve the user experience. It cannot be relied upon for security&amp;nbsp;because the client controls this code. Take the following steps to ensure that input is validated on the server:</p>\r\n  <ol>\r\n    <li>\r\n      <p>\r\n        <strong>Identify all input validation routines in client-side code. </strong>Ensure that you have identified all the routines in your web pages that validate input received from the user. These client-side validation routines usually include checks for length, range, format, and type on the input received. Some examples of client-side validators are:</p>\r\n      <ul>\r\n        <li>Form controls such as those that restrict the number of characters allowed using the <strong>MAXLENGTH</strong> attribute and the range of input values allowed in drop-down boxes. <li>Javascript validation routines that check the length, range, type, format, etc. <li>Hidden fields which are sometimes used&amp;nbsp;to impose constraints on the input. Although the actual validation happens on the server, it is easy to tamper with the hidden fields on the client side.</li></li></li>\r\n      </ul>\r\n      <li>\r\n        <p>\r\n          <strong>Ensure that corresponding server-side validation routines exist. </strong>For all client-side validation routines that have been identified, check that similar, or more rigorous, validation routines have been implemented on the server side. This protects your application from cross-site scripting, SQL injection or other types of attacks in which the client-side validation has been bypassed by an attacker. The server can be easily&amp;nbsp;tested by disabling Javascript and modifying the client-side code or by using an HTTP&amp;nbsp;proxy application.</p>\r\n        <li>\r\n          <p>\r\n            <strong>Ensure that missing server-side validation routines are implemented. </strong>For all input that is validated on the client but not on the server, add server-side validation routines which are no less strict than the validation performed on the client. Also add validation routines for any input received from the user that is not validated on the client. Examples are validation of cookies, hidden fields, ViewState, etc.</p>\r\n        </li>\r\n      </li>\r\n    </li>\r\n  </ol>\r\n  <h1>Problem Example</h1>\r\n  <p>Consider a very simple form where a user is asked to enter their name and email address:</p>\r\n  <pre>&lt;form id=\"form1\" runat=\"server\"&gt;<br />&lt;asp:textbox id=\"txtName\" runat=\"server\"&gt;<br />&lt;/asp:textbox&gt;&lt;asp:textbox id=\"txtEmail\" runat=\"server\"&gt;<br />&lt;/asp:textbox&gt;&lt;asp:button id=\"btnSubmit\" runat=\"server\" text=\"Submit\" onclientclick=\"return cValidate()\"/&gt;<br />&lt;/form&gt;<br />&lt;script language=\"javascript\" type=\"text/javascript\"&gt;function cValidate()<br />&amp;#123;<br />      if (document.getElementById(\"&lt;&amp;#37;=txtName.ClientID&amp;#37;&gt;\").value==\"\")<br />      &amp;#123;<br />                 alert(\"Name Field cannot be blank\");<br />                 document.getElementById(\"&lt;&amp;#37;=txtName.ClientID&amp;#37;&gt;\").focus();<br />                 return false;<br />      &amp;#125;<br />      if(document.getElementById(\"&lt;&amp;#37;=txtEmail.ClientID &amp;#37;&gt;\").value==\"\")<br />      &amp;#123;<br />                 alert(\"Email Field cannot be blank\");<br />                 document.getElementById(\"&lt;&amp;#37;=txtEmail.ClientID &amp;#37;&gt;\").focus(); <br />                 return false;<br />      &amp;#125;<br />      var emailPat = /&amp;#94;(\\\".&amp;#42;\\\"&amp;#124;&amp;#91;A-Za-z&amp;#93;\\w&amp;#42;)&amp;#64;(\\&amp;#91;\\d&amp;#123;1,3&amp;#125;(\\.\\d&amp;#123;1,3&amp;#125;)&amp;#123;3&amp;#125;&amp;#93;&amp;#124;&amp;#91;A-Za-z&amp;#93;\\w&amp;#42;(\\.&amp;#91;A-Za-z&amp;#93;\\w&amp;#42;)&amp;#43;)&amp;#36;/;<br />      var emailid=document.getElementById(\"&lt;&amp;#37;=txtEmail.ClientID &amp;#37;&gt;\").value;<br />      var matchArray = emailid.match(emailPat);<br />      if (matchArray == null)<br />      &amp;#123;<br />               alert(\"Your email address seems incorrect. Please try again.\");<br />               document.getElementById(\"&lt;&amp;#37;=txtEmail.ClientID &amp;#37;&gt;\").focus();<br />               return false;<br /> &amp;#125;<br /> return true;<br />&amp;#125;<br />&lt;/script&gt;</pre>\r\n  <p>This page validates the user's input for validity but does so on the client using JavaScript. This type of validation can be bypassed by an attacker who disables JavaScript, replaces the validation script, or edits the data as the browser is submitting it using an&amp;nbsp;HTTP proxy.</p>\r\n  <h1>Additional Resources</h1>\r\n  <ul>\r\n    <li>For more information on input validation, see: <a href=\"http://msdn2.microsoft.com/en-us/library/ms998372.aspx#pagpractices0001_inputanddatavalidation\">Security Practices: Input and Data Validation</a> in MSDN. <li>For an example of an excellent debugging HTTP proxy, check out the <a href=\"http://www.fiddlertool.com/\">Fiddler.</a></li></li>\r\n  </ul>\r\n  <h1>Related Items</h1>\r\n  <ul>\r\n    <li>\r\n      <a href=\"/article/6e981095-84bd-4158-a212-8f9937bcb336\">Guideline: Do Not Rely on Client-Side Validation (ASP.NET)</a>\r\n      <li>\r\n        <a href=\"/article/b3a939b6-732f-49d0-b204-0422dbfbdbaa\">Input is Validated for Length, Range, Format, and Type</a>\r\n      </li>\r\n    </li>\r\n  </ul>\r\n  <hr />\r\n  <p>Adapted from Microsoft patterns &amp; practices guidance. </p>"
        ]
      }
    ]
  }
}