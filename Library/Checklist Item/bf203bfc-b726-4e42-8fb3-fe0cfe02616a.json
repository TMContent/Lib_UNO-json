{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "257597250",
      "Content_Hash": "1671188109"
    },
    "Metadata": [
      {
        "Id": [
          "bf203bfc-b726-4e42-8fb3-fe0cfe02616a"
        ],
        "Id_History": [
          "bf203bfc-b726-4e42-8fb3-fe0cfe02616a,c40ec881-bd3d-4ba6-b97a-92813232a969,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "User-Supplied Filenames And Paths Are Validated"
        ],
        "Category": [
          "Input and Data Validation"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          ".NET"
        ],
        "Type": [
          "Checklist Item"
        ],
        "DirectLink": [
          "User-Supplied Filenames And Paths Are Validated"
        ],
        "Tag": [
          "ASP.NET,ASP.NET 3.5,ASP"
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          "2"
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<h1>What to Check For</h1>\n  <p>Ensure&amp;nbsp;that user supplied filename and path input is carefully validated and that the input is checked for format and validity of location within the context of the application.</p>\n  <h1>Why</h1>\n  <p>Filtering paths and filenames helps to avoid a Canonicalization Attack where your application&amp;nbsp;can be&amp;nbsp;made to read or write to arbitrary files on the server.</p>\n  <h1>How to Check</h1>\n  <p>Make these checks&amp;nbsp;to ensure that user-supplied filename and path input have been validated:</p>\n  <ol>\n    <li>\n      <p>\n        <strong>Check that file names and paths have been validated. </strong>The best security practice is to avoid accepting user-supplied file name or path input. If this is not feasible, then ensure that the <strong>System.IO.Path.GetFullPath</strong> method has been used to canonicalize the input before using it to access the file.</p>\n    </li>\n    <li>\n      <p>\n        <strong>Ensure that MapPath has been used to prevent cross application mapping. </strong>In order to constrain file access to the application's virtual directory hierarchy, check that the overloaded <strong>Request.MapPath</strong> method,&amp;nbsp;which accepts a <strong>bool</strong> parameter, has been used. This method prevents cross-application mapping by throwing an exception when an attempt is made to traverse outside the virtual directory when its last parameter is set to 'false'. </p>\n      <pre>try<br />{<br />    string mappedPath = Request.MapPath( inputPath.Text,<br />     Request.ApplicationPath, false);<br />}<br />catch (HttpException)<br />{<br />    // Cross-application mapping attempted<br />}</pre>\n    </li>\n    <li>\n      <p>\n        <strong>Verify that Code Access Security has been used to restrict File IO. </strong>You can also restrict the file operations to the application's virtual directory hierarchy using Code Access Security. This can be implemented by setting the trust level to 'medium' in the application's Web.config or the machine-level Machine.config file. Use Web.config to configure a specific application and Machine.config to configure all the applications hosted on the server.</p>\n      <pre>...<br />&lt;location allowOverride=\"false\"&gt;<br /> &lt;system.web&gt;<br /> ...<br /> &lt;trust level=\"Medium\" originUrl=\"\"/&gt;<br /> ...<br /> &lt;/system.web&gt;<br /> ...<br />&lt;/location&gt;<br />...</pre>\n    </li>\n  </ol>\n  <h1>Problem Example</h1>\n  <p>In the following code example, the server receives a filename from the user. The server appends the user-supplied filename to the a hardcoded path and verifies to see if this file exists on the server. If the file exists, the server opens the file and performs operations on it.</p>\n  <pre>&lt;%@ Page Language=\"C#\" ValidateRequest=\"false\" %&gt;<br /> &lt;script runat=\"server\"&gt;<br />   void submitBtn_Click(object sender, EventArgs e)<br />   {<br />             String fileName = \"c:\\\\configfiles\\\\\" + inputPath.Text;<br />       if (System.IO.File.Exists (fileName))<br />       {<br />            System.IO.FileStream fs = System.IO.File.Open(fileName, System.IO.FileMode.Open);<br />       }<br />   }<br /> &lt;/script&gt;<br /> &lt;html xmlns=\"http://www.w3.org/1999/xhtml\" &gt;<br />   &lt;body&gt;<br />     &lt;form id=\"form1\" runat=\"server\"&gt;<br />       &lt;div&gt;<br />         &lt;asp:TextBox ID=\"inputPath\" Runat=\"server\"<br />              TextMode=\"MultiLine\" Width=\"382px\" Height=\"152px\"&gt;<br />         &lt;/asp:TextBox&gt;<br />         &lt;asp:Button ID=\"submitBtn\" Runat=\"server\" Text=\"Submit\"<br />                     OnClick=\"submitBtn_Click\" /&gt;<br />       &lt;/div&gt;<br />     &lt;/form&gt;<br />   &lt;/body&gt;<br /> &lt;/html&gt;</pre>\n  <p>Here one can clearly notice that the intention of the developer is to limit access to the <strong>C:\\ConfigFiles</strong> folder. However, if a user supplied the input \"..\\windows\\system32\\critical.ini\" then the application will join the user-supplied input with the hardcoded path and give the attacker access to critical system files.</p>\n  <br />\n  <hr />\n  <p>Adapted from Microsoft patterns &amp; practices guidance. </p>"
        ]
      }
    ]
  }
}