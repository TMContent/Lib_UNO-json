{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "1169611794",
      "Content_Hash": "2120900240"
    },
    "Metadata": [
      {
        "Id": [
          "5338f3dc-2b13-41d1-9515-9c3c3ec448fe"
        ],
        "Id_History": [
          "5338f3dc-2b13-41d1-9515-9c3c3ec448fe,b80a1f4b-5d05-4e04-9e5a-11fd6ca77871,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "A Security Policy Is Defined"
        ],
        "Category": [
          "Other"
        ],
        "Phase": [
          "Design"
        ],
        "Technology": [
          "Java"
        ],
        "Type": [
          "Checklist Item"
        ],
        "DirectLink": [
          "A Security Policy Is Defined"
        ],
        "Tag": [
          ""
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          "2"
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<h1>What to Check For</h1>\r\n  <p>Ensure that your application has a defined security policy that applies the principle of least privilege. Restrict application execution to only allow the minimum set of necessary actions.</p>\r\n  <h1>Why</h1>\r\n  <p>Defining a Java security policy is a defense in-depth mechanism for&nbsp;preventing your application from performing tasks that the operating system would otherwise allow. This is especially important&nbsp;if your application becomes compromised by an attacker.</p>\r\n  <h1>How to Check</h1>\r\n  <p>Your application's security policy should be based on your business requirements. Use the following steps to ensure that your application implements and deploys a security policy that matches your organization's business requirements:</p>\r\n  <ol>\r\n    <li>\r\n      <p>\r\n        <strong>Identify assets that need to be protected. </strong>Review your application's threat model documentation and enumerate all system resources that you need to protect. Common resources that need protection include:</p>\r\n      <ul>\r\n        <li>Files - upload and download code</li>\r\n        <li>Sockets - code that enables listener sockets or code that makes connections to backend systems</li>\r\n        <li>System properties </li>\r\n        <li>Network connections </li>\r\n        <li>Database operations </li>\r\n        <li>Runtime operations</li>\r\n      </ul>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Ensure each asset is protected by the correct permissions and actions. </strong>Using the principle of least privilege, determine the appropriate permissions and actions that need to be granted for each identified resource. Verify that a <em>codeBase</em> attribute is associated with each granted permission. Without the attribute, the resource can be accessed by any of your application's components. For instance, the following entry from the security policy grants a global permission to read the file <em>/tmp/myfile</em>:</p>\r\n      <pre>grant<br />{<br />    permission java.io.FilePermission \"/tmp/myfile\", \"read\";<br />};</pre>\r\n      <p>Instead, include the <em>codeBase</em> that would restrict read access only to components located in<strong></strong><em>/usr/myapp/</em>: </p>\r\n      <pre>grant <strong>codeBase \"file:/usr/myapp/\"<br /></strong>{<br />    permission java.io.FilePermission \"/tmp/myfile\", \"read\";<br />};</pre>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Ensure your security policy is enforced. </strong>Your application's security policies will be enforced only when they are loaded into the Java Runtime. To make sure your security policies will be enforced:</p>\r\n      <ul>\r\n        <li>\r\n          <p>\r\n            <strong>System-wide security properties:</strong> Check if your security policy is included in the system-wide security properties file (<em>&lt;java home&gt;/lib/security/java.security</em>). Example:</p>\r\n          <pre># Class to instantiate as the system Policy. This is the name of the class<br /># that will be used as the Policy object.<br />#<br />policy.provider=sun.security.provider.PolicyFile<br /><br /># The default is to have a single system-wide policy file,<br /># and a policy file in the user's home directory.<br />policy.url.1=file:${java.home}/lib/security/java.policy<br />policy.url.2=file:${user.home}/myapp.java.policy</pre>\r\n        </li>\r\n        <li>\r\n          <p>\r\n            <strong>Command line:</strong> Check if your application's environment is configured to start with the <em>-Djava.security.manager</em> and <em>-Djava.security.policy</em> flags:</p>\r\n          <pre>java <strong>-Djava.security.manager<br /></strong><strong>-Djava.security.policy=/usr/myapp/myapp.java.policy</strong> &lt;application server&gt;</pre>\r\n        </li>\r\n        <li>\r\n          <p>\r\n            <strong>System object:</strong> Check if your application verifies whether a <em>SecurityManager</em> object has been assigned within the System object: </p>\r\n          <pre>if (System.getSecurityManager() == null)<br />{<br />      System.setSecurityManager(new SecurityManager());<br />}</pre>\r\n        </li>\r\n      </ul>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Ensure your application's security policy is protected. </strong>Use the following steps to verify that your application's security policy is protected: </p>\r\n      <ul>\r\n        <li>\r\n          <strong>On disk:</strong> Verify that your application's security policy is accessible only by your application and its administrators. Ensure that the security policy has the right filesystem permissions set and is not accessible via the web. </li>\r\n        <li>\r\n          <strong>In memory:</strong>&nbsp;Verify that&nbsp;your application's security policy is enforced at start-up. Ensure that your application has a dedicated Policy Manager for handling any policy modifications during runtime.</li>\r\n      </ul>\r\n    </li>\r\n  </ol>\r\n  <h1>How to Fix</h1>\r\n  <p>Although Java applications run inside a virtual machine, do not execute your application in the context of a privileged user. Consider tightening the restrictions on your application by employing Java Policies.</p>\r\n  <p>Use the following steps to successfully utilize Java Permissions:</p>\r\n  <ol>\r\n    <li>\r\n      <p>\r\n        <strong>Identify the system resources that your application uses. </strong>Enumerate all resources that your application will need to access. Identify the types of permissions that your application requires to access those resources. For example, your application will need to connect to your database via a socket connection or write to your logs.</p>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Identify your application. </strong>Your application can be identified via two ways inside a Java policy â€” code signing or code base.</p>\r\n      <ul>\r\n        <li>\r\n          <p>\r\n            <strong>Code signing.</strong> Always sign your code whenever possible. This ensures the authenticity of your code. Use Java's KeyTool when signing your code.</p>\r\n        </li>\r\n        <li>\r\n          <p>\r\n            <strong>Code base.</strong> Identify the location of your code. Example:</p>\r\n          <pre>codeBase \"file:e:/myapp/bin/\"</pre>\r\n        </li>\r\n      </ul>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Create the appropriate policy. </strong>Once all required resources are enumerated, create a Java policy that reflects the type of access that is required for each resource. Example:</p>\r\n      <pre>grant codeBase \"file:e:/myapp/bin/-\" <br />{<br />    // A placeholder for all appropriate permissions<br />};</pre>\r\n      <p>Assign a permission for each required resource. Java provides different types of permissions, each of which can be customized to meet your application's needs:</p>\r\n      <ul>\r\n        <li>\r\n          <p>\r\n            <strong>java.security.AllPermission:</strong>\r\n            <em>AllPermission</em> grants all other permissions to the code. It should seldom&nbsp;be used. Example:</p>\r\n          <pre>permission java.security.AllPermission;</pre>\r\n        </li>\r\n        <li>\r\n          <p>\r\n            <strong>javax.sound.sampled.AudioPermission:</strong>\r\n            <em>AudioPermission</em> grants access rights to the system's audio components. It should be used only when the application is required to play or record audio. Example:</p>\r\n          <pre>permission javax.sound.sampled.AudioPermission \"play\";</pre>\r\n        </li>\r\n        <li>\r\n          <p>\r\n            <strong>javax.security.auth.AuthPermission:</strong>\r\n            <em>AuthPermission</em> is used during authentication procedures. The <em>AuthPermission's</em> only argument is the name of the security configuration parameter. This permission class is used to guard access to the <em>Policy, Subject, LoginContext</em>, and <em>Configuration</em> objects. Example:</p>\r\n          <pre>permission javax.security.auth.AuthPermission \"modifyPrincipals\";</pre>\r\n        </li>\r\n        <li>\r\n          <p>\r\n            <strong>java.awt.AWTPermission:</strong>\r\n            <em>AWTPermission</em> grants access to the system's user experience and graphical interface. For example, the following permission would allow the application to access the system's clipboard:</p>\r\n          <pre>permission java.awt.AWTPermission \"accessClipboard\";</pre>\r\n        </li>\r\n        <li>\r\n          <p>\r\n            <strong>javax.security.auth.kerberos.DelegationPermission:</strong>\r\n            <em>DelegationPermission</em> restricts the usage of the Kerberos delegation model. Example:</p>\r\n          <pre>permission javax.security.auth.kerberos.DelegationPermission<br />       \"\\\"host/foo.example.com@EXAMPLE.COM\\\" \\\"krbtgt/EXAMPLE.COM@EXAMPLE.COM\\\"\";</pre>\r\n        </li>\r\n        <li>\r\n          <p>\r\n            <strong>java.io.FilePermission:</strong>\r\n            <em>FilePermission</em> grants access to files on the local system. Access right are read, write, execute, delete. Note that <em>FilePermission</em> always grants read access to files within the code's directory and any subdirectories. Example:</p>\r\n          <pre>permission java.io.FilePermission \"e:/myapp/logs/20061016.log\", \"write\";</pre>\r\n        </li>\r\n        <li>\r\n          <p>\r\n            <strong>java.util.logging.LoggingPermission:</strong>\r\n            <em>LoggingPermission</em> is associated with Java's standard logging mechanism. Currently <em>LoggingPermission</em> grants only the right to control Java's logging configuration. Example:</p>\r\n          <pre>permission java.util.logging.LoggingPermission \"control\";</pre>\r\n        </li>\r\n        <li>\r\n          <p>\r\n            <strong>java.net.NetPermission:</strong>\r\n            <em>NetPermission</em> grants access to various network permissions. For example, the following permission allows the ability to specify a stream handler when constructing a URL:</p>\r\n          <pre>permission java.net.NetPermission \"specifyStreamHandler\";</pre>\r\n        </li>\r\n        <li>\r\n          <p>\r\n            <strong>javax.security.auth.PrivateCredentialPermission:</strong>\r\n            <em>PrivateCredentialPermission</em> protects access to the private <em>Credentials</em> belonging to a particular <em>Subject</em>. Example:</p>\r\n          <pre>permission javax.security.auth.PrivateCredentialPermission<br />                \"javax.resource.spi.security.PasswordCredential * \\\"*\\\"\",\"read\";</pre>\r\n        </li>\r\n        <li>\r\n          <p>\r\n            <strong>java.util.PropertyPermission:</strong>\r\n            <em>PropertyPermission</em> specifies the read/write access to an object's or System's properties. Example:</p>\r\n          <pre>permission java.util.PropertyPermission \"java.home\", \"read\";</pre>\r\n        </li>\r\n        <li>\r\n          <p>\r\n            <strong>java.lang.reflect.ReflectPermission:</strong>\r\n            <em>ReflectPermission</em> grants access to reflective operations. Currently it only allows suppressing the standard Java language access checks (i.e. public, protected and private) by reflected objects at their point of use. Example:</p>\r\n          <pre>permission java.lang.reflect.ReflectPermission \"suppressAccessChecks\";</pre>\r\n        </li>\r\n        <li>\r\n          <p>\r\n            <strong>java.lang.RuntimePermission:</strong>\r\n            <em>RuntimePermission</em> grants access to runtime operations such as loading external libraries and halting the JVM. Example:</p>\r\n          <pre>permission java.lang.RuntimePermission \"accessDeclaredMembers\";</pre>\r\n        </li>\r\n        <li>\r\n          <p>\r\n            <strong>java.security.SecurityPermission:</strong>\r\n            <em>SecurityPermission</em> is used any security related events. Example:</p>\r\n          <pre>permission java.security.SecurityPermission \"createAccessControlContext\";</pre>\r\n        </li>\r\n        <li>\r\n          <p>\r\n            <strong>java.io.SerializablePermission:</strong>\r\n            <em>SerializablePermission</em> grant access to more advanced features of Java's serialization model. For example, the following permission allows the substitution of one object for another during serialization:</p>\r\n          <pre>permission java.io.SerializablePermission \"enableSubstitution\";</pre>\r\n        </li>\r\n        <li>\r\n          <p>\r\n            <strong>javax.security.auth.kerberos.ServicePermission:</strong>\r\n            <em>ServicePermission</em> protects the access to Kerberos services and any supplemental credentials. Example:</p>\r\n          <pre>permission javax.security.auth.kerberos.ServicePermission<br />                                    \"krbtgt/EXAMPLE.COM@EXAMPLE.COM\", \"initiate\";</pre>\r\n        </li>\r\n        <li>\r\n          <p>\r\n            <strong>java.net.SocketPermission:</strong>\r\n            <em>SocketPermission</em> grants access to the network via sockets. It allows your application to connect to a host, accept connections from a host, listen on a given port, or resolve the other host's IP/hostname. Example:</p>\r\n          <pre>permission java.net.SocketPermission \"serv02.example.com:3306\", \"connect\";</pre>\r\n        </li>\r\n        <li>\r\n          <p>\r\n            <strong>java.sql.SQLPermission:</strong>\r\n            <em>SQLPermission</em> grants access to operations executed during database access. Currently all standard Java methods that use <em>SQLPermission</em> are deprecated. <br /></p>\r\n        </li>\r\n        <li>\r\n          <p>\r\n            <strong>javax.net.ssl.SSLPermission:</strong>\r\n            <em>SSLPermission</em> grants access to SSL related operations. For example, an <em>SSLPermission</em> would be required to get the <em>SSLSessionContext</em> of an <em>SSLSession</em>:</p>\r\n          <pre>permission javax.net.ssl.SSLPermission \"getSSLSessionContext\";</pre>\r\n        </li>\r\n      </ul>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Load the policy at runtime. </strong>By default Java provides two policy files: a system policy file<em> ({java.home}/lib/security/java.policy)</em> and a user policy file <em>({user.home}/.java.policy)</em>. Use the <em>-Djava.security.policy(={policy file})</em> flag to load your policy during the start-up routine of your application's server. Make sure you use only a single <strong>=</strong> to append your policy to the JVM's default policies as <strong>==</strong> will force the JVM to load your policy only. Example: </p>\r\n      <pre>-Djava.security.policy=e:/myapp/config/myapp.policy</pre>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Enforce your application's policy. </strong>To fully enforce your application's policy, attach a <em>SecurityManager</em> to the System object. Because most standard Java packages come with built-in permission checks that are linked to the System's <em>SecurityManager</em>, enforcing a certain set of permissions is a fairly easy task. Example: </p>\r\n      <pre>if (System.getSecurityManager() == null)<br />{<br />      System.setSecurityManager(new SecurityManager());<br />}</pre>\r\n      <p>or</p>\r\n      <pre>-Djava.security.manager</pre>\r\n      <p>Be aware that enforcing a security policy may restrict access to various resources that are essential to the application's environment. Examples of such resources include, but are not limited to, use of network sockets, application server's local files, etc. Use the following steps to resolve such problems:</p>\r\n      <ol>\r\n        <li>\r\n          <p>\r\n            <strong>Enumerate all permissions that are granted to your application's environment. </strong>Enumerating all granted permissions to your application's environment helps identify the basic functionality that it requires for its normal operations. The following code helps you identify all permissions that your application inherits from its environment:</p>\r\n          <pre>public void doGet(HttpServletRequest request, HttpServletResponse response)<br />      throws ServletException, IOException<br />{<br />      PrintWriter out = response.getWriter();<br />      CodeSigner[] cSign = null;<br />      CodeSource cSource = new CodeSource(null, cSign);<br />      Principal[] principals = new Principal[0];<br />      ProtectionDomain pDomain = new ProtectionDomain(cSource,<br />                                                    null, null, principals);<br />      java.security.Policy policy = java.security.Policy.getPolicy();<br />      PermissionCollection permCollect = policy.getPermissions(pDomain);<br />      Enumeration permList = permCollect.elements();<br />      while (permList.hasMoreElements())<br />      {<br />            out.println( \"&lt;br&gt;\" + permList.nextElement().toString());<br />      }<br />}</pre>\r\n          <p>Note that the code snippet will perform its intended action only if the System's <em>SecurityManager</em> is set to <em>null</em>.</p>\r\n        </li>\r\n        <li>\r\n          <p />\r\n          <strong>Check if your application's environment performs unauthorized actions. </strong>Enable the <em>SecurityManager</em> during the start-up routine of your application's environment. Monitor the environment's logs for any <em>access denied</em> errors. For instance, Tomcat will not function properly if the administrator does not grant a <em>SocketPermission</em> to connect and resolve 127.0.0.1 on port 8005: <p /><pre>Exception in thread \"ContainerBackgroundProcessor[StandardEngine[Catalina]]\"<br />     java.security.AccessControlException: access denied<br />          (java.lang.RuntimePermission setContextClassLoader)<br />...<br />Caused by: java.security.AccessControlException: access denied<br />          (java.net.SocketPermission 127.0.0.1:8005 connect,resolve)</pre></li>\r\n        <li>\r\n          <p>\r\n            <strong>Grant the essential permissions for your application's environment. </strong>Grant all essential permissions into the security policy for your application's environment to allow the environment to function properly.</p>\r\n        </li>\r\n      </ol>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Protect security policy files. </strong>Make sure that appropriate security measures are taken when storing the security policy files.</p>\r\n      <ul>\r\n        <li>\r\n          <strong>Choose a security policy directory:</strong> Dedicate a directory for storing your application's security policy files. Make sure the directory is not web-accessible. This limits the scope of users&nbsp;who can potentially compromise the contents inside the directory. </li>\r\n        <li>\r\n          <strong>Set appropriate permissions:</strong> Apply the appropriate filesystem permissions such that the security policy files can be only accessed by your application and its administrators.</li>\r\n      </ul>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Avoid common mistakes</strong>.</p>\r\n      <ul>\r\n        <li>\r\n          <p>\r\n            <strong>Delegate a Policy Manager:</strong> Java allows its applications to alter the JVM's policies during runtime. If your application needs to alter its policies during runtime, create a custom Policy Manager and delegate it the task of altering Java policies. Using the <em>SecurityPermission class</em>, enforce strict access control to the manager's functionality such that only authorized components can request modifications to the JVM's policies.</p>\r\n          <p>The following permissions must be granted to the Policy Manager's code:</p>\r\n          <pre>java.security.SecurityPermission \"getPolicy\";<br />java.security.SecurityPermission \"setPolicy\";</pre>\r\n        </li>\r\n        <li>\r\n          <p>\r\n            <strong>Enforce the security policy as early as possible:</strong> Delaying the enforcement of the security policies provides a bigger window of opportunity for an attacker to execute a payload through your compromised application.</p>\r\n        </li>\r\n      </ul>\r\n    </li>\r\n  </ol>\r\n  <h1>Problem Example</h1>\r\n  <p>The following snippet shows part of the Java policy for an application. Because the developer has not identified his component, the applied permission will be valid for any other component hosted within the same Java application.</p>\r\n  <pre>grant <br />{<br />permission java.net.SocketPermission \"serv02.example.com:3306\", \"connect\";<br />}; </pre>\r\n  <h1>Solution Example</h1>\r\n  <p>The following snippet shows part of the Java policy for an application. Because the developer has identified his component, the applied permission will be valid only for his component hosted within the Java application.</p>\r\n  <pre>grant codeBase \"file:e:/myapp/bin/DBManager/-\" <br />{<br />permission java.net.SocketPermission \"serv02.example.com:3306\", \"connect\";<br />};</pre>\r\n  <br />"
        ]
      }
    ]
  }
}