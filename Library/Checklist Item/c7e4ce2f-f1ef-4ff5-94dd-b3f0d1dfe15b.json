{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "2064598212",
      "Content_Hash": "1447622561"
    },
    "Metadata": [
      {
        "Id": [
          "c7e4ce2f-f1ef-4ff5-94dd-b3f0d1dfe15b"
        ],
        "Id_History": [
          "c7e4ce2f-f1ef-4ff5-94dd-b3f0d1dfe15b,3b137813-dffa-46c4-9f9e-6439e5adb528,"
        ],
        "Library_Id": [
          "26bd1a04-beed-4a66-917d-b6ab0a7d634c"
        ],
        "Title": [
          "Passwords Are Not Left in Memory"
        ],
        "Category": [
          "Authentication"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          ".NET"
        ],
        "Type": [
          "Checklist Item"
        ],
        "DirectLink": [
          "Passwords Are Not Left in Memory"
        ],
        "Tag": [
          "ASP.NET,ASP.NET 4.0,ASP"
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<h1>Applies To</h1>\r\n  <ul>\r\n    <li>ASP.NET 4.0</li>\r\n  </ul>\r\n  <h1>What to Check For</h1>\r\n  <p>Ensure that passwords are cleared from memory after their use.</p>\r\n  <h1>Why</h1>\r\n  <p>Passwords are sensitive data that are used to establish a trust relationship. Leaving them in memory after their use can expose them to an attacker.</p>\r\n  <h1>How To Check</h1>\r\n  <p>To make sure that passwords are cleared from memory after their use:</p>\r\n  <ol>\r\n    <li>\r\n      <p>\r\n        <strong>Identify all password use.</strong> Examine your application and identify all places inside its code base that handle user passwords. Common places include:</p>\r\n      <ul>\r\n        <li>Creating new users </li>\r\n        <li>Modifying existing users </li>\r\n        <li>Changing credentials for existing users </li>\r\n        <li>Authenticating users </li>\r\n      </ul>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Verify that passwords are stored in mutable objects.</strong> Each identified password should be stored in a mutable object, such as a character array. This allows the password to be overwritten in memory and not rely on the garbage collector. Verify that passwords are not stored in immutable objects, such as .NET strings, that do not allow their memory space to be modified after being allocated.</p>\r\n      <p>Ensure that the memory containing the password is overwritten as quickly after use as possible. Ensure that passwords are not passed between function, class, or object boundaries except when absolutely necessary. Note in the examples below the difference between Byte and byte. .NET cannot guarantee that it will overwrite the same memory location in the heap that is already occupied by a Byte. However, if you overwrite a byte variable or an element inside a byte[], then you have overwritten the same memory location that contains the actual data.</p>\r\n      <p>Examples of Mutable objects:</p>\r\n      <ul>\r\n        <li>char </li>\r\n        <li>char[] </li>\r\n        <li>byte </li>\r\n        <li>byte[] </li>\r\n      </ul>\r\n      <p>Examples of Immutable objects:</p>\r\n      <ul>\r\n        <li>string </li>\r\n        <li>Byte </li>\r\n        <li>Byte[] </li>\r\n        <li>Char </li>\r\n      </ul>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Verify that all password instances are cleared.</strong> Ensure that all the memory locations where passwords have been stored are cleared or overwritten after their use. Setting a pointer to NULL does not clear or overwrite the memory- a new value must be assigned to it. For a character array, setting each char to a new value, such as a space or a zero, will overwrite the value stored in memory. </p>\r\n      <p>Example of improper password removal: </p>\r\n      <pre>char[] pass = GetPassword();<br />...<br />//insufficient for removing a password from memory<br />pass = null;</pre>\r\n      <p>Example of proper password removal:</p>\r\n      <pre>char[] pass = GetPassword();<br />...<br />//proper clearing of character array to remove data from memory<br />for(int i=0; i&lt;pass.Length; i++){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pass[i] = ' ';<br />}<br />pass = null;</pre>\r\n    </li>\r\n  </ol>\r\n  <h1>How To Fix</h1>\r\n  <p>Passwords can be cleared by overwriting the memory where the passwords were stored. Deallocating the memory is not sufficient since the .NET garbage collector gives no guarantee as to when the deallocated memory will be collected or reused. Be aware that any time you assign a password to a new buffer, or pass it as a parameter, the password is being copied and is now in memory in a new location. When clearing memory, ensure you clear every instance.</p>\r\n  <p>Keep in mind the following considerations when handling passwords:</p>\r\n  <ol>\r\n    <li>\r\n      <p>\r\n        <strong>Identify all password use.</strong> Locate all code segments, both functions and data members, that handle passwords. These can be functions and data structures scattered throughout the application. If the application cannot be managed as easy, centralize all code that handles passwords.</p>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Store passwords in mutable objects.</strong> Mutable objects allow the data in them to be overwritten. This is especially useful in .NET as objects are required to be deallocated through the garbage collector. Therefore there is no certainty when the password instance will be deallocated from the current process space. Examples of mutable objects include character arrays (i.e. char[]). .NET strings, however, are not mutable objects; therefore, once allocated, their current memory space cannot be modified. When storing a password into an array, make sure you use arrays of primitive data types such as byte, char, and int, but not arrays of the wrapper structures that .NET provides for primitive types such as Byte, Char, and Int32. If you are forced to use .NET strings, (for instance, when calling a function which takes a .NET string), try to construct the string just before use and assign a new value to it as soon as you are done to encourage speedy garbage collection; this is sub-optimal and may lead to security issues, but until the .NET APIs allow for the exclusive use of mutable objects or SecureStrings, it may be unavoidable.</p>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Clear all password instances.</strong> Make sure that all memory locations, where passwords have been stored, are cleared/overwritten after their use. Losing a pointer to a password instance can result in not cleaning that particular memory and allowing the password to leak.</p>\r\n    </li>\r\n  </ol>\r\n  <h1>Related Items</h1>\r\n  <em>You may find these additional articles useful</em>\r\n  <ul>\r\n    <li>\r\n      <a href=\"/article/dd8ddb2d-3290-470c-befd-d443e26bd1bf\">Do Not Leave Passwords in Memory</a>\r\n    </li>\r\n  </ul>\r\n  <hr />\r\n  <p>Adapted from Microsoft patterns & practices guidance. </p>\r\n  <h1>\r\n  </h1>\r\n  <h1>\r\n  </h1>"
        ]
      }
    ]
  }
}