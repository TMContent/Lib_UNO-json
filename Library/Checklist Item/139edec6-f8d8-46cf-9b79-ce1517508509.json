{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "-1520882126",
      "Content_Hash": "1216493631"
    },
    "Metadata": [
      {
        "Id": [
          "139edec6-f8d8-46cf-9b79-ce1517508509"
        ],
        "Id_History": [
          "139edec6-f8d8-46cf-9b79-ce1517508509,917eb53c-23d9-47ef-a1f3-fca8c2c1ff4b,"
        ],
        "Library_Id": [
          "26bd1a04-beed-4a66-917d-b6ab0a7d634c"
        ],
        "Title": [
          "Sensitive Data Is Cleared from Memory After Use"
        ],
        "Category": [
          "Other"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          ".NET"
        ],
        "Type": [
          "Checklist Item"
        ],
        "DirectLink": [
          "Sensitive Data Is Cleared from Memory After Use"
        ],
        "Tag": [
          "ASP.NET,ASP.NET 4.0,ASP"
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<h1>Applies To</h1>\r\n  <ul>\r\n    <li>ASP.NET 4.0</li>\r\n  </ul>\r\n  <h1>What to Check For</h1>\r\n  <p>Ensure that sensitive data, such as encryption keys or private information, is maintained in memory for the bare minimum amount of time required. Check that as soon as the data is no longer used, it is purged from memory and all traces of it are eradicated, so it does not end up leaking to the swap file.</p>\r\n  <h1>Why</h1>\r\n  <p>Sensitive data residing in memory for more time than is strictly necessary is at high risk to be swapped out to disk. This could leave fragments of data available well after the application has terminated. Such data may be gathered by inspecting the contents of the disk, temporary files or the swap file.</p>\r\n  <h1>How To Check</h1>\r\n  <p>If the application handles sensitive data of any kind, use the following steps to ensure that your application properly handles sensitive data in memory: </p>\r\n  <ol>\r\n    <li>\r\n      <p>\r\n        <strong>Identify sensitive information. </strong>Sensitive data is any information that is kept secret and should be disclosed only to authorized parties. Common examples of sensitive data include, but are not limited to, names of customers, government issued ID numbers, credit card and other financial information, passwords, and private keys. Some industries, such as health care and banking, have regulatory standards that define sensitive information. Use regulatory requirements, as they apply to your application, to identify sensitive data. Sensitive data can be defined as follows:</p>\r\n      <ul>\r\n        <li>Information that either contains personally identifiable information or can be used to derive personally identifiable information that should not be shared with others. </li>\r\n        <li>Information that a user provides that they would not want shared with other users of the application. </li>\r\n        <li>Information that comes from an external trusted source that is not designed to be shared with users.</li>\r\n      </ul>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Identify all code that handles sensitive data. </strong>Examine your application's code base. Identify all functionality that handles sensitive data. Common places include:</p>\r\n      <ul>\r\n        <li>Authentication mechanisms </li>\r\n        <li>User management </li>\r\n        <li>All user transactions of sensitive nature</li>\r\n      </ul>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Verify that sensitive data is stored in mutable objects. </strong>Each identified piece of sensitive data should be stored in a mutable object, such as a character array. This allows the sensitive data to be overwritten in memory and not rely on the garbage collector. Verify that sensitive data is not stored in immutable objects, such as .NET strings, that do not allow their memory space to be modified after being allocated. Ensure that the memory containing the sensitive data is overwritten as quickly after use as possible. Ensure that sensitive data is not passed between function, class, or object boundaries except when absolutely necessary. Note in the examples below the difference between <strong>Byte</strong> and <strong>byte</strong>. .NET cannot guarantee that it will overwrite the same memory location in the heap that is already occupied by a <strong>Byte</strong>. However, if you overwrite a <strong>byte</strong> variable or an element inside a <strong>byte[]</strong>, then you have overwritten the same memory location that contains the actual data. </p>Examples of Mutable objects: <ul><li>char </li><li>char[] </li><li>byte </li><li>byte[]</li></ul>Examples of Immutable objects: <ul><li>string </li><li>Byte </li><li>Byte[] </li><li>Char</li></ul></li>\r\n    <li>\r\n      <p>\r\n        <strong>Verify that all instances of sensitive data are cleared. </strong>Ensure that all the memory locations where sensitive data has been stored are cleared or overwritten after their use. Setting a pointer to NULL does not clear or overwrite the memory - a new value must be assigned to it. For a character array, setting each char to a new value, such as a space or a zero, will overwrite the value stored in memory. Example of improper removal of sensitive data:</p>\r\n      <pre>char[] ssn = GetSocialSecurity();<br />...<br />//insufficient for removing sensitive data from memory<br />ssn = null;</pre>\r\n      <p>Example of proper removal of sensitive data:</p>\r\n      <pre>char[] ssn = GetSocialSecurity();<br />...<br />//proper clearing of character array to remove sensitive<br />//data from memory<br />for(int i=0; i&lt;ssn.Length; i++)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ssn[i] = ' ';<br />}<br />ssn = null;</pre>\r\n    </li>\r\n  </ol>\r\n  <h1>How To Fix</h1>\r\n  <p>Sensitive data can be cleared by overwriting the memory where the sensitive data was stored. Deallocating the memory is not sufficient since the .NET garbage collector gives no guarantee as to when the deallocated memory will be collected or reused. Be aware that any time you assign a sensitive data to a new buffer, or pass it as a parameter, the sensitive data is being copied and is now in memory in a new location. When clearing memory, ensure you clear every instance.</p>\r\n  <p>Keep in mind the following considerations when handling passwords: </p>\r\n  <ol>\r\n    <li>\r\n      <p>\r\n        <strong>Identify sensitive information.</strong> Sensitive data is any information that is kept secret and should be disclosed only to authorized parties. Common examples of sensitive data include, but are not limited to, names of customers, government issued ID numbers, credit card and other financial information, passwords, and private keys. Some industries, such as health care and banking, have regulatory standards that define sensitive information. Use regulatory requirements, as they apply to your application, to identify sensitive data. Sensitive data can be defined as follows:</p>\r\n      <ul>\r\n        <li>Information that either contains personally identifiable information or can be used to derive personally identifiable information that should not be shared with others. </li>\r\n        <li>Information that a user provides that they would not want shared with other users of the application. </li>\r\n        <li>Information that comes from an external trusted source that is not designed to be shared with users.</li>\r\n      </ul>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Identify all sensitive data use.</strong> Locate all code segments, both functions and data members, that handle sensitive data. These can be functions and data structures scattered throughout your application. If possible, centralize all code that handles sensitive data.</p>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Store sensitive data in mutable objects.</strong> Mutable objects allow the data in them to be overwritten. This is especially useful in .NET as objects are required to be deallocated through the garbage collector. Therefore, there is no certainty when the sensitive data will be deallocated from the current process space. Examples of mutable objects include character arrays (i.e. char[]). .NET strings, however, are not mutable objects; therefore, once allocated, their current memory space cannot be modified. When storing sensitive data into an array, make sure that you use arrays of primitive data types such as byte, char, and int, but not arrays of the wrapper classes that .NET provides for primitive types such as Byte, Char or Int32. If you are forced to use .NET strings, (for instance, when calling a function which takes a .NET string), try to construct the string just before use and assign a new value to it as soon as you are done to encourage speedy garbage collection; this is sub-optimal and may lead to security issues, but until the .NET APIs allow for the exclusive use of mutable objects or SecureStrings, it may be unavoidable.</p>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Clear all sensitive data instances.</strong> Make sure that all memory locations where sensitive data has been stored are cleared or overwritten after their use. Losing a pointer to a sensitive data instance can result in not cleaning that particular memory and allowing the sensitive data to leak.</p>\r\n    </li>\r\n  </ol>\r\n  <h1>Related Items</h1>\r\n  <em>You may find these additional articles useful</em>\r\n  <ul>\r\n    <li>\r\n      <a href=\"/article/ffa14c84-64d3-42db-9a48-73e4a9ce1877\">Clear Sensitive Data from Memory When No Longer Used</a>\r\n    </li>\r\n  </ul>\r\n  <hr />\r\n  <p>Adapted from Microsoft patterns & practices guidance. </p>\r\n  <h1>\r\n  </h1>\r\n  <h1>\r\n  </h1>"
        ]
      }
    ]
  }
}