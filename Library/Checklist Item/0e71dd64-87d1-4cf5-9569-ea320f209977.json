{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "1466481928",
      "Content_Hash": "-170295046"
    },
    "Metadata": [
      {
        "Id": [
          "0e71dd64-87d1-4cf5-9569-ea320f209977"
        ],
        "Id_History": [
          "0e71dd64-87d1-4cf5-9569-ea320f209977,eb0f0ee4-ba77-4010-b328-79fd9b00fcd2,"
        ],
        "Library_Id": [
          "26bd1a04-beed-4a66-917d-b6ab0a7d634c"
        ],
        "Title": [
          "Input Is Validated for Length, Range, Format, And Type"
        ],
        "Category": [
          "Input and Data Validation"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          ".NET"
        ],
        "Type": [
          "Checklist Item"
        ],
        "DirectLink": [
          "Input Is Validated for Length, Range, Format, And Type"
        ],
        "Tag": [
          ""
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<h1>Applies To</h1>\r\n  <ul>\r\n    <li>ASP.NET 4.0</li>\r\n  </ul>\r\n  <h1>What to Check For</h1>\r\n  <p>Input is validated on the server to ensure that it is in the expected format, based upon which contexts the input is used in, and encoded appropriately on output.</p>\r\n  <h1>Why</h1>\r\n  <p>An attacker passing malicious input can attempt SQL injection, cross-site scripting, and other injection attacks that aim to exploit your vulnerabilities in your application. Validating input helps to reduce these risks by ensuring that the input received matches the expected format. Input validation on its own is not sufficient; output encoding is also needed to fully prevent these attacks as well as to improve&nbsp;reliability. Validation should always be as strict as possible, to ensure that problems do not arise from input thought to be out-of-range but harmless. An allow-list approach should always be taken, never a block list, to ensure that this property is maintained.</p>\r\n  <p>While input validation can be used to effectively mitigate the risk from a majority of known security vulnerabilities, is should not be used as the only line of defense as there are certain vulnerabilities that can not be remediated with input validation alone (example information disclosure vulnerabilities).</p>\r\n  <h1>How To Check</h1>\r\n  <p>To check for this problem, use the following steps: </p>\r\n  <ol>\r\n    <li>\r\n      <p>\r\n        <strong>Ensure&nbsp;that numeric range constraints have been enforced. </strong>Check that the <em>RangeValidator</em> control has been used to constrain the numeric input to a specific range.</p>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Ensure that verification fields are validated. </strong>Check that the <em>CompareValidator</em> control has been used to ensure validity for verification fields. An example of a verification field is the password entry field, where the user is required to re-type the value and the two values are compared to validate them. </p>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Ensure that type constraints have been enforced on string fields. </strong>Check that the <em>RegularExpressionValidator</em> control has been used to validate string input. This validator performs a variety of checks on string input fields using regular expressions. </p>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Ensure that custom validation has been used to handle remaining input constraints. </strong>Check that the <em>CustomValidator</em> control has been used to validate input for constraints not handled by the built-in ASP.NET validators. When the <strong>CustomValidator</strong> control is used, it is important to check that input has been validated for length, range, format and type. Use this validator in cases where your application might require certain business logic constraints which cannot be enforced by the existing validators for example. </p>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Ensure that the Regex class is being used to validate other sources. </strong>If you need to validate input from sources other than form fields, such as query string parameters or cookies, check that the <strong>Regex</strong> class, within the <strong>System.Text.RegularExpressions</strong> namespace, is being used. </p>\r\n    </li>\r\n  </ol>\r\n  <h1>How To Fix</h1>\r\n  <p>The methods for validating different aspects of user input are shown below:</p>\r\n  <ol>\r\n    <li>\r\n      <p>\r\n        <strong>Enforce numeric range constraints</strong>: Use the RangeValidator control to ensure any numeric values are constrained to a specific, acceptable range. Here is an example that declares an integer field in an ASP page that has a valid range from 1 to 50:</p>\r\n      <pre>&lt;td&gt;<br />  &lt;asp:RangeValidator id=\"Range1\"<br />           ControlToValidate=\"txtState\"<br />           MinimumValue=\"1\"<br />           MaximumValue=\"50\"<br />           Type=\"Integer\"<br />           EnableClientScript=\"false\"<br />           Text=\"The value must be from 1 to 10!\"<br />           runat=\"server\"&gt;<br />  &lt;/asp:RangeValidator&gt;&lt;/td&gt;<br />&lt;td&gt;State:&lt;/td&gt;<br />&lt;td&gt;&lt;input type=text runat=server id=txtState&gt;&lt;/td&gt;</pre>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Validate verification fields</strong>: Fields such as password entry are often verified by having the user re-type them to ensure they are correct. Use the CompareValidator control to make the comparisons and ensure validity/integrity. Here is an example that declares two password fields in an ASP page that must match in order to validate properly:</p>\r\n      <pre>&lt;asp:CompareValidator runat=server<br />            ControlToValidate=txtRePWord<br />            ControlToCompare=txtPWord<br />            ErrorMessage=\"Passwords do not match.\" /&gt;</pre>\r\n      <p>In this case, the two fields being compared are \"txtPWord\" and \"txtRePWord\". If they do not match, validation fails with the error message, \"Passwords do not match.\". </p>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Enforce type constraints on string fields</strong>: String fields are the most difficult type of input to effectively validate because the range of acceptable characters is much larger than numeric and enumerated types. Regular expressions provide a flexible mechanism for dictating valid patterns and characters. Use the RegularExpressionValidator to perform a variety of checks on string-based fields such as zip codes and phone numbers. Here is an example that declares a text field in an ASP page that should represent a five digit zip code, consisting entirely of numeric digits, and a validator to enforce those constraints:</p>\r\n      <pre>&lt;input type=text runat=server id=txtZip&gt;<br />      &lt;asp:RegularExpressionValidator runat=server<br />             ControlToValidate=\"txtZip\"<br />             ErrorMessage=\"Zip code must be 5 digits, all numbers.\"<br />             ValidationExpression=\"[0-9]{5}\"&gt; <br />      &lt;/asp:RegularExpressionValidator&gt;&lt;td&gt;Zip code:&lt;/td&gt;<br />&lt;td&gt;&lt;input type=text runat=server id=txtZip&gt;&lt;/td&gt;</pre>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Use custom validation to handle remaining input constraints</strong>: The built-in ASP.NET validation controls handle most of the cases that commonly arise in web applications, but there may be times when they are not appropriate. The CustomValidator enables custom validation code that can plug into the existing validation system. Here is an example that declares a text field in an ASP page. For this particular text field, there is business logic constraint that needs to be satisfied which is not easily constrainable by the other validation constructs, so a custom validator is implemented that ensures the string in the text field does not start with the letter \"a\":</p>\r\n      <pre>&lt;%@ Page Language=\"vb\" %&gt;<br />&lt;script runat=server&gt;public sub CheckID(source as Object, args as ServerValidateEventArgs)<br />    args.IsValid = args.Value.substring(0, 1).tolower() &lt;&gt; \"a\"end sub &lt;/script&gt;</pre>\r\n      <p>To call this function, add a CustomValidator, a control designed to call developer code to perform its check. Here is the declaration:</p>\r\n      <pre>      &lt;asp:CustomValidator runat=server<br />             controltovalidate=\"txtName\"<br />             errormessage=\"ID is already in use.\"<br />             OnServerValidate=\"CheckID\" /&gt;</pre>\r\n      <p>It is worth noting that this could have been done with the RegularExpression validation control, but in this case it makes more sense to use custom validation since a type of high-level validation that could conceivably be more complex than a simple pattern match is being defined (e.g., the validation rules might change based on application state). </p>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Use the Regex class to validate other sources</strong>: Most Web applications accept input from various sources, including HTML controls, server controls, query strings, and cookies. Validate input from all of these sources to help prevent injection attacks. Use regular expressions to help validate input. The following example shows how to use the <strong>Regex</strong> class. </p>\r\n      <pre>using System.Text.RegularExpressions;<br />// Instance method:Regex reg = new Regex(@\"^[a-zA-Z'.\\s]{1,40}$\");<br />Response.Write(reg.IsMatch(Request.QueryString[\"Name\"]));<br />// Static method:if (!Regex.IsMatch(Request.QueryString[\"Name\"],@\"^[a-zA-Z'.\\s]{1,40}$\"))<br />{<br />   // Name does not match expression<br />}</pre>\r\n      <p>If you cannot cache your regular expression for frequent use, you should use the static <strong>IsMatch</strong> method where possible for performance reasons, to avoid unnecessary object creation.</p>\r\n    </li>\r\n  </ol>\r\n  <h1>Related Items</h1>\r\n  <em>You may find these additional articles useful</em>\r\n  <ul>\r\n    <li>\r\n      <a href=\"/article/e59923e7-c2fb-4a75-8db7-a9a91e869f74\">Validate Input for Length, Range, Format, and Type</a>\r\n    </li>\r\n  </ul>\r\n  <hr />\r\n  <p>Adapted from Microsoft patterns & practices guidance. </p>\r\n  <h1>\r\n  </h1>\r\n  <h1>\r\n  </h1>"
        ]
      }
    ]
  }
}