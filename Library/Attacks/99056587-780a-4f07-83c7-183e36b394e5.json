{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "39113248",
      "Content_Hash": "-1712374677"
    },
    "Metadata": [
      {
        "Id": [
          "99056587-780a-4f07-83c7-183e36b394e5"
        ],
        "Id_History": [
          "733be22b-8cda-4c76-9009-1bafbb223ddc,99056587-780a-4f07-83c7-183e36b394e5,ba015b28-074f-4a50-8a1f-6c557cf10177,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6204f2d47eb7"
        ],
        "Title": [
          "Response Splitting Attack"
        ],
        "Category": [
          "Input and Data Validation"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          "Technology Independent"
        ],
        "Type": [
          "Attack"
        ],
        "DirectLink": [
          "Response Splitting Attack"
        ],
        "Tag": [
          ""
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          "1"
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "wikitext"
        },
        "Data": [
          "=Applies To\r\n\r\nAny web application.\r\n\r\n=Description\r\n\r\nHTTP response splitting occurs when an attacker is able to inject arbitrary data into the headers of an HTTP response. In the presence of this vulnerability, the attacker can essentially force an HTTP response that contains HTML of the attacker's choosing. This is accomplished by simply terminating the header section of the response with the 0x0d 0x0a byte sequence and continuing with the malicious HTML. The resulting byte stream appears to the browser as two separate HTTP responses. The first contains the malicious HTML and is interpreted by the browser as being the legitimate response. The second contains the actual HTML that would have been returned by the server and is typically ignored.\r\n\r\nBy essentially allowing the attacker complete control over an HTTP response that is rendered in the context of your domain, the door is opened for a phishing or a cross site scripting attack.\r\n\r\n=Impact\r\n\r\n    *Elevation of privilege: The attacker can execute script in the context of your web application's domain.\r\n    *Access control: The attacker can steal authentication cookies or at the very least execute additional HTTP requests in the context of the currently logged in user.\r\n    *Defacement: The attacker can author pages with arbitrary content.\r\n\r\n=Vulnerabilities\r\n\r\n*HTTP response headers populated with untrusted and un-encoded input. The most common scenarios where this occurs are:\r\n**HTTP redirects (see example).\r\n**HTTP cookie values supplied by the user. For instance, your application allows the user to supply a name and then sets a cookie value using that name. It is important to note that cookies are set with the Set-Cookie HTTP response header.\r\n\r\n=Countermeasures\r\n\r\n*Perform context-sensitive scrubbing and encoding of untrusted input before it is used in an HTTP response header.\r\n*In particular RFC 2616 states that CRs and LFs are not allowed in HTTP response headers, especially in the \"Location\" and \"Set-Cookie\" fields. Also remove sequences of CRs, LFs, SPs, and HTs and do not accept any input where LF is not followed by SP or HT.\r\n\r\nAs with any blacklist strategy, this is a good start but will not catch everything. Web proxies, such as Sun Java System Web Proxy Server, cause problems with this approach because they often accept CR only as a valid end of line marker and hence can be exploited by using only CR.\r\n\r\n=Example\r\n\r\nTo demonstrate the response splitting attack, consider the following situation. Suppose there is a web server located at the domain {{{example.com}}} that has two pages. The first page located at {{{/redirect.php}}} is used to redirect users to the second page at {{{/hello/world.html}}}.\r\n\r\nHere is a simple redirect.php\r\n\r\n{{{\r\n<?phpheader (\"Location: \" . $_GET['site']);?>\r\n}}}\r\n\r\nHere is a simple {{{/hello/world.html}}}\\\\\r\n\r\n{{{\r\n<html>hello world!</html>\r\n}}}\r\n\r\nThis link will redirect a user to the {{{hello/world.html}}} page.\r\n\r\n{{{\r\nhttp://example.com/redirect.php?site=hello/world.html\r\n}}}\r\n\r\nThe following shows the headers that are sent between the client and the web server when this happens. First the client requests the page.\r\n\r\n{{{\r\nGET http://example.com:80/redirect.php?page=hello/world.html HTTP/1.1\r\nAccept: */*Accept-Language: en-us\r\nUA-CPU: x86\r\nAccept-Encoding: gzip, deflate\r\nUser-Agent: Mozilla/4.0\r\nHost: somewhere.com\r\nProxy-Connection: Keep-Alive\r\n}}}\r\n\r\nThen the server responds with a message telling the client that the page has moved and where to find it.\r\n\r\n{{{\r\nHTTP/1.1 302 Found\r\nServer: Apache/1.3.33 (Unix) PHP/4.4.2X-Powered-By: PHP/4.4.2\r\nLocation: hello/world.html\r\nX-Transfer-Encoding: chunked\r\nContent-Type: text/htmlContent-length: 0\r\n}}}\r\n\r\nHence the client application sends a request for the new page.\r\n\r\n{{{\r\nGET http://example.com:80/hello/world.html HTTP/1.1\r\nAccept: */*\r\nAccept-Language: en-us\r\nUA-CPU: x86\r\nAccept-Encoding: gzip, deflate\r\nUser-Agent: Mozilla/4.0\r\nHost: 192.168.1.103\r\nProxy-Connection: Keep-Alive\r\n}}}\r\n\r\nFinally, the server responds with the page.\r\n\r\n{{{\r\nHTTP/1.1 200 OK\r\nServer: Apache/1.3.33 (Unix) PHP/4.4.2\r\nAccept-Ranges: bytes\r\nContent-length: 28\r\nContent-Type: text/html\r\n <html>hello world!</html>\r\n}}}\r\n\r\nThere are a few things to note at this point. Each line in the above headers end with the carriage return line feed (CRLF) sequence {{{\\r\\n}}}. To make things easier to read, they are not shown in the above dialog, but they exist and are important to applications when communicating. \r\n\r\nThe next thing to note is that the URL-encoded CRLF sequence {{{%0d%0a}}} is equivalent to {{{\\r\\n}}} and can be used to embed header information into a URL. The next part of this example demonstrates how this can be used to deliver an attacker-controlled page to a user's browser.\r\n\r\nConsider what happens when the following is injected into a URL:\r\n\r\n{{{\r\n%0d%0aContent-Type: text/html%0d%0aHTTP/1.1 200 OK%0d%0a Content-Type: text/html%0d%0a%0d%0a%3Chtml%3E Insert attacker payload here! %3C/html%3E\r\n}}}\r\n\r\nThat is, the user is given the following link:\r\n\r\n{{{\r\nhttp://example.com/redirect.php?site=%0d%0aContent-Type: text/html%0d%0aHTTP/1.1 200 OK%0d%0aContent-Type: text/html%0d%0a%0d%0a%3Chtml%3E Insert attacker payload here! %3C/html%3E\r\n}}}\r\n\r\nNow we take a look at what happens to the headers during the dialog when a client requests the above URL.\r\n\r\n{{{\r\nGET http://example.com/redirect.php?site=%0d%0aContent-Type: text/html%0d%0a\r\n  HTTP/1.1 200 OK%0d%0aContent-Type: text/html%0d%0a%0d%0a%3C\r\n  html%3E Insert XSS payload here!\r\n %3C/html%3E HTTP/1.1\r\nAccept: */*\r\nAccept-Language: en-us\r\nUA-CPU: x86\r\nAccept-Encoding: gzip, deflate\r\nUser-Agent: Mozilla/4.0\r\nHost: somewhere.com\r\nProxy-Connection: Keep-Alive\r\nPragma: no-cache\r\n}}}\r\n\r\nBasically two headers are being sent with a single request. Let's look at the above header in a more readable form:\r\n\r\n{{{\r\nGET http://example.com/redirect.php?site=Content-Type: text/html\r\nHTTP/1.1 200 OK\r\nContent-Type: text/html\r\n <html> Insert attacker payload here! </html>\r\n HTTP/1.1\r\nAccept: */*\r\nAccept-Language: en-us\r\nUA-CPU: x86A\r\nccept-Encoding: gzip, deflate\r\nUser-Agent: Mozilla/4.0\r\nHost: 192.168.1.103\r\nProxy-Connection: Keep-Alive\r\nPragma: no-cache\r\n}}}\r\n\r\nWhen the server receives this header, it sends the following two responses which include the attacker's payload.\r\n\r\n{{{\r\nHTTP/1.1 302 Found\r\nServer: Apache/1.3.33 (Unix) PHP/4.4.2\r\nLocation:\r\nContent-Type: text/html\r\nHTTP/1.1 200 OK\r\nContent-Type: text/html\r\n<html> Insert attacker payload here! </html>\r\nKeep-Alive: timeout=15, max=100\r\nConnection: Keep-Alive\r\nTransfer-Encoding: chunked\r\nContent-Type: text/html\r\n}}}\r\n\r\n=Additional Resources\r\n\r\n    *For more information on HTTP Response Splitting, see: http://projects.webappsec.org/w/page/13246931/HTTP%20Response%20Splitting\r\n    *For more information about an Introduction to HTTP Response Splitting, see: http://www.securiteam.com/securityreviews/5WP0E2KFGK.html\r\n\r\n=Related Items\r\n\r\n    *[[914b6a65-2729-47c6-87d9-03f34c2fc700|Attack: Request Smuggling Attack]]\r\n    *[[00d296c8-2c75-47ef-a659-5b4f25d5c73f|Attack: Canonicalization Attack]]\r\n    *[[36ce61ac-adcc-45a9-9910-95d477142c8b|Attack: Cross Site Scripting Attack]]\r\n    *[[49f1d246-0c79-48dd-90d0-39e52a17d8cc|Attack: Phishing Attack]]\r\n    *[[054ee066-d6c5-48b2-98d6-7043a30fc0a5|Attack: URL Redirection Attack]]\r\n  \r\n\r\n"
        ]
      }
    ]
  }
}