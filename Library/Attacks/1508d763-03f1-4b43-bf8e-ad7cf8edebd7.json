{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "-369593238",
      "Content_Hash": "-150120562"
    },
    "Metadata": [
      {
        "Id": [
          "1508d763-03f1-4b43-bf8e-ad7cf8edebd7"
        ],
        "Id_History": [
          "9e18ec6e-1100-4423-b5cf-60b2e117ca25,1508d763-03f1-4b43-bf8e-ad7cf8edebd7,ced71023-d6ac-4b06-a954-ed130f60076d,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6204f2d47eb7"
        ],
        "Title": [
          "Xpath-XQuery Attack"
        ],
        "Category": [
          "Input and Data Validation"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          "Technology Independent"
        ],
        "Type": [
          "Attack"
        ],
        "DirectLink": [
          "Xpath-XQuery Attack"
        ],
        "Tag": [
          ""
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          "1"
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "wikitext"
        },
        "Data": [
          "=Applies To\r\n\r\nAny application that can manipulate XML documents through Xpath/XQuery.\r\n\r\n=Description\r\n\r\nAn Xpath/XQuery attack exploits missing or poor input validation to run arbitrary commands in XML databases. This attack works in much the same way as a SQL injection attack, but with an XML target instead of a SQL target. This attack can occur when an application uses unvalidated user input to construct an Xpath/XQuery statement to access XML tables. Using the Xpath/XQuery attack the attacker can execute arbitrary Xpath/XQuery statements on an XML database. This attack is often more damaging than a SQL injection attack, as permissions are not enforced and the attacker’s query can access every part of the XML document. With an Xpath/XQuery attack it is possible to retrieve, manipulate, and destroy any data stored in the XML document.\r\n\r\n=Impact\r\n\r\n    *Confidentiality: Since XML generally holds sensitive data, loss of confidentiality is a frequent problem.\r\n    *Integrity: The attacker may be able to not only read sensitive information, but also to change or even delete this information.\r\n    *Authentication: If poorly formed XPath/XQuery commands are used to check user names and passwords, the attacker may be able to connect to a system as another user with no previous knowledge of the password.\r\n    *Authorization: If authorization information is held in an XML document, the attacker may be able to change this information.\r\n    \r\n\r\n=Vulnerabilities\r\n\r\n    *Weak input validation.\r\n    *Generating XPath expressions by dynamically concatenating strings with user-supplied data.\r\n    *Failure to escape single quotes, double quotes, and other potentially dangerous characters.\r\n\r\n=Countermeasures\r\n\r\n    *Validate input: Use vigorous whitelist style validation on any user input that may be used as part of an XQuery command. This will also help prevent meta-characters from being added to your stored data set which will be used again.\r\n    *Use parameterized and precompiled XPath expressions in your XQuery instead of concatenating strings with user input: Parameterized Xpath statements will accept characters that have special meaning to Xpath (like single quote) without problems because they are strongly typed.\r\n    *Use escaping routines. If you cannot use parameters and must generate XPath expressions dynamically, use escaping routines to handle special characters that have meaning to the database.\r\n    *Do not echo XQuery errors. Catch any exceptions on the server and return generic error messages to the client.\r\n\r\n=Example\r\n\r\nConsider the following XML file, being used by an application to log users into the application:\r\n\r\n{{{\r\n<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> \r\n<users>    \r\n\t<user>       \r\n\t\t<username>admin</username>       \r\n\t\t<password>8af2&</password>       \r\n\t\t<account>admin</account>    \r\n\t</user>    \r\n\r\n\t<user>       \r\n\t\t<username>user1</username>       \r\n\t\t<password>password</password>       \r\n\t\t<account>guest</account>    \r\n\t</user>    \r\n\r\n\t<user>       \r\n\t\t<username>user2</username>       \r\n\t\t<password>1234</password>       \r\n\t\t<account>guest</account>    \r\n\t</user> \r\n</users>\r\n}}}\r\n\r\nA developer could use the following {{{Xpath}}} command to return all the users with the username:\r\n\r\n{{{\r\n‘user1’ and password ‘password’string(//user[username/text()='user1'        \r\nand password/text()='password']/account/text())\r\n}}}\r\n\r\nHowever, without proper input validation, the attacker could easily input a logic statement to manipulate the output of the query. An attacker could provide the following string to the {{{Xpath}}} statement above.\r\n\r\n{{{\r\nUsername: user1Password: ' or '1' = '1\r\n}}}\r\n\r\nThis will change the {{{Xpath}}} statement to look like this:\r\n\r\n{{{\r\nstring(//user[username/text()='user1' and password/text()=''        \r\nor '1' = '1']/account/text())\r\n}}}\r\n\r\nThe password portion of the query will always resolve to true, which means that the application will authenticate the attacker as {{{user1}}} even though no password was provided.\r\n\r\nA good way to fix this example is to use a parameterized query. The idea here is to create a precompiled query that gets values from parameters instead of dynamically creating an {{{XPath}}} expression by concatenation at run time. Let {{{$username}}} and {{{$password}}} be string variables that hold the users input. Then construct a query in the following way:\r\n\r\n{{{\r\n\"//user[user[username/text()=$username and password/text()=$password]\"\r\n}}}\r\n\r\nIf you are using .NET, see the Additional Resources below for another example of how this works.\r\n\r\n=Additional Resources\r\n\r\n    *For more information on Mitigating XPath Injection Attacks in .NET, see: http://www.tkachenko.com/blog/archives/000385.html\r\n    *For more information on XPATH Injection, see: http://www.owasp.org/index.php/XML_Injection\r\n    *For more information on XPath injection in XML databases, see: http://palisade.plynt.com/issues/2005Jul/xpath-injection/index.php\r\n\r\n=Related Items\r\n\r\n    *[[ae392dbb-fdb4-443f-9d17-78240b4acc95|Attack: XML Injection Attack]]\r\n    *[[b1757bda-0a0d-48e7-b101-3c4088e41878|Attack: SQL Injection Attack]]\r\n    *[[8482159c-5ec2-4b89-9c65-9af765030ff5|Attack: Information Disclosure Attack]]\r\n    *[[9d60faca-687b-4c69-91ba-f5712af0fd02|Attack: Server-Side Code Injection Attack]]\r\n    *[[61f0d74e-d9b6-4e27-9e12-da65baff83fd|Attack: LDAP Injection Attack]]"
        ]
      }
    ]
  }
}