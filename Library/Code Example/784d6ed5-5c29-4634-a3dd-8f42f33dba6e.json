{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "-1213472095",
      "Content_Hash": "47473622"
    },
    "Metadata": [
      {
        "Id": [
          "784d6ed5-5c29-4634-a3dd-8f42f33dba6e"
        ],
        "Id_History": [
          "784d6ed5-5c29-4634-a3dd-8f42f33dba6e,8ab7bd1d-f1d4-4206-8b30-4402a105d460,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "1sink junk Securely Execute a New Process"
        ],
        "Category": [
          "Dangerous APIs"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          ".NET"
        ],
        "Type": [
          "Code Example"
        ],
        "DirectLink": [
          "Securely Execute a New Process"
        ],
        "Tag": [
          "ASP.NET,ASP.NET 4.0,ASP"
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<h1>Applies To</h1>\r\n  <ul>\r\n    <li>ASP.NET 4.0</li>\r\n  </ul>\r\n  <h1>Summary</h1>\r\n  <p>The purpose of this code snippet is to illustrate how to execute a new process under a different user account within a running .NET application.</p>\r\n  <h1>Objectives</h1>\r\n  <ul>\r\n    <li>Secure execution of a new process from within a running application.</li>\r\n    <li>Secure storage and retrieval of credentials needed to run a process encrypted in the DPAPI.</li>\r\n    <li>Deploying an application in \"least privilege\" mode and making use of another, privileged component to perform a critical task.</li>\r\n  </ul>\r\n  <h1>Scenarios</h1>\r\n  <ul>\r\n    <li>Application component needs to access functionality that only exists in a different runtime component.</li>\r\n    <li>Application occasionally needs access to privileged functionality but wants to use a low-privileged security context for enhanced overall security.</li>\r\n  </ul>\r\n  <h1>Solution Example</h1>\r\n  <pre>// Execute a process under another user account, making<br />// use of credentials stored in the DPAPI<br />static public void ExecuteProcess(string fullProcessPath) {<br />    // Retrieve the user and password from the registry and decrypt<br />    byte[] encryptedUser = Registry.GetValue(@\"HKEY_CURRENT_USER\\ProcessExecCreds\", \"User\", null) as byte[];<br />    byte[] encryptedPass = Registry.GetValue(@\"HKEY_CURRENT_USER\\ProcessExecCreds\", \"Pass\", null) as byte[];<br />    string user = Encoding.ASCII.GetString(ProtectedData.Unprotect(encryptedUser, null, DataProtectionScope.CurrentUser));<br />    string pass = Encoding.ASCII.GetString(ProtectedData.Unprotect(encryptedPass, null, DataProtectionScope.CurrentUser));<br />    SecureString securepass = new SecureString();<br />    foreach(char b in pass.ToCharArray()) {<br />                securepass.AppendChar(b);<br />    }<br /><br />    // Execute a process as our stored user account<br />    // This process will run a simple batch file that outputs the runtime account name<br />    Process process = new Process();<br />    process.StartInfo.UseShellExecute = false;<br />    process.StartInfo.RedirectStandardOutput = true;<br />    process.StartInfo.RedirectStandardError = true;<br />    process.StartInfo.CreateNoWindow = true;<br /><br />    // Set the working directory to a value the user will be able to access<br />    process.StartInfo.FileName = fullProcessPath;<br />    process.StartInfo.WorkingDirectory = @\"C:\\\";<br />    process.StartInfo.UserName = user;<br />    process.StartInfo.Password = securepass;<br />    process.Start();<br />    string output = process.StandardOutput.ReadToEnd();<br />    Console.WriteLine(output);<br />}</pre>\r\n  <h1>Problem Example</h1>\r\n  <p>The following example executes simple execution of a process within the user context defined by the running executable. An example </p>\r\n  <pre>// Start my process with a given argument<br />Process.Start(\"MyProc.exe\", @\"MyArg\");</pre>\r\n  <ul>\r\n    <li>The parent application must run with the same level of privileges as the executed process.</li>\r\n    <li>The process path is not fully specified, rendering the Process.Start call more vulnerable to trojan execution.</li>\r\n    <li>Application makes use of a different user context to run the process, but stores the credentials in clear text in a file or database</li>\r\n  </ul>\r\n  <h1>Test Case</h1>\r\n  <p>The following classes must be included in any project making use of the sample code provided above:</p>\r\n  <pre>using System.Diagnostics;<br />using System.IO;<br />using System.Runtime.InteropServices;<br />using System.Security;<br />using System.Security.AccessControl;<br />using System.Security.Cryptography;<br />using Microsoft.Win32;</pre>\r\n  <p>Run the following code to store a set of credentials in the registry using the DPAPI and, in conjunction with the solution method, execute a command as a given user. The example test case executes the \"<em>whoami</em>\" command. </p>\r\n  <pre>static void Main(string[] args){<br />    // prompt for credentials and store in the registry using DPAPI<br />    StoreUserCreds();<br /><br />    // retrieve the credentials from the DPAPI and run a process<br />    ExecuteProcess(@\"whoami.exe\");<br />}<br /><br />// This method provides a mechanism for storing credentials<br />// for a runtime process in the registry using the DPAPI.<br />static public void StoreUserCreds(){<br />    // Obtain username and password for the account<br />    Console.Write(@\"Enter user name for process execution: \");<br />    string user = Console.ReadLine();<br />    Console.Write(\"Enter password for this user name: \");<br />    string pass = Console.ReadLine();<br /><br />    // Convert the username and passwords to byte arrays and encrypt<br />    // the data by using the DPAPI ProtectedData class.<br />    byte[] encryptedUser = ProtectedData.Protect(<br />            UnicodeEncoding.ASCII.GetBytes(user),<br />            null,<br />            DataProtectionScope.CurrentUser);<br />    byte[] encryptedPass = ProtectedData.Protect(<br />            UnicodeEncoding.ASCII.GetBytes(pass),<br />            null,<br />            DataProtectionScope.CurrentUser);<br /><br />    // Create a security context for a new key that we will use to store<br />    // the credentials that will restrict access to only the application user.<br />    string userEnv = Environment.UserDomainName + \"\\\\\" + Environment.UserName;<br />    RegistrySecurity security = new RegistrySecurity();<br />    RegistryAccessRule rule = new RegistryAccessRule(userEnv,<br />            RegistryRights.FullControl,<br />            InheritanceFlags.ContainerInherit,<br />            PropagationFlags.None,<br />            AccessControlType.Allow);<br />    security.AddAccessRule(rule);<br /><br />    // Create a new registry key and apply the security context<br />    Registry.CurrentUser.CreateSubKey(\"ProcessExecCreds\",<br />            RegistryKeyPermissionCheck.ReadWriteSubTree,<br />            security);<br /><br />    // Write the encrypted credentials into the registry<br />    Registry.SetValue(@\"HKEY_CURRENT_USER\\ProcessExecCreds\", \"User\", encryptedUser);<br />    Registry.SetValue(@\"HKEY_CURRENT_USER\\ProcessExecCreds\", \"Pass\", encryptedPass);<br />}</pre>\r\n  <h1>Expected Result</h1>\r\n  <p>The following output was obtaining by running the test case as \"<em>vm-win2003\\Administrator</em>\"</p>\r\n  <pre>Enter user name for process execution: joeuser<br />Enter password for this user name: joeuser1234<br />vm-win2003\\joeuser</pre>\r\n  <h1>More Information</h1>\r\n  <p>The code makes use of the <em>CurrentUser</em> scope instead of the <em>MachineKey</em> scope so that other, potentially malicious applications cannot access this key in the registry and decrypt. This provides additional security but sacrifices interoperability with other applications. Consider using the <em>MachineKey</em> scope if you have a need to share credential data between applications.</p>\r\n  <br />\r\n  <hr />\r\n  <p>Adapted from Microsoft patterns &amp; practices guidance.</p>"
        ]
      }
    ]
  }
}