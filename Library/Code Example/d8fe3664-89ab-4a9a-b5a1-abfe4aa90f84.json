{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "-1802835074",
      "Content_Hash": "680650612"
    },
    "Metadata": [
      {
        "Id": [
          "d8fe3664-89ab-4a9a-b5a1-abfe4aa90f84"
        ],
        "Id_History": [
          "d8fe3664-89ab-4a9a-b5a1-abfe4aa90f84,e0af7283-e5b3-489e-8067-cedcce02644a,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "[SINK] Encrypt a File via a Block Cipher Using 3DES"
        ],
        "Category": [
          "Cryptography"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          ".NET 3.5"
        ],
        "Type": [
          "Code Example"
        ],
        "DirectLink": [
          "Encrypt a File via a Block Cipher Using 3DES"
        ],
        "Tag": [
          ""
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<h1>Applies to</h1>\r\n  <ul>\r\n    <li>C#</li>\r\n  </ul>\r\n  <h1>Summary</h1>\r\n  <p>The purpose of this code is to demonstrate the proper use of a symmetric block cipher. This code sample demonstrates the use of Triple DES, which should primarily be used for backwards compatibility with other applications and replaced with AES in newer implementations of code.</p>\r\n  <h1>Objectives</h1>\r\n  <ul>\r\n    <li>To provide confidentiality of files which are transmitted over insecure or untrusted communication channels. <li>To provide confidentiality of files in storage until they are needed by a user or application <li>To provide backwards compatibility with other applications which only provide encryption using 3DES</li></li></li>\r\n  </ul>\r\n  <h1>Scenarios</h1>\r\n  <ul>\r\n    <li>Application developer desires confidentiality for files in storage or in transit. <li>3DES should only be used in implementations which require backwards compatibility for interaction with applications that do not implement the new NIST encryption standard, AES.</li></li>\r\n  </ul>\r\n  <h1>Solution Example</h1>\r\n  <pre>private static void EncryptFile(string sInputFilename, string sOutputFilename, string sKey, string sIV)<br />&amp;#123;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; // The default 3DES key size under the .NET framework is 192 (168).&amp;nbsp; The following<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; // call will create a 3DES crypto provider and create a random initialization<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; // vector and key. The crypto mode defaults to CBC ensuring the proper chaining <br />&amp;nbsp;&amp;nbsp;&amp;nbsp; // of data to mitigate repetition of cipher text blocks.</pre>\r\n  <pre>\r\n    <br />&amp;nbsp;&amp;nbsp;&amp;nbsp; TripleDESCryptoServiceProvider tdes = (TripleDESCryptoServiceProvider) TripleDESCryptoServiceProvider.Create();</pre>\r\n  <pre>\r\n    <br />&amp;nbsp;&amp;nbsp;&amp;nbsp; // One could override the default randomly generated key and initialization vector<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; // by setting the following properties to the Rijndael Crypto Provider, e.g.:<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; //<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; //&amp;nbsp; tdes.Key = some_key_val;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; //&amp;nbsp; tdes.IV = some_iv_val;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; //&amp;nbsp; tdes.KeySize = 192;&amp;nbsp; <br />&amp;nbsp;&amp;nbsp;&amp;nbsp; // <br />&amp;nbsp;&amp;nbsp;&amp;nbsp; // Similarly a developer may wish to change the default encryption mode, e.g.:<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; //<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; //&amp;nbsp; tdes.Mode = CipherMode.CFB; // Defaults to CBC mode. Use of ECB mode is not recommended<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // as it provides no feedback chaining of ciphertext</pre>\r\n  <pre>\r\n    <br />&amp;nbsp;&amp;nbsp;&amp;nbsp; //Set secret key For 3DES algorithm.<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; tdes.Key = ASCIIEncoding.ASCII.GetBytes(sKey);</pre>\r\n  <pre>\r\n    <br />&amp;nbsp;&amp;nbsp;&amp;nbsp; //Set initialization vector.<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; tdes.IV = ASCIIEncoding.ASCII.GetBytes(sIV);</pre>\r\n  <pre>\r\n    <br />&amp;nbsp;&amp;nbsp;&amp;nbsp; FileStream fsPlaintext = new FileStream(sInputFilename, FileMode.Open, FileAccess.Read);<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; FileStream fsCiphertext = new FileStream(sOutputFilename, FileMode.Create, FileAccess.Write);</pre>\r\n  <pre>\r\n    <br />&amp;nbsp;&amp;nbsp;&amp;nbsp; //Create an 3DES encryptor from the TripleDES instance.<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; ICryptoTransform tdesencrypt = tdes.CreateEncryptor();</pre>\r\n  <pre>\r\n    <br />&amp;nbsp;&amp;nbsp;&amp;nbsp; //Create crypto stream set to read and do an 3DES encryption transform on incoming bytes.<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; CryptoStream cipherstream = new CryptoStream(fsCiphertext, tdesencrypt, CryptoStreamMode.Write);</pre>\r\n  <pre>\r\n    <br />&amp;nbsp;&amp;nbsp;&amp;nbsp; byte&amp;#91;&amp;#93; bytearrayinput = new byte&amp;#91;fsPlaintext.Length&amp;#93;;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; fsPlaintext.Read(bytearrayinput, 0, bytearrayinput.Length);<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; cipherstream.Write(bytearrayinput, 0, bytearrayinput.Length);<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; cipherstream.Close();<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; fsPlaintext.Close();<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; fsCiphertext.Close();<br />&amp;#125;</pre>\r\n  <h1>Problem Example</h1>\r\n  <p>The following example demonstrates an implementation of a Encryption routine containing several common secure coding issues.</p>\r\n  <pre>private static void ProblematicFileEncrypt(string sInputFilename, string sOutputFilename)<br />&amp;#123;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; TripleDESCryptoServiceProvider tdes = (TripleDESCryptoServiceProvider)TripleDESCryptoServiceProvider.Create();</pre>\r\n  <pre>\r\n    <br />&amp;nbsp;&amp;nbsp;&amp;nbsp; //Set secret key For 3DES algorithm.<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; tdes.Key = ASCIIEncoding.ASCII.GetBytes(\"ASAMPLEKEYWEUSETOENCRYPT\");<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; //We don't use an IV because the book doesn't show us an example using a <br />&amp;nbsp;&amp;nbsp;&amp;nbsp; //more secure, chained mode&amp;#33;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; // tdes.IV = ASCIIEncoding.ASCII.GetBytes(\"SAMPLEIV\");</pre>\r\n  <pre>\r\n    <br />&amp;nbsp;&amp;nbsp;&amp;nbsp; //Set encryption mode to an unchained value (because the book says so&amp;#33;)<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; tdes.Mode = CipherMode.ECB;</pre>\r\n  <pre>\r\n    <br />&amp;nbsp;&amp;nbsp;&amp;nbsp; //Create a file stream to read the plaintext contents in.<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; FileStream fsPlaintext = new FileStream(sInputFilename, FileMode.Open, FileAccess.Read);<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; FileStream fsCiphertext = new FileStream(sOutputFilename, FileMode.Create, FileAccess.Write);</pre>\r\n  <pre>\r\n    <br />&amp;nbsp;&amp;nbsp;&amp;nbsp; //Create an 3DES encryptor<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; ICryptoTransform tdesencrypt = tdes.CreateEncryptor();</pre>\r\n  <pre>\r\n    <br />&amp;nbsp;&amp;nbsp;&amp;nbsp; //Create crypto stream set to read and do an 3DES encryption transform on incoming bytes.<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; CryptoStream cipherstream = new CryptoStream(fsCiphertext, tdesencrypt, CryptoStreamMode.Write);</pre>\r\n  <pre>\r\n    <br />&amp;nbsp;&amp;nbsp;&amp;nbsp; //Write the contents of the encrypted file.<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; byte&amp;#91;&amp;#93; bytearrayinput = new byte&amp;#91;fsPlaintext.Length&amp;#93;;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; fsPlaintext.Read(bytearrayinput, 0, bytearrayinput.Length);<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; cipherstream.Write(bytearrayinput, 0, bytearrayinput.Length);<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; cipherstream.Close();<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; fsPlaintext.Close();<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; fsCiphertext.Close();<br /></pre>\r\n  <ul>\r\n    <li>Cleartext encryption key can be extracted by any user with access to the source code or compiled code <li>Use of a weak encryption key, which can be brute-forced using a dictionary attack <li>Insecure cipher mode (ECB), performs encryption of each block 64 bits independently with no feedback into subsequent blocks as CBC and other chained modes do. An attacker can rearrange or replace blocks with previous blocks they observe. <li>ECB mode does not utilize an initialization vector, yielding the same encrypted value for each plaintext value. An attacker can thus observe patterns in the encrypted blocks and perform known plaintext attacks (Note: Initialization vectors need not remain secret however they should be random for each encrypted value of the plaintext)</li></li></li></li>\r\n  </ul>\r\n  <h1>Test Case</h1>\r\n  <p>The following classes must be included in any project making use of the sample code provided above:</p>\r\n  <pre>using System;<br />using System.Text;<br />using System.IO;<br />using System.Security.Cryptography;</pre>\r\n  <p>The following test case demonstrates the use of the EncryptFile function</p>\r\n  <pre>static void Main(string&amp;#91;&amp;#93; args)<br />&amp;#123;<br />    Console.Out.WriteLine(\"Encrypting: \" &amp;#43; args&amp;#91;0&amp;#93; &amp;#43; \" to file: \" &amp;#43; args&amp;#91;1&amp;#93;);<br />    EncryptFile(args&amp;#91;0&amp;#93;, args&amp;#91;1&amp;#93;, sKey, sIV);<br />    Console.Out.WriteLine(\"Decrypting: \" &amp;#43; args&amp;#91;1&amp;#93; &amp;#43; \" to file: \" &amp;#43; args&amp;#91;0&amp;#93; &amp;#43; \".new\");<br />    DecryptFile(args&amp;#91;1&amp;#93;, args&amp;#91;0&amp;#93; &amp;#43; \".new\", sKey, sIV);<br />&amp;#125;</pre>\r\n  <ul>\r\n    <li>sKey and sIV are retrieved from the DataProtection API within Application code</li>\r\n  </ul>\r\n  <h1>Expected Result</h1>\r\n  <p>Comparing the Decrypted file value with the original file text should yield the same text.</p>\r\n  <h1>More Information</h1>\r\n  <ul>\r\n    <li>The test case assumes use of the DataProtection API implemented within the user code to securely store and retrieve encryption keys.</li>\r\n  </ul>\r\n  <hr />\r\n  <p>Adapted from Microsoft patterns &amp; practices guidance.</p>"
        ]
      }
    ]
  }
}