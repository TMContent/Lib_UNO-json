{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "757988945",
      "Content_Hash": "-525697545"
    },
    "Metadata": [
      {
        "Id": [
          "ec15e372-bf2e-47b1-90ee-1669f97e5f0c"
        ],
        "Id_History": [
          "ec15e372-bf2e-47b1-90ee-1669f97e5f0c,1762bf77-2c91-4bf3-b11d-db65d610f256,"
        ],
        "Library_Id": [
          "92718d53-36b2-47bc-b6f5-e60994385f46"
        ],
        "Title": [
          "Generate a Message Authentication Code MAC"
        ],
        "Category": [
          "Cryptography"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          ".NET 3.5"
        ],
        "Type": [
          "Code Example"
        ],
        "DirectLink": [
          "Generate a Message Authentication Code MAC"
        ],
        "Tag": [
          "ASP.NET,ASP.NET 3.5,ASP"
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<h1>Applies to</h1>\n  <ul>\n    <li>C# </li>\n  </ul>\n  <h1>Summary</h1>\n  <p>Message Authentication Codes or MACs are used by two parties to validate that a message hadn't been altered in transit. Only the nodes which posses the keys may compute the MAC and validate the MAC against an input text. This code sample demonstrates the use of an HMAC.</p>\n  <h1>Objectives</h1>\n  <ul>\n    <li>Provide a method to detect message modification and tampering, this method should not allow an attacker to easily generate and modify the MAC in transit. <li>Generate a cryptographically strong key which appears random in value for use as an HMAC signing key </li></li>\n  </ul>\n  <h1>Scenarios</h1>\n  <ul>\n    <li>Two entities are communicating over a sockets interface (clear-text or encrypted communications) and wish to detect message modification for data in transit <li>Two entities wish to prevent message modification for data in transit via a sockets interface (clear-text or encrypted communications) </li></li>\n  </ul>\n  <h1>Solution Example</h1>\n  <pre>public static string GenerateHMAC(string input, string secret)&#123;<br />    // Instantiate the HMAC class<br />    HMACSHA256 hmac = new HMACSHA256();<br />    try<br />    &#123;<br />        // We pass in a user supplied password to generate a strong key to be used in our HMAC<br />        // since people tend to use weak and potentially dictionary values for keys.<br />          // Using the PasswordDerivedBytes helps to mitigate the risk of dictionary attacks<br />        // on our HMAC key<br />        // In the current implementation, regardless of the salt passed to the PasswordDeriveBytes<br />        // constructor the same derived password will be generated.<br />        PasswordDeriveBytes pdb = new PasswordDeriveBytes(secret, null);<br />        byte&#91;&#93; pbytes = pdb.CryptDeriveKey(\"TripleDES\", \"SHA1\", 192, new byte&#91;&#93; &#123; 0, 0, 0, 0, 0, 0, 0, 0 &#125;);<br />        hmac.Key = pbytes;<br />    &#125;<br />    catch (Exception e)<br />    &#123;<br />        Console.Error.WriteLine(e.ToString());<br />    &#125;<br />    return ASCIIEncoding.ASCII.GetString(hmac.ComputeHash(ASCIIEncoding.ASCII.GetBytes(input)));<br />&#125;</pre>\n  <h1>Problem Example</h1>\n  <p>The following code sample demonstrates the use of a message authenticating code prone to tampering because it simply uses a publicly know hashing mechanism with no shared secret:</p>\n  <pre>public static string GenerateDigest(string input)&#123;<br />    // Instantiate the SHA1 Digest<br />    SHA1 sha = new SHA1CryptoServiceProvider();<br />    return ASCIIEncoding.ASCII.GetString(sha.ComputeHash(ASCIIEncoding.ASCII.GetBytes(input)));<br />&#125;</pre>\n  <h1>Test Case</h1>\n  <p>The following classes must be included in any project making use of the sample code provided above:</p>\n  <pre>using System.Security.Cryptography;</pre>\n  <p>Execute a test encryption and comparison of a two iterations of our plaintext, one which is unaltered and a second which emulates being altered in transit:</p>\n  <pre>static void Main(string&#91;&#93; args)&#123;<br />    string secret = \"thisisaweaksecretkeywhichweuseinourhmac\";<br />    CodeSample cs = new CodeSample();<br />    string text = \"the quick brown fox jumped over the lazy dog\";<br />    // Generate the SHA256 HMAC for the given value based on the keys setup in our constructor<br />    string strHmac = GenerateHMAC(text, secret);<br />    // Append the HMAC to the original text to be sent on the wire. The HMAC serves the purpose<br />    // of validating the integrity of the original message<br />    string msg1 = text &#43; strHmac;<br />    bool isValid = ValidateHMAC(msg1, secret);<br />    Console.Out.WriteLine(\"Validating MSG1 (Unaltered in transit): \" &#43; isValid.ToString());<br />    // Test a variation of the original message with the original HMAC to test validation of the<br />    // HMAC and message.<br />    string msg2 = \"the quick brown dog jumped over the lazy fox\" &#43; strHmac;<br />    isValid = ValidateHMAC(msg2, secret);<br />    Console.Out.WriteLine(\"Validating MSG2 (Altered in transit / text rearranged): \" &#43; isValid.ToString());<br />    // Show our problem example<br />    //Console.Out.WriteLine(\"Digest of '&#123;0&#125;': &#123;1&#125;\", msg2, GenerateDigest(msg1));<br />&#125;</pre>\n  <p>The ValidateHMAC method is shown below for the purposes of validating the HMAC:</p>\n  <pre>public static bool ValidateHMAC(string input, string secret)&#123;<br />    bool isValid = false;<br />    try<br />    &#123;<br />        // Instantiate the HMAC class<br />        HMACSHA256 hmac = new HMACSHA256();<br />        // Since we're using SHA256, we'll take the last 32 bytes from the message,<br />        // recompute the hmac on the first half and compare the two HMACs<br />        string strOrigHMAC = input.Remove(0, input.Length - 32);<br />        string strMsg = input.Substring(0, input.Length - 32);<br />        if (strOrigHMAC == GenerateHMAC(strMsg, secret))<br />        &#123;<br />            isValid = true;<br />        &#125;<br />        else<br />        &#123;<br />            isValid = false;<br />        &#125;<br />    &#125;<br />    catch<br />    &#123;<br />        isValid = false;<br />    &#125;<br />    return isValid;<br />&#125;</pre>\n  <h1>Expected Result</h1>\n  <pre>Validating MSG1 (Unaltered in transit): True<br />Validating MSG2 (Altered in transit / text rearranged): False</pre>\n  <h1>More Information</h1>\n  <ul>\n    <li>An HMAC consists of taking a secret known only to entities wishing to communicate, concatenating this value to the front of a message to be sent. Next, this value is digested with a secure hash function, after which the secret is prepended to the resulting digest and performs a second digest using the secure hash function. <li>The .NET framework provides several HMAC providers. In this example, we've demonstrated the use of creation and validation of an HMAC using the SHA256 hash function. <li>Another goal in choosing a key for the HMAC process is to ensure that keys are strongly generated. Assuming two entities share a weak password it is possible to generate a derived key which resembles a strong and random key to an eavesdropper. </li></li></li>\n  </ul>\n  <h1>Additional Resources</h1>\n  <ul>\n    <li>HMAC definition: <a href=\"http://en.wikipedia.org/wiki/HMAC\">http://en.wikipedia.org/wiki/HMAC</a><li>HMAC class: <a href=\"http://msdn2.microsoft.com/en-US/library/system.security.cryptography.hmac.aspx\">http://msdn2.microsoft.com/en-US/library/system.security.cryptography.hmac.aspx</a><li>Generating a key from a password: <a href=\"http://blogs.msdn.com/shawnfa/archive/2004/04/14/113514.aspx\">http://blogs.msdn.com/shawnfa/archive/2004/04/14/113514.aspx</a></li></li></li>\n  </ul>\n  <hr />\n  <p>Adapted from Microsoft patterns & practices guidance.</p>"
        ]
      }
    ]
  }
}