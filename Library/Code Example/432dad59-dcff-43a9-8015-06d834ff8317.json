{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "-126541231",
      "Content_Hash": "1368665938"
    },
    "Metadata": [
      {
        "Id": [
          "432dad59-dcff-43a9-8015-06d834ff8317"
        ],
        "Id_History": [
          "432dad59-dcff-43a9-8015-06d834ff8317,57b247be-b2be-4fb1-9e7d-a7784643eba5,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "[SINK] Securely Executing a New Process from a .NET Application"
        ],
        "Category": [
          "Concurrency"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          ".NET"
        ],
        "Type": [
          "Code Example"
        ],
        "DirectLink": [
          "Securely Executing a New Process from a .NET Application"
        ],
        "Tag": [
          ""
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ],
        "Source": [
          "ASP.NET 3.5"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<h1>Applies To</h1>\r\n  <ul>\r\n    <li>C#</li>\r\n  </ul>\r\n  <h1>Summary</h1>\r\n  <p>The purpose of this code snippet is to illustrate how to execute a new process under a different user account within a running .NET application.</p>\r\n  <h1>Objectives</h1>\r\n  <ul>\r\n    <li>Secure execution of a new process from within a running application <li>Secure storage and retrieval of credentials needed to run a process encrypted in the DPAPI <li>Deploying an application in \"least privilege\" mode and making use of another, privileged component to perform a critical task</li></li></li>\r\n  </ul>\r\n  <h1>Scenarios</h1>\r\n  <ul>\r\n    <li>Application component needs to access functionality that only exists in a different runtime component <li>Application occasionally needs access to privileged functionality but wants to use a low-privileged security context for enhanced overall security</li></li>\r\n  </ul>\r\n  <h1>Solution Example</h1>\r\n  <pre>// Execute a process under another user account, making<br /> // use of credentials stored in the DPAPI<br />static public void ExecuteProcess(string fullProcessPath) &amp;#123;<br />    // Retrieve the user and password from the registry and decrypt<br />    byte&amp;#91;&amp;#93; encryptedUser = Registry.GetValue(&amp;#64;\"HKEY_CURRENT_USER\\ProcessExecCreds\", \"User\", null) as byte&amp;#91;&amp;#93;;<br />    byte&amp;#91;&amp;#93; encryptedPass = Registry.GetValue(&amp;#64;\"HKEY_CURRENT_USER\\ProcessExecCreds\", \"Pass\", null) as byte&amp;#91;&amp;#93;;<br />    string user = Encoding.ASCII.GetString(ProtectedData.Unprotect(encryptedUser, null, DataProtectionScope.CurrentUser));<br />    string pass = Encoding.ASCII.GetString(ProtectedData.Unprotect(encryptedPass, null, DataProtectionScope.CurrentUser));<br />    SecureString securepass = new SecureString();<br />    foreach(char b in pass.ToCharArray()) &amp;#123;<br />                securepass.AppendChar(b);<br />    &amp;#125;<br />    // Execute a process as our stored user account<br />    // This process will run a simple batch file that outputs the runtime account name<br />    Process process = new Process();<br />    process.StartInfo.UseShellExecute = false;<br />    process.StartInfo.RedirectStandardOutput = true;<br />    process.StartInfo.RedirectStandardError = true;<br />    process.StartInfo.CreateNoWindow = true;<br />    // Set the working directory to a value the user will be able to access<br />    process.StartInfo.FileName = fullProcessPath;<br />    process.StartInfo.WorkingDirectory = &amp;#64;\"C:\\\";<br />    process.StartInfo.UserName = user;<br />    process.StartInfo.Password = securepass;<br />    process.Start();<br />    string output = process.StandardOutput.ReadToEnd();<br />    Console.WriteLine(output);<br />&amp;#125;</pre>\r\n  <h1>Problem Example</h1>\r\n  <p>The following example executes simple execution of a process within the user context defined by the running executable. An example </p>\r\n  <pre>// Start my process with a given argumentProcess.Start(\"MyProc.exe\", &amp;#64;\"MyArg\");</pre>\r\n  <ul>\r\n    <li>Parent application must run with the same level of privileges as the executed process <li>Process path is not fully specified, rendering the Process.Start call more vulnerable to trojan execution </li></li>\r\n  </ul>\r\n  <p>Other problem practices not shown in this example:</p>\r\n  <ul>\r\n    <li>Application makes use of a different user context to run the process, but stores the credentials in clear text in a file or database</li>\r\n  </ul>\r\n  <h1>Test Case</h1>\r\n  <p>The following classes must be included in any project making use of the sample code provided above:</p>\r\n  <pre>using System.Diagnostics;<br />using System.IO;<br />using System.Runtime.InteropServices;<br />using System.Security;<br />using System.Security.AccessControl;<br />using System.Security.Cryptography;<br />using Microsoft.Win32;</pre>\r\n  <p>Run the following code to store a set of credentials in the registry using the DPAPI and, in conjunction with the solution method, execute a command as a given user. The example test case executes the \"whoami\" </p>\r\n  <p>command. </p>\r\n  <pre>static void Main(string&amp;#91;&amp;#93; args)&amp;#123;<br />    // prompt for credentials and store in the registry using DPAPI<br />    StoreUserCreds();<br />    // retrieve the credentials from the DPAPI and run a process<br />    ExecuteProcess(&amp;#64;\"whoami.exe\");<br />&amp;#125;<br />// This method provides a mechanism for storing credentials<br /> // for a runtime process in the registry using the DPAPI.<br /> static public void StoreUserCreds()&amp;#123;<br />    // Obtain username and password for the account<br />    Console.Write(&amp;#64;\"Enter user name for process execution: \")<br />;    string user = Console.ReadLine();<br />    Console.Write(\"Enter password for this user name: \");<br />    string pass = Console.ReadLine();<br />    // Convert the username and passwords to byte arrays and encrypt<br />     // the data by using the DPAPI ProtectedData class.<br />     byte&amp;#91;&amp;#93; encryptedUser = ProtectedData.Protect(<br />                    UnicodeEncoding.ASCII.GetBytes(user),<br />                     null,<br />                     DataProtectionScope.CurrentUser);<br />    byte&amp;#91;&amp;#93; encryptedPass = ProtectedData.Protect(<br />                    UnicodeEncoding.ASCII.GetBytes(pass),<br />                     null,<br />                     DataProtectionScope.CurrentUser);<br />    // Create a security context for a new key that we will use to store<br />     // the credentials that will restrict access to only the application user.<br />    string userEnv = Environment.UserDomainName &amp;#43; \"\\\\\" &amp;#43; Environment.UserName;<br />    RegistrySecurity security = new RegistrySecurity();<br />    RegistryAccessRule rule = new RegistryAccessRule(userEnv,<br />            RegistryRights.FullControl,<br />            InheritanceFlags.ContainerInherit,<br />            PropagationFlags.None,<br />            AccessControlType.Allow);<br />    security.AddAccessRule(rule);<br />    // Create a new registry key and apply the security context<br />     Registry.CurrentUser.CreateSubKey(\"ProcessExecCreds\",<br />             RegistryKeyPermissionCheck.ReadWriteSubTree,<br />             security);<br />    // Write the encrypted credentials into the registry<br />    Registry.SetValue(&amp;#64;\"HKEY_CURRENT_USER\\ProcessExecCreds\", \"User\", encryptedUser);<br />    Registry.SetValue(&amp;#64;\"HKEY_CURRENT_USER\\ProcessExecCreds\", \"Pass\", encryptedPass);<br />&amp;#125;</pre>\r\n  <h1>Expected Result</h1>\r\n  <p>The following output was obtaining by running the test case as \"vm-win2003\\Administrator\"</p>\r\n  <pre>Enter user name for process execution: joeuser<br />Enter password for this user name: joeuser1234<br />vm-win2003\\joeuser</pre>\r\n  <h1>More Information</h1>\r\n  <p>The code makes use of the CurrentUser scope instead of the MachineKey scope so that other, potentially malicious applications cannot access this key in the registry and decrypt. This provides additional security but sacrifices interoperability with other applications. Consider using the MachineKey scope if you have a need to share credential data between applications.</p>\r\n  <h1>Additional Resources</h1>\r\n  <ul>\r\n    <li>Process Class Reference: <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfsystemdiagnosticsprocessclassstarttopic.asp\">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfsystemdiagnosticsprocessclassstarttopic.asp</a></li>\r\n  </ul>\r\n  <hr />\r\n  <p>Adapted from Microsoft patterns &amp; practices guidance.</p>"
        ]
      }
    ]
  }
}