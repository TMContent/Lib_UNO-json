{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "-1486758888",
      "Content_Hash": "137835978"
    },
    "Metadata": [
      {
        "Id": [
          "172c224e-c3e5-4a5f-bf7a-26fe2db406a4"
        ],
        "Id_History": [
          "172c224e-c3e5-4a5f-bf7a-26fe2db406a4,cf854fa3-eb83-44e0-b6d2-9be0bd3f8b27,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "Encrypt Communication Links"
        ],
        "Category": [
          "Communication Security"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          "Java"
        ],
        "Type": [
          "Guideline"
        ],
        "DirectLink": [
          "Encrypt Communication Links"
        ],
        "Tag": [
          ""
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          "2"
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "html"
        },
        "Data": [
          "<h1>Applies to</h1>\r\n  <ul>\r\n    <li>Applications written using Servlets or JSP.</li>\r\n  </ul>\r\n  <h1>What to Do</h1>\r\n  <p>Encrypt the communication channels when interacting with other software across the network.</p>\r\n  <h1>Why</h1>\r\n  <p>Encrypting the communication links allows the application to preserve the confidentiality and integrity of the transmitted data. </p>\r\n  <h1>When</h1>\r\n  <p>If sensitive data must be transmitted between two hosts, either&amp;nbsp;between servers or between application and server, then encrypt the communication links.</p>\r\n  <h1>How</h1>\r\n  <p>To encrypt the communication links:</p>\r\n  <ol>\r\n    <li>\r\n      <p>\r\n        <strong>Identify the connections used for transmitting sensitive data. </strong>Enumerate all connections between the different servers with other servers or with the application. Identify the sensitive data that is sent over the network and the respective connections that are used for such communication.</p>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Choose the appropriate encryption mechanism. </strong>Depending on the infrastructure, you may consider using IPSec or TLS.</p>\r\n      <ul>\r\n        <li>\r\n          <strong>IPSec:</strong> IPSec is used when the encryption needs to be applied across all involved parties. Since IPSec is designed to secure connections between static hosts that are \"always on,\" use IPSec to secure the network connections between your application's servers. Due to its nature, IPSec requires low level support; therefore, your application would need support from the operating system or a JNI component to manage it. </li>\r\n        <li>\r\n          <strong>TLS:</strong> TLS provides a granular protection which&amp;nbsp;allows only&amp;nbsp;the traffic containing sensitive data to be encrypted. Because TLS has a certificate based design, it allows the protection of data between mobile hosts. Use TLS to secure the communication channel between your application and its users.<br /><br />While Java provides APIs for handling TLS encrypted traffic, it is recommended to follow the manuals associated with the&amp;nbsp;third party software that&amp;nbsp;is being used. For example, if your application connects to a database server, follow the database server's manual on setting up the encryption; if your application is web-oriented, follow the web server's documentation on setting up the TLS certificate. </li>\r\n      </ul>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Apply the appropriate encryption mechanism. </strong>Apply the encryption mechanism of choice at the appropriate locations in the code. Such locations include all functionality that establishes a connection between your application and another entity.</p>\r\n    </li>\r\n  </ol>\r\n  <h1>Problem Example</h1>\r\n  <p>The following code establishes a connection between&amp;nbsp;two servers. Unfortunately, the communication is not encrypted; therefore, it is possible for an attacker to eavesdrop on the connection.</p>\r\n  <pre>String remoteHost = \"server02.example.com\";<br />int remotePort = \"1337\";<br /><br />Socket sock = new Socket(remoteHost, remotePort);<br />InputStreamReader isr = new InputStreamReader(sock.getInputStream());<br />BufferedReader input = new BufferedReader(isr);<br />PrintWriter output = new PrintWriter(sock.getOutputStream(), true);</pre>\r\n  <h1>Solution Example</h1>\r\n  <p>The following code establishes a connection between&amp;nbsp;two servers. Because the communication is encrypted, the confidentiality of the data in transit is preserved; therefore, it is impossible for an attacker to eavesdrop on the connection.</p>\r\n  <pre>String remoteHost = \"server02.example.com\";<br />int remotePort = \"1337\";<br /><br />SSLSocketFactory sslSF = (SSLSocketFactory) SSLSocketFactory.getDefault();<br />SSLSocket sslSock = (SSLSocket) sslSF.createSocket(remoteHost, remotePort);<br /><br />InputStreamReader isr = new InputStreamReader(sslSock.getInputStream());<br />BufferedReader input = new BufferedReader(isr);<br />PrintWriter output = new PrintWriter(sslSocket.getOutputStream(), true);</pre>"
        ]
      }
    ]
  }
}