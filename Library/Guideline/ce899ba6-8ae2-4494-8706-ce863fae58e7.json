{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "-643555541",
      "Content_Hash": "-985500837"
    },
    "Metadata": [
      {
        "Id": [
          "ce899ba6-8ae2-4494-8706-ce863fae58e7"
        ],
        "Id_History": [
          "ce899ba6-8ae2-4494-8706-ce863fae58e7,557ed42b-69ed-4e8f-906b-39bac56f2ae8,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "Filter All User-supplied Filename And Path Input"
        ],
        "Category": [
          "Input and Data Validation"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          ".NET"
        ],
        "Type": [
          "Guideline"
        ],
        "DirectLink": [
          "Filter All User-supplied Filename And Path Input"
        ],
        "Tag": [
          "ASP.NET,ASP.NET 3.5,ASP"
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          "2"
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<h1>What to Do</h1>\n  <p>Carefully validate use supplied filename and path to ensure correct format and validity of location within the context of the application</p>\n  <h1>Why</h1>\n  <p>Filtering paths and filenames helps to avoid a Canonicalization Attack where your application may be caused to read or write to arbitrary files on the server.</p>\n  <h1>When</h1>\n  <p>Whenever the user input used as a filename or path component for a file or similar resource on the server is received.</p>\n  <h1>How</h1>\n  <p>Whenever possible, user supplied input should not be used as a component of any filename or path. When storing files supplied by a user, keep the user-provided filename in a database and store the file on disk under a GUID. Likewise, do not allow users to specify details about which files to access unless absolutely necessary. When you must allow a user to specify part of a filename or path, the following three methods should be used to ensure safe handling of user supplied paths and filenames:</p>\n  <ol>\n    <li>\n      <p>\n        <strong>Validate file paths and names</strong>: to avoid canonicalization bugs, canonicalize the file name by using the System.IO.Path.GetFullPath method.</p>\n    </li>\n    <li>\n      <p>\n        <strong>Use MapPath to prevent cross application mapping</strong>: When using <strong>MapPath</strong> to map a supplied virtual path to a physical path on the server, use the overload of Request.MapPath that accepts a bool parameter so that you can prevent cross-application mapping. In the sample below the final <strong>false</strong> parameter prevents cross-application mapping. This means that a user cannot successfully supply a path that contains \"..\" to traverse outside of your application's virtual directory hierarchy. Any attempt to do this results in an exception:</p>\n    </li>\n    <li>\n      <p>\n        <strong>Use Code Access Security to restrict File IO</strong>: You can configure all the file operations by the web-application to be restricted to its own virtual directory. This is done by configuring the application to run with Medium trust, you can do this by setting the <strong>&lt;trust&gt;</strong> element in Web.config or Machine.config as follows:</p>\n      <pre> &lt;trust level=\"Medium\" /&gt;</pre>\n      <p>Running applications successfully in <strong>Medium trust</strong> requires appropriate design and development techniques. </p>\n    </li>\n  </ol>\n  <h1>Problem Example</h1>\n  <p>In the following code example, the server receives a file name from the user. The server appends the user supplied filename to the a hardcoded path and verifies to see if this file exists on the server. If the file exists, the server opens the file and performs operations on it.</p>\n  <blockquote>\n    <pre>&lt;%@ Page Language=\"C#\" ValidateRequest=\"false\" %&gt;<br /> &lt;script runat=\"server\"&gt;<br />   void submitBtn_Click(object sender, EventArgs e)<br />   {<br />       String fileName = \"c:\\\\configfiles\\\\\" + inputPath.Text;<br />       if (System.IO.File.Exists (fileName))<br />       {<br />            System.IO.FileStream fs = System.IO.File.Open(fileName, System.IO.FileMode.Open);<br />       }<br />   }<br /> &lt;/script&gt;<br /> &lt;html xmlns=\"http://www.w3.org/1999/xhtml/Overview.html\"&gt;<br />   &lt;body&gt;<br />     &lt;form id=\"form1\" runat=\"server\"&gt;<br />       &lt;div&gt;<br />         &lt;asp:TextBox ID=\"inputPath\" Runat=\"server\"<br />               TextMode=\"MultiLine\" Width=\"382px\" Height=\"152px\"&gt;<br />         &lt;/asp:TextBox&gt;<br />         &lt;asp:Button ID=\"submitBtn\" Runat=\"server\" Text=\"Submit\"<br />                      OnClick=\"submitBtn_Click\" /&gt;<br />       &lt;/div&gt;<br />     &lt;/form&gt;<br />   &lt;/body&gt;<br /> &lt;/html&gt;</pre>\n  </blockquote>\n  <p>Here one can clearly notice that the intention of the developer is to limit access to the <strong>C:\\ConfigFiles</strong> folder. However, if a user supplied the input \"..\\windows\\system32\\critical.ini\" then the application will readily join the user supplied input with the hardcoded path and give the attacker access to critical system files.</p>\n  <h1>Solution Example</h1>\n  <p>The server side code of this application is now updated to use the GetFullPath method:</p>\n  <blockquote>\n    <pre> &lt;script runat=\"server\"&gt;<br />   void submitBtn_Click(object sender, EventArgs e)<br />   {<br />       String fileName = \"c:\\\\configfiles\\\\\" + inputPath.Text;<br />       fileName = System.IO.Path.GetFullPath(fileName).ToLower();<br />       if (fileName.StartsWith(\"c:\\\\configfiles\") &amp;&amp;<br />            System.IO.File.Exists (fileName))<br />       {<br />            System.IO.FileStream fs = System.IO.File.Open(fileName, System.IO.FileMode.Open);<br />       }<br />   }<br /> &lt;/script&gt;</pre>\n  </blockquote>\n  <p>Now, the website calls GetFullPath and then verifies that the file name is indeed pointing to somewhere within the C:\\ConfigFiles\\ folder.</p>\n  <br />\n  <hr />\n  <p>Adapted from Microsoft patterns &amp; practices guidance. </p>"
        ]
      }
    ]
  }
}