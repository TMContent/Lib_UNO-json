{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "377293933",
      "Content_Hash": "1314429224"
    },
    "Metadata": [
      {
        "Id": [
          "ebc7a550-8cc5-472c-a04d-c0094b26e15c"
        ],
        "Id_History": [
          "ebc7a550-8cc5-472c-a04d-c0094b26e15c,5907384f-1765-4cf8-826d-7ed57111c4cd,"
        ],
        "Library_Id": [
          "92718d53-36b2-47bc-b6f5-e60994385f46"
        ],
        "Title": [
          "Consider Using LogonUser API, If Your WCF Service Cannot Be Trusted for Delegation"
        ],
        "Category": [
          "Impersonation and Delegation"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          "WCF"
        ],
        "Type": [
          "Guideline"
        ],
        "DirectLink": [
          "Consider Using LogonUser API, If Your WCF Service Cannot Be Trusted for Delegation"
        ],
        "Tag": [
          "WCF 3.5"
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          "J.D. Meier, Jason Taylor, Prashant Bansode, Carlos Farre, Madhu Sundararajan, Rob Boucher, Steve Gregersen"
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<h1>Applies to</h1>\r\n  <ul>\r\n    <li>Microsoft&#174; Windows Communication Foundation (WCF) 3.5 <li>Microsoft Visual Studio&#174; 2008</li></li>\r\n  </ul>\r\n  <h1>What to Do</h1>\r\n  <p>If your WCF service cannot be trusted for Delegation, consider using LogonUser API.</p>\r\n  <h1>How</h1>\r\n  <p>Use the Win32 LogonUser API (via P/Invoke) to create delegation-level impersonation tokens, but only when your WCF service cannot be trusted for delegation, because this option forces you to store user name and passwords on your WCF Service.</p>\r\n  <p>Use the basic authentication mode to get the original user&#8217;s impersonation token so that you will have access to the username and password. You can then get the impersonation token using the LogonUser API. For Service accounts you will have to store the username and password securely, and then using the LogonUser API to get the impersonation token.</p>\r\n  <p>The following code example shows how the LogonUser API is used for impersonation:</p>\r\n  <pre>using System.Runtime.InteropServices;<br />&#8230;<br />// Declare the logon types as constants<br />const long LOGON32_LOGON_NETWORK = 3;</pre>\r\n  <pre>// Declare the logon providers as constants<br />const long LOGON32_PROVIDER_DEFAULT = 0;<br /><br />&#91;DllImport(\"advapi32.dll\",EntryPoint = \"LogonUser\")&#93;<br />private static extern bool LogonUser(<br />           string lpszUsername,<br />           string lpszDomain,<br />           string lpszPassword,<br />           int dwLogonType,<br />           int dwLogonProvider,<br />           ref IntPtr phToken);<br />&#91;DllImport(\"kernel32.dll\", CharSet=CharSet.Auto)&#93;<br />public extern static bool CloseHandle(IntPtr handle);</pre>\r\n  <pre>private void ImpersonateAndUse(string Username,<br />                                        string Password,<br />                                        string Domain)<br />&#123;<br />  IntPtr token = new IntPtr(0);<br />  token = IntPtr.Zero;<br />  // Call LogonUser to obtain a handle to an access token.<br />  bool returnValue = LogonUser(Username, Domain,Password,<br />                                 (int)LOGON32_LOGON_NETWORK,<br />                                 (int)LOGON32_PROVIDER_DEFAULT,<br />                                 ref token);<br />  if (false == returnValue)<br />  &#123;<br />     int ret = Marshal.GetLastWin32Error();<br />     string strErr = String.Format(\"LogonUser failed with error code : &#123;0&#125;\", ret);<br />     throw new ApplicationException(strErr, null);<br />  &#125;<br />  WindowsIdentity newId = new WindowsIdentity(token);<br />  WindowsImpersonationContext impersonatedUser = newId.Impersonate();<br />  try<br />  &#123;<br />     // do the operations using original user security context<br />  &#125;<br />  finally<br />  &#123;<br />     // stop impersonating<br />     impersonatedUser.Undo();<br />     CloseHandle(token);<br />  &#125;<br />&#125;<br /></pre>\r\n  <h1>Additional Resources</h1>\r\n  <ul>\r\n    <li>For more information on the LogonUser API, see &#8220;How to validate user credentials on Microsoft operating systems&#8221; at <a href=\"http://support.microsoft.com/kb/q180548/\">http://support.microsoft.com/kb/q180548/</a><li>For more information, see &#8220;Delegation and Impersonation with WCF&#8221; at <a href=\"http://msdn2.microsoft.com/en-us/library/ms730088.aspx\">http://msdn2.microsoft.com/en-us/library/ms730088.aspx</a><li>For impersonation and delegation Q&A, see the Impersonation/Delegation section of &#8220;WCF 3.5 Questions and Answers&#8220; at <a href=\"http://www.codeplex.com/WCFSecurityGuide/Wiki/View.aspx?title=WCF&#37;20Questions&#37;20and&#37;20Answers&#37;20&#37;28Q&#37;26A&#37;29&referringTitle=Home\">http://www.codeplex.com/WCFSecurityGuide/Wiki/View.aspx?title=WCF&#37;20Questions&#37;20and&#37;20Answers&#37;20&#37;28Q&#37;26A&#37;29&referringTitle=Home</a><a href=\"http://www.codeplex.com/WCFSecurity/Wiki/View.aspx?title=Questions&#37;20and&#37;20Answers&referringTitle=Home\"></a><br /></li></li></li>\r\n  </ul>\r\n  <hr />\r\n  <p>Adapted from Microsoft patterns & practices guidance.</p>"
        ]
      }
    ]
  }
}