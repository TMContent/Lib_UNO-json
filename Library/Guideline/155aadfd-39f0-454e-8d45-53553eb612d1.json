{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "-1675560699",
      "Content_Hash": "347747859"
    },
    "Metadata": [
      {
        "Id": [
          "155aadfd-39f0-454e-8d45-53553eb612d1"
        ],
        "Id_History": [
          "155aadfd-39f0-454e-8d45-53553eb612d1,c0f010d5-bf35-4448-9f59-930c80132e5b,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "Check Array Indexes Before Use"
        ],
        "Category": [
          "Memory Management"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          "C++"
        ],
        "Type": [
          "Guideline"
        ],
        "DirectLink": [
          "Check Array Indexes Before Use"
        ],
        "Tag": [
          ""
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "markdown"
        },
        "Data": [
          "## What to Do ##\r\n\r\nCheck your array indexes before use to ensure that the index is within the array bounds.\r\n\r\n## Why ##\r\n\r\nArray indexing errors, such as buffer overruns can lead to memory being overwritten at arbitrary locations. This can lead to application instability or, with a carefully constructed attack, can lead to code injection.\r\n\r\n## When ##\r\n\r\nWhenever indexing into an array with a variable or calculated value.\r\n\r\n## How ##\r\n\r\nFollow these steps to assure that all array indices are within bounds:\r\n\r\n1. **Identify all functions that use arrays.** Identify functions where array elements are addressed to verify that array indices are validated before use.\r\n\r\n2. **Iterate through array elements safely.** When iterating through array elements, make sure that indices run from zero to n-1, where n is the number of array elements. Array indices start at 0, so the index of the last element of an array is n-1, where n is the number of elements in the array. This is a basic programming concept and is mentioned here for completeness.\r\n\r\n3. **Avoid using input parameters as array indexes.** Write code that does not use input parameters as array indexes. If the application requires it, validate and constrain any input parameters used as array indexes to ensure that the maximum and minimum array bounds cannot be exceeded.\r\n\r\n4. **Validate array indexes before accessing data in the array.** Perform bounds checks on array indexes used to access data within the array before performing the actual access.\r\n\r\n## Problem Example ##\r\n\r\n\r\n\tint main(int argc, char *argv[])\r\n\t{\r\n\tint arraySize = 10;\r\n\tint array[arraySize];\r\n\tint i;\r\n\r\n\t// We are going to populate the array with some arbitrary data\r\n\tfor(i = 0; i < arraySize; i++){\r\n\t\tarray[i] = i * 1000;\r\n\t}\r\n\r\n\t// As silly as this is, this is a common mistake\r\n\t// This code will compile and run\r\n\t// In this case, the data being written is not user controlled so it is not exploitable\r\n\ti = arraySize;\r\n\tarray[i] = i * 1000; \r\n\r\n\t// We can in fact set the iterator to some crazy value \r\n\t// And the code will still compile and run\r\n\t// If the data being written is attacker controlled, the code is probably exploitable\r\n\t// In some cases, if the iterator is attacker controlled, the code might also be exploitable\r\n\ti = 555;\r\n\tarray[i] = i * 1000;\r\n\r\n\t// If we go too far outside the bounds, the code will compile but segfault at runtime\r\n\t}\r\n\r\n\r\n## Solution Example ##\r\n\r\n\r\n\tint main(int argc, char *argv[])\r\n\t{\r\n\tint arraySize = 10;\r\n\tint array[arraySize];\r\n\tint i;\r\n\r\n\t// We are going to populate the array with some arbitrary data\r\n\tfor(i = 0; i < arraySize; i++){\r\n\t\tarray[i] = i * 1000;\r\n\t}\r\n\r\n\t// Somehow the iterator is set out of bounds\r\n\t// This is a contrived example to illustrate a point\r\n\t// However, setting the iterator to the size of the array is a common error\r\n\ti = 555;\r\n\t// We are going to validate the iterator before performing an action\r\n\t// Obviously the array will not be accessed in this case\r\n\tif(i >= 0 && i < arraySize) array[i] = i * 1000; \r\n\t// If the iterator is outside of bounds, indicate an error condition \r\n\telse return -1;\r\n\t}\r\n\r\n\r\n"
        ]
      }
    ]
  }
}