{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "458595276",
      "Content_Hash": "-1587499006"
    },
    "Metadata": [
      {
        "Id": [
          "254ddab5-ecd2-4e05-a2b0-861e970bc0d9"
        ],
        "Id_History": [
          "254ddab5-ecd2-4e05-a2b0-861e970bc0d9,c2a4f8a4-458a-4e63-9c85-b1c1c970fbed,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "[SINK] Protect Session Cookies"
        ],
        "Category": [
          "Session Management"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          ".NET 3.5"
        ],
        "Type": [
          "Guideline"
        ],
        "DirectLink": [
          "Protect Session Cookies"
        ],
        "Tag": [
          "ASP.NET,ASP.NET 3.5,ASP"
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          "2"
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<br />\r\n  <h1>What to Do</h1>\r\n  <p>Protect the confidentiality and integrity of session cookies.</p>\r\n  <h1>Why</h1>\r\n  <p>Session cookies are used by an application to identify the session associated with a particular user. Protecting session cookies can help prevent an attacker from hijacking the session and posing as a legitimate user.</p>\r\n  <h1>When</h1>\r\n  <p>If your application uses cookies to maintain a user's session state.</p>\r\n  <h1>How</h1>\r\n  <p>Use the following steps to secure session cookies:</p>\r\n  <ol>\r\n    <li>\r\n      <p>\r\n        <strong>Do not allow users to choose their own session identifiers</strong>: Generating and using your own values as session IDs may lead to session prediction attacks if the values can be forecasted or are based on guessable elements like the username. Instead, use the IDs that are generated by ASP.NET for its sessions. This minimizes the risk of an attacker hijacking another user's session because a strongly random ID is assigned to each session (and can be accessed via <strong>Session.SessionID</strong>).</p>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Do not reuse sessions</strong>: Always use clean sessions. This prevents old data (possibly from another user) from being disclosed and helps to protect the privacy and the integrity of user accounts. To make sure that sessionIDs are never recycled you must set the <strong>regenerateExpiredSessionId</strong> attribute of the <strong>sessionState</strong> configuration to <strong>false</strong>. The sessionState element can be set in the Machine.config or Web.config file, as shown below:</p>\r\n      <pre>&lt;sessionState<br />   ...<br />   ...<br />   cookieless=\"UseCookies\"<br />   cookieName=\"ASP.NET_SessionId\"<br />   timeout=\"20\"<br />   allowCustomSqlDatabase=\"false\" <br /><strong>regenerateExpiredSessionId=\"false\"<br /></strong> &lt;/sessionState&gt;</pre>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Time-out sessions</strong>: Set an expiration time for sessions. This helps mitigate the threat of an HTTP Session Hijacking Attack by giving an attacker a smaller window of opportunity. Depending on your application an appropriate timeout can be anywhere from 10 to 30 minutes. The timeout value (in minutes) can be set via the <strong>timeout</strong> attribute in the sessionState configuration:</p>\r\n      <pre>&lt;sessionState<br />   ...<br />   ...<br />   cookieless=\"UseCookies\" <br />   cookieName=\"ASP.NET_SessionId\" <br /><strong>timeout=\"10\" <br /></strong>   allowCustomSqlDatabase=\"false\" <br />   regenerateExpiredSessionId=\"false\"<br /> &lt;/sessionState&gt;</pre>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Allow users to terminate their sessions</strong>: Allowing users to invalidate their sessions reduces the risk of session hijacking. When a user decides to log-off from the web application, use the <strong>Session.Abandon()</strong> method in conjunction with setting the <strong>regenerateExpiredSessionId</strong> attribute to false (as mentioned in point #2). Once the <strong>Session.Abandon()</strong> method is called the current session is no longer valid and a new session can be started.</p>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Hide cookies from scripts</strong>: Authentication cookies are only used on the server side to authenticate requests coming from a user; they're never used on the client. Preventing the client from accessing them via scripts means that if a script injection attack occurs, the attacker will not be able to steal a user's cookies. This can be done by setting the <strong>httpOnlyCookies</strong> attribute in the <strong>httpCookies</strong> configuration of web.config or machine.config file as follows:</p>\r\n      <pre>&lt;system.web&gt;<br />...<br /><strong>&lt;httpCookies httpOnlyCookies=\"true\" requireSSL=\"true\" topic=\"\" /&gt;</strong><br />...<br />&lt;/system.web&gt;</pre>\r\n      <p>This value can also be set programmatically by setting the <strong>HttpOnly</strong> property in the <strong>System.Net.Cookie</strong> class. This protection is only effective for users using Microsoft's Internet Explorer and can be circumvented in a variety of ways, but still adds a layer of defense.</p>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Ensure that cookies are sent over encrypted channels</strong>: Use SSL to protect the integrity and confidentiality of session cookies for both authentication and authorization in order to prevent users from assuming other user's identities, or from altering the roles they have in the system.</p>\r\n      <p>\r\n        <strong>For Authentication</strong>: When using forms authentication in ASP.NET, set the <strong>requireSSL</strong> attribute in the <strong>authentication</strong> configuration, which is stored in the web.config file for your web application. It may be set as follows:</p>\r\n      <pre>&lt;authentication mode=\"Forms\"&gt;<br />  &lt;forms loginUrl=\"member_login.aspx\"<br />    cookieless=\"UseCookies\"<br /><strong>requireSSL=\"true\"<br /></strong>    path=\"/MyApplication\" /&gt;<br />&lt;/authentication&gt;</pre>\r\n      <p>\r\n        <strong>For Authorization</strong>: If a user can alter their authorization cookie, they can potentially alter the roles they are allowed to take in the system. Reading another user's authorization cookie may allow a user to forge a working authorization cookie, again allowing them to gain more access to the system than they should have. Encrypt the authorization cookies by setting the <strong>cookieProtection</strong> attribute of the <strong>roleManager</strong> configuration in the web.config or machine.config file for your web application to <strong>All</strong>, and ensure it is only sent over secure connections by setting the <strong>cookieRequireSSL</strong> attribute. They may be set as follows:</p>\r\n      <pre>&lt;roleManager enabled=\"true\"<br />  cacheRolesInCookie=\"true\"<br />  cookieName=\".ASPROLES\"<br />  cookieTimeout=\"30\"<br />  cookiePath=\"/\"<br /><strong>cookieRequireSSL=\"true\"<br /></strong>  cookieSlidingExpiration=\"true\"<br /><strong>cookieProtection=\"All\"<br /></strong>  createPersistentCookie=\"false\"&gt;<br />&lt;/roleManager&gt;</pre>\r\n      <p>\r\n        <strong>Without SSL</strong>: If SSL can not be used for your application (sometimes true in mobile applications), then set the <strong>cookieSlidingExpiration</strong> attribute to <strong>false</strong> for both authentication and authorization cookies. When this attribute is set along with the <strong>timeout</strong> attribute (described above) it forces your user to re-authenticate after the set timeout period regardless of user activity (or inactivity). This can be set for authentication cookies as follows:</p>\r\n      <pre>&lt;authentication mode=\"Forms\"&gt;<br />  &lt;forms loginUrl=\"member_login.aspx\"<br />    cookieless=\"UseCookies\"<br />    requireSSL=\"true\"<br />    path=\"/MyApplication\"<br /><strong>slidingExpiration=\"false\"</strong> /&gt;<br />&lt;/authentication&gt;</pre>\r\n      <p>And it can be set for authorization cookies as follows:</p>\r\n      <pre>&lt;roleManager enabled=\"true\"<br />  cacheRolesInCookie=\"true\"<br />  cookieName=\".ASPROLES\"<br />  cookieTimeout=\"30\"<br />  cookiePath=\"/\"<br />  cookieRequireSSL=\"false\"<br /><strong>cookieSlidingExpiration=\"false\"<br /></strong>  cookieProtection=\"All\"<br />  createPersistentCookie=\"false\"&gt;<br />&lt;/roleManager&gt;</pre>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Do not use persistent session cookies</strong>: Persistent session cookies will be stored in a user profile and can be compromised if an attacker gets physical access to the machine or if a user who accesses your application from public machines forgets to log out. It's acceptable to have a persistent user identification cookie, so that you can welcome a returning user to the site by name. However, be very careful that the identification cookie does not become a login cookie or allow access to any protected resources. To prevent unauthorized access, follow one of the following steps:</p>\r\n      <ul>\r\n        <li>\r\n          <p>If using Login controls: Set the <strong>DisplayRememberMe</strong> property of the <strong>Login</strong> control to <strong>false</strong>.</p>\r\n        </li>\r\n        <li>\r\n          <p>If you are not using the login controls, you can specify a non-persistent cookie when you call either the <strong>RedirectFromLoginPage</strong> or <strong>SetAuthCookie</strong> methods of the <strong>FormsAuthentication</strong> class having validated the user's credentials, as shown here:</p>\r\n          <pre>public void Login_Click(object sender, EventArgs e)<br />{<br />   // Is the user valid?<br />   if (Membership.ValidateUser(userName.Text, password.Text))<br />   {<br />        // Parameter two set to false indicates non-persistent cookie<br />        FormsAuthentication.RedirectFromLoginPage(username.Text, false);<br />   }<br />   else <br />   {  <br />        Status.Text = \"Invalid credentials. Please try again.\";<br />   }<br />}</pre>\r\n        </li>\r\n      </ul>\r\n      <p>For authorization cookies, set the createPersistentCookie attribute of the roleManager configuration. It may be set as follows:</p>\r\n      <pre>&lt;roleManager enabled=\"true\"<br />             cacheRolesInCookie=\"true\"<br />             cookieName=\".ASPROLES\"<br />             cookieTimeout=\"30\"<br />             cookiePath=\"/\"<br />             cookieRequireSSL=\"true\"<br />             cookieSlidingExpiration=\"true\"<br />             cookieProtection=\"All\"<br />             createPersistentCookie=\"false\"&gt;&lt;/roleManager&gt;</pre>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Use unique cookie names and paths</strong>: By ensuring unique names, you prevent possible problems that can occur when hosting multiple applications on the same server. For example, if you do not use distinct names, it is possible for a user who is authenticated in one application to make a request to another application without being redirected to that application's login page.</p>\r\n      <p>Set a unique value for the <strong>name</strong> and <strong>path</strong> attributes on the &lt;<strong>forms</strong>&gt; element at the following locating in your web.config file.</p>\r\n      <pre>&lt;forms name=\"YourAppName\"<br />       path=\"/FormsAuth\" ... /&gt;</pre>\r\n    </li>\r\n  </ol>\r\n  <h1>Problem Example</h1>\r\n  <p>A web application uses SSL to provide a secure connection for user data, generates strong, new session IDs for each user, and times out and terminates sessions appropriately. However, it is susceptible to cross-site scripting flaws, and despite having a user base that mostly uses IE, does not set <strong>httpOnlyCookies</strong> on its cookies. The web.config file for this application looks like this:</p>\r\n  <pre>&lt;system.web&gt;<br />  ...<br />  &lt;httpCookies httpOnlyCookies=\"<strong>false</strong>\" requireSSL=\"true\" topic=\"\" /&gt;<br />  ...<br />&lt;/system.web&gt;</pre>\r\n  <p>When the Cross Site Scripting Attack is discovered by an attacker, she uses it to steal user session cookies via a malicious script and is then able to impersonate those users.</p>\r\n  <h1>Solution Example</h1>\r\n  <p>The designers of the web application learn their lesson and in addition to fixing and preventing further Cross-Site Scripting vulnerabilities, they also decide to hide their authentication cookies from scripts as an added layer of defense. They do this by setting the <strong>httpOnlyCookies</strong> attribute as follows:</p>\r\n  <pre>&lt;system.web&gt;<br />  ...<br />  &lt;httpCookies httpOnlyCookies=\"<strong>true</strong>\" requireSSL=\"true\" topic=\"\" /&gt;<br />  ...<br />&lt;/system.web&gt;</pre>\r\n  <p>This prevents any scripts (including most malicious ones) in the client browser from accessing the authentication cookie, and the users of the system are now safer.</p>\r\n  <hr />\r\n  <p>Adapted from Microsoft patterns & practices guidance. </p>"
        ]
      }
    ]
  }
}