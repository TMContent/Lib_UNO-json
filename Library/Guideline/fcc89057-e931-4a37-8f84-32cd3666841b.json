{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "-511131628",
      "Content_Hash": "1948815992"
    },
    "Metadata": [
      {
        "Id": [
          "fcc89057-e931-4a37-8f84-32cd3666841b"
        ],
        "Id_History": [
          "fcc89057-e931-4a37-8f84-32cd3666841b,bf9f515a-3073-474a-9a9b-dd7ac13ef416,"
        ],
        "Library_Id": [
          "92718d53-36b2-47bc-b6f5-e60994385f46"
        ],
        "Title": [
          "Consider Using the Sealed Keyword"
        ],
        "Category": [
          "Design Considerations"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          ".NET 3.5"
        ],
        "Type": [
          "Guideline"
        ],
        "DirectLink": [
          "Consider Using the Sealed Keyword"
        ],
        "Tag": [
          ""
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<h1>What to Do</h1>\r\n  <p>If you do not want anyone to extend your base classes, you should mark them with the <b>sealed</b> keyword.</p>\r\n  <h1>Why</h1>\r\n  <p>If a class is not intended to be extended and is not sealed, it gives apportunity to malicious users to extend the class and launch attacks&nbsp;against your code.&nbsp;</p>\r\n  <h1>When</h1>\r\n  <p>Before you use the <b>sealed</b> keyword at the class level, you should carefully evaluate your extensibility requirements. It is especially important to seal a class in the following situations: </p>\r\n  <ul>\r\n    <li>The class contains security secrets, such as passwords, that are accessible through protected APIs. <li>The class contains many virtual members that cannot be sealed, and the type is not designed for third-party extensibility.</li></li>\r\n  </ul>\r\n  <h1>How</h1>\r\n  <p>You can use the <b>sealed</b> keyword at the class and method level. In Visual Basic .NET, you can use the <b>NotInheritable</b> keyword at the class level or <b>NotOverridable</b> at the method level. </p>\r\n  <p>You can also seal individual methods and properties within a class. For example, if you derive from a base class that has virtual members and you do not want anyone to extend the functionality of the derived class, you can consider sealing the virtual members in the derived class. Sealing the virtual methods has performance benefits because it makes them candidates for inlining and other compiler optimizations.</p>\r\n  <p>Consider the following example.</p>\r\n  <pre>public class MyClass&#123; <br />&nbsp; protected virtual void SomeMethod() &#123; ... &#125; <br />&#125; <br />You can override and seal the method in a derived class, as follows.</pre>\r\n  <pre>public class DerivedClass : MyClass &#123; <br />&nbsp; protected override sealed void SomeMethod () &#123; ... &#125; <br />&#125;</pre>\r\n  <p>This code ends the chain of virtual overrides and makes <b>DerivedClass.SomeMethod</b> a candidate for inlining.</p>\r\n  <blockquote>\r\n    <b>Note</b>&nbsp;&nbsp;&nbsp;Class sealing is enforced at compile time only. When malicious code runs in a full trust environment, it could use reflection or unmanaged pointers to bypass this restriction.</blockquote>\r\n  <h1>&nbsp;</h1>\r\n  <hr />\r\n  <p>Adapted from Microsoft patterns & practices guidance.</p>"
        ]
      }
    ]
  }
}