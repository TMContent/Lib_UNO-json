{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "1715125178",
      "Content_Hash": "-121247876"
    },
    "Metadata": [
      {
        "Id": [
          "2120b3fe-34c6-47bf-be83-d9756e512d02"
        ],
        "Id_History": [
          "2120b3fe-34c6-47bf-be83-d9756e512d02,c95b6111-18bf-4173-8293-792a1b802e64,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "0sink Do Not Leave Passwords in Memory"
        ],
        "Category": [
          "Authentication"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          ".NET 3.5"
        ],
        "Type": [
          "Guideline"
        ],
        "DirectLink": [
          "Do Not Leave Passwords in Memory"
        ],
        "Tag": [
          "ASP.NET,ASP.NET 3.5,ASP"
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          "2"
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<h1>What to Do</h1>\r\n  <p>Clear passwords from memory after their use.</p>\r\n  <h1>Why</h1>\r\n  <p>Passwords are sensitive data that are used to establish a trust relationship. Leaving them in memory after their use can expose them to an attacker.</p>\r\n  <h1>When</h1>\r\n  <p>If your application handles passwords.</p>\r\n  <h1>How</h1>\r\n  <p>Passwords can be cleared by overwriting the memory where the passwords were stored. Deallocating the memory is not sufficient since the .NET garbage collector gives no guarantee as to when the deallocated memory will be collected or reused. Be aware that any time you assign a password to a new buffer, or pass it as a parameter, the password is being copied and is now in memory in a new location. When clearing memory, ensure you clear every instance.</p>\r\n  <p>Keep in mind the following considerations when handling passwords: </p>\r\n  <ol>\r\n    <li>\r\n      <p>\r\n        <strong>Identify all password use. </strong>Locate all code segments, both functions and data members, that handle passwords. These can be functions and data structures scattered throughout the application. If the application cannot be managed as easy, centralize all code that handles passwords. </p>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Store passwords in mutable objects.</strong> Mutable objects allow the data in them to be overwritten. This is especially useful in .NET as objects are required to be deallocated through the garbage collector. Therefore there is no certainty when the password instance will be deallocated from the current process space. Examples of mutable objects include character arrays (i.e. char[]). .NET strings, however, are not mutable objects; therefore, once allocated, their current memory space cannot be modified. When storing a password into an array, make sure you use arrays of primitive data types such as byte, char, and int, but not arrays of the wrapper structures that .NET provides for primitive types such as Byte, Char, and Int32. If you are forced to use .NET strings, (for instance, when calling a function which takes a .NET string), try to construct the string just before use and assign a new value to it as soon as you are done to encourage speedy garbage collection; this is sub-optimal and may lead to security issues, but until the .NET APIs allow for the exclusive use of mutable objects or SecureStrings, it may be unavoidable. </p>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Clear all password instances.</strong> Make sure that all memory locations, where passwords have been stored, are cleared/overwritten after their use. Losing a pointer to a password instance can result in not cleaning that particular memory and allowing the password to leak.</p>\r\n    </li>\r\n  </ol>\r\n  <h1>Problem Example</h1>\r\n  <p>The following code makes a use of a password. Although the pointer to the string is removed and garbage collection is called, .NET does not guarantee the data will be erased.</p>\r\n  <pre>string pass = GetPassword();<br />...<br />pass = null;<br />GC.Collect();</pre>\r\n  <h1>Solution Example</h1>\r\n  <p>The following code makes use of a password. After the password is used, the memory is explicitly cleared. Since strings are immutable objects, the code uses character arrays to store passwords. This makes it possible to overwrite the data after its use. </p>\r\n  <pre>char[] pass = GetPassword();<br />...<br />ClearPassword(pass);<br />pass = null;<br />...<br />void ClearPassword(char[] pass)<br />{      <br />\tfor(int i=0; i&lt;pass.Length; i++)      <br />\t{            <br />\t\tpass[i] = ' ';      <br />\t}<br />}</pre>\r\n  <br />\r\n  <hr />\r\n  <p>Adapted from Microsoft patterns &amp; practices guidance. </p>"
        ]
      }
    ]
  }
}