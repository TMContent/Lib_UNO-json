{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "-1423243523",
      "Content_Hash": "660709238"
    },
    "Metadata": [
      {
        "Id": [
          "4236cf87-7f64-4f77-91b3-04dc1507c366"
        ],
        "Id_History": [
          "4236cf87-7f64-4f77-91b3-04dc1507c366,4e84ca3a-80c6-46dd-b830-e24de68e6b86,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "PHP Include Unique Tokens in HTTP Requests"
        ],
        "Category": [
          "Session Management"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          "PHP"
        ],
        "Type": [
          "Code Example"
        ],
        "DirectLink": [
          "Include Unique Tokens in HTTP Requests"
        ],
        "Tag": [
          ""
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "markdown"
        },
        "Data": [
          "## Applies To ##\r\n\r\n* PHP\r\n\r\n\r\n## Summary ##\r\n\r\nInclude unique tokens in HTTP requests when performing sensitive operations to prevent Cross-Site Request Forgery (CSRF). CSRF may be possible when an attacker can form a URL, which performs an action on the behalf of an authenticated user. Forming such URLs becomes much more difficult, if unique tokens are included in HTTP requests. Including difficult to predict token in HTTP requests is an effective defense against CSRF attacks.\r\n\r\n\r\n## Solution Example ##\r\n\r\nTo include unique tokens in HTTP requests:\r\n\r\n1. **Identify sensitive operations.** Review application design and code to identify all operations that require authorization.\r\n\r\n2. **Identify code that performs sensitive operations.** Identify all pages that are involved in performing sensitive operations - this includes both the pages that link to sensitive operations and the code that actually carries out the sensitive operations.\r\n\r\n3. **Choose a method for generating unique tokens.** There are different ways to generate unique tokens. One approach is to use the uniqid function combined with a hash based on current time. For example:\r\n\r\n\t~~~~\r\n\tuniqid(md5(microtime()), true);\r\n\t~~~~\r\n\r\n4. **Add the unique token to the session.** Add code that generates unique tokens and stores them in session variables to the pages that link to sensitive operations. For example:\r\n\r\n\t~~~~\r\n\tsession_start();\r\n\t$_SESSION['CSRFToken'] = uniqid(md5(microtime()), true);\r\n\t~~~~\r\n\r\n5. **Add unique tokens to HTTP requests.** Add code that sends the generated unique tokens in HTTP requests to the pages that link to sensitive operations. One of the simplest ways to do this is to include the tokens in hidden fields in forms. For example:\r\n\r\n\t~~~~\r\n\t<input type=\"hidden\" name=\"CSRFToken\" value=\"<?php echo $_SESSION['CSRFToken'] ?>\" />\r\n\t~~~~\r\n\r\n6. **Add token validation code.** Add code to the pages that carry out sensitive operations that compares the tokens sent in HTTP requests to the tokens stored in session variables. Comparing the tokens in HTTP requests to tokens in session variables makes sure that the tokens are generated by the server as a part of normal application workflow and therefore the requested action is being performed by a legitimate user. The validation code should look something like the following:\r\n\r\n\t~~~~\r\n\tsession_start();\r\n\tif ($_POST['CSRFToken'] !== $_SESSION['CSRFToken']) {\r\n\t  // The tokens don't match - possible CSRF detected\r\n\t  die('Possible CSRF');\r\n\t}\r\n\t// Validation passed, so tokens match - perform the sensitive operation\r\n\t~~~~\r\n"
        ]
      }
    ]
  }
}