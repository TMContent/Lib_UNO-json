{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "-1307081589",
      "Content_Hash": "708165234"
    },
    "Metadata": [
      {
        "Id": [
          "fda6f06b-c276-43e1-a74d-fcb28cdda689"
        ],
        "Id_History": [
          "fda6f06b-c276-43e1-a74d-fcb28cdda689,ebd1be48-afc1-4694-913d-82a51f9bd00b,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "0sink junk Restrict Access to Persisted Keys"
        ],
        "Category": [
          "Cryptography"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          ".NET 3.5"
        ],
        "Type": [
          "Guideline"
        ],
        "DirectLink": [
          "Restrict Access to Persisted Keys"
        ],
        "Tag": [
          ""
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<h1>What to Do</h1>\r\n  <p>When you store keys to be used at run time in persistent storage, use appropriate ACLs and limit access to the keys. Grant access to the keys only to administrators, SYSTEM, and the identity of the code at run time (for example, the Network Service account in the case of ASP.NET applications that run in the default application pool).</p>\r\n  <p>When you back up a key, do not store it in plain text. Instead, use DPAPI to encrypt it or use a strong password and place it on removable media.</p>\r\n  <h1>Why</h1>\r\n  <p>An&amp;nbsp;attacker can gain access to persisted keys if they&amp;nbsp;are not protected with restricted access.&amp;nbsp; </p>\r\n  <h1>When</h1>\r\n  <p>When adding cryptographic support to your application.</p>\r\n  <h1>How</h1>\r\n  <p>Use DPAPI to encrypt the encryption key and store it in a protected registry key. Create an ACL to protect the registry key that allows full control for administrators and read-only access for your application's process account.</p>\r\n  <p>Use of HKEY_LOCAL_MACHINE makes it easier to store Keys at installation time and maintain it later on.</p>\r\n  <p>Here are the steps which you can use to configure the ACLs on the registry key</p>\r\n  <ol>\r\n    <li>Open the registry by running <strong>regedit.exe</strong> from the commandline <li>Locate the regitsry where the data is stored e.g. <strong>My Computer\\HKEY_LOCAL_MACHINE\\SOFTWARE\\TestAppData</strong><li>Right click on the registry key and select <strong>Permissions.</strong><li>Add the required user account which needs the permission and remove all the irrelevant accounts and permissions for them. <li>Click <strong>Apply</strong> and then <strong>Ok</strong> on the <strong>Permission For...</strong> dialog box and close the <strong>Regitsry Editor</strong>.</li></li></li></li></li>\r\n  </ol>\r\n  <p>If your security requirements dictate an even less accessible storage solution, use a key under HKEY_CURRENT_USER. This approach means that you do not have to explicitly configure ACLs because access to the current user key is automatically restricted based on process identity.</p>\r\n  <blockquote>\r\n    <b>Note</b>&amp;nbsp;&amp;nbsp;&amp;nbsp;HKEY_CURRENT_USER allows more restrictive access because a process can access the current user key only if the user profile associated with the current thread or process token is loaded.&amp;nbsp;</blockquote>\r\n  <hr />\r\n  <p>Adapted from Microsoft patterns &amp; practices guidance.</p>"
        ]
      }
    ]
  }
}