{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "731665408",
      "Content_Hash": "-200440412"
    },
    "Metadata": [
      {
        "Id": [
          "a8eb9762-08f6-4e61-afa7-23386cbca281"
        ],
        "Id_History": [
          "a8eb9762-08f6-4e61-afa7-23386cbca281,f5cfa9c3-f355-405e-b532-a81817b3e362,"
        ],
        "Library_Id": [
          "51eb81c3-1d23-4146-ba83-8a6bb9233c11"
        ],
        "Title": [
          "Validate All Input"
        ],
        "Category": [
          "Input and Data Validation"
        ],
        "Phase": [
          "Design"
        ],
        "Technology": [
          "C++"
        ],
        "Type": [
          "Guideline"
        ],
        "DirectLink": [
          "Validate All Input"
        ],
        "Tag": [
          ""
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ],
        "Source": [
          "C++"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<h1>What to Do</h1>\n  <p>Whenever user input is accepted, validate it before using it. Start by constraining input and checking for known good data by validating for type, length, format, and range. Sometimes you also need to sanitize input and make potentially malicious input safe. </p>\n  <h1>Why</h1>\n  <p>An attacker may attempt to exploit or discover vulnerabilities by passing invalid input.</p>\n  <h1>When</h1>\n  <p>All input should always be validated, regardless of source.</p>\n  <h1>How</h1>\n  <p>Perform the following steps to assure that all input is validated:</p>\n  <ol>\n    <li>\n      <p>\n        <strong>Identify all sources of input.</strong> Establish your application's trust boundary. The general notion is that all input not generated by your application is untrusted. Enumerate all possible sources of input and make note of the expected input from these sources. An application can have various sources of input. Each of these sources is an entry point to your application and can potentially be used to break your application's security model. Place a content specific validator at each entry point.</p>\n      <li>\n        <p>\n          <strong>Understand the input that your application can handle and process.</strong> Understand the specifics about your application's input. After identifying the different entry points, define the format and type of input that will be provided through each entry point. Build a validator for every format and type of expected input.</p>\n        <li>\n          <p>\n            <strong>Centralize validation.</strong> Centralize your application's validators as it helps strengthen the code by limiting the amount of scattered validation code throughout your application. Place the set of validators on your application's trust boundary. Your application should accept input from the outside world only through its set of validators. When you develop an input- and data-validation architecture for your application, consider developing a library of validation routines in all but the smallest applications. This will help ensure that data is validated in a consistent way throughout the application and provide a single point of maintenance. You need to trace data from entry point to exit point to know how it should be validated. A good library includes routines for all of the different types of validation you need to apply, and these can be used in combination if necessary. </p>\n          <li>\n            <p>\n              <strong>Constrain, reject, and sanitize input.</strong> Constrain what you allow from the beginning. It is much easier to validate data for known valid types, patterns, and ranges (using a white list) than it is to validate data by looking for known bad characters (using a black list). When you design your application, you know what your application expects. The range of valid data is generally a more finite set than the range of potentially malicious input. However, for added defense you might want to reject known bad input and then sanitize the input. Constrain input for type, length, format, and range. Use regular expressions to help constrain text input. Use strong data typing where possible. </p>\n            <li>\n              <p>\n                <strong>Validate input length.</strong> Input length validation is of particular importance in C&#43;&#43; programming, because it is the single most effective measure for preventing buffer overflows. Buffer overflows occur when data is being copied from one data structure in memory to another, which doesn't have enough memory to store all the data. Input length validation assures that only the amount of data that can fit into the target data structure is processed.</p>\n              <li>\n                <p>\n                  <strong>Identify trust boundaries.</strong> Ensure that entry points between trust boundaries validate all input data explicitly. Make no assumptions about the data. The only exception is inside a routine that you know can only be called by other routines within the same trust boundary.</p>\n              </li>\n            </li>\n          </li>\n        </li>\n      </li>\n    </li>\n  </ol>\n  <h1>Related Items</h1>\n  <ul>\n    <li>\n      <a href=\"/article/f14408bf-7874-4514-a440-48dca88c6afb\">Use Regular Expressions to Validate Input</a>\n      <li>\n        <a href=\"/article/62ed6d49-ca67-492a-b3ed-14c18bb8d906\">Use Helper Classes to Assure Input Validation</a>\n      </li>\n    </li>\n  </ul>"
        ]
      }
    ]
  }
}