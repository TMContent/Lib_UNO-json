{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "-1352114686",
      "Content_Hash": "1731190452"
    },
    "Metadata": [
      {
        "Id": [
          "e0f37b23-4bf9-4e95-b839-a4ba48e13d9f"
        ],
        "Id_History": [
          "e0f37b23-4bf9-4e95-b839-a4ba48e13d9f,68c98a7a-ff08-4596-b913-fb8eb91233de,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "[SINK] Do Not Store Keys in Code"
        ],
        "Category": [
          "Cryptography"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          ".NET 3.5"
        ],
        "Type": [
          "Guideline"
        ],
        "DirectLink": [
          "Do Not Store Keys in Code"
        ],
        "Tag": [
          ""
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<h1>What to Do</h1>\r\n  <p>Do not store keys in code. Instead use DPAPI to encrypt the encryption key and store it in a protected registry key. Create an ACL to protect the registry key that allows full control for administrators and read-only access for your application's process account.</p>\r\n  <h1>Why</h1>\r\n  <p>an attacker can disassemble hard-coded keys in your compiled assembly by using tools similar to ILDASM, which will render your key in plain text.</p>\r\n  <h1>When</h1>\r\n  <p>When adding cryptographic support to your application.</p>\r\n  <h1>How</h1>\r\n  <p>You can use DPAPI with the machine key to encrypt the keys, store the encrypted keys beneath a registry key, and then use an ACL that restricts access to your specific application identity to restrict access to the registry key. Alternatively, you can use DPAPI with the user store. In this latter case, you need to load the user account's profile to access the key.</p>\r\n  <p>Consider using the machine store if your application is a server that runs on its own dedicated computer with no other applications, or if you have multiple applications on the same server and you need those applications to be able to share the keys. If you only want specific service accounts to be able to access the DPAPI keys and their profiles are loaded, then use DPAPI with the user store.</p>\r\n  <p>The following code shows how to create a registry key protected with an ACL and how to use DPAPI with the machine store to store encrypted data in the restricted key.</p>\r\n  <pre>using System.Security.Cryptography;<br />using System.Security.AccessControl;<br />using System.Text;<br />using Microsoft.Win32;<br />...</pre>\r\n  <pre>// Get the original data in a byte array<br />byte&#91;&#93; toEncrypt = UnicodeEncoding.ASCII.GetBytes(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \"The Keys to be encrypted\");</pre>\r\n  <pre>// Encrypt the data by using the ProtectedData class.<br />byte&#91;&#93; encryptedData = ProtectedData.Protect(toEncrypt, null,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataProtectionScope.LocalMachine);</pre>\r\n  <pre>// Create a new key in the registry with a restricted ACL <br />// and write stream of bytes to the registry key<br />string user = Environment.UserDomainName &#43; \"\\\\\" &#43; Environment.UserName;<br />RegistrySecurity security = new RegistrySecurity();<br />RegistryAccessRule rule = new RegistryAccessRule(user,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RegistryRights.FullControl,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InheritanceFlags.ContainerInherit,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PropagationFlags.None,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AccessControlType.Allow);<br />security.AddAccessRule(rule);</pre>\r\n  <pre>Registry.CurrentUser.CreateSubKey(\"TestEncryptedData\",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RegistryKeyPermissionCheck.ReadWriteSubTree,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; security);<br />Registry.SetValue(&#64;\"HKEY_CURRENT_USER\\TestEncryptedData\", \"Encrypted\",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; encryptedData);</pre>\r\n  <p>Use the following code to decrypt the Keys stored in the registry.</p>\r\n  <pre>// Read the encrypted data from registry and decrypt the contents <br />byte&#91;&#93; dataFromRegistry = Registry.GetValue(<br />&#64;\"HKEY_CURRENT_USER\\TestEncryptedData\",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \"Encrypted\", null) as byte&#91;&#93;;<br />byte&#91;&#93; decryptedData = ProtectedData.Unprotect(dataFromRegistry, null,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataProtectionScope.LocalMachine);&nbsp;</pre>\r\n  <hr />\r\n  <p>Adapted from Microsoft patterns & practices guidance.</p>"
        ]
      }
    ]
  }
}