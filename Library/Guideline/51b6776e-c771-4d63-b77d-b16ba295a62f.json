{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "34502115",
      "Content_Hash": "1904811828"
    },
    "Metadata": [
      {
        "Id": [
          "51b6776e-c771-4d63-b77d-b16ba295a62f"
        ],
        "Id_History": [
          "51b6776e-c771-4d63-b77d-b16ba295a62f,ac88482f-edca-4436-9e29-55d8d7703d37,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "0sink Encrypt Sensitive Data in the Database"
        ],
        "Category": [
          "Cryptography"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          ".NET 3.5"
        ],
        "Type": [
          "Guideline"
        ],
        "DirectLink": [
          "Encrypt Sensitive Data in the Database"
        ],
        "Tag": [
          "ASP.NET,ASP.NET 3.5,ASP"
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          "2"
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<br />\r\n  <h1>What to Do</h1>\r\n  <p>Encrypt any sensitive data that you store in a database.</p>\r\n  <h1>Why</h1>\r\n  <p>Encrypted data in SQL Server is a final line of defense. Even if an attacker successfully gains access to a database, she must still decrypt the data. Although key management and encryption overhead add to the cost and complexity of an application, at-rest data encryption can greatly increase application security. Furthermore, it is or will be required for some classes of personally identifiable information, such as credit card records, and can reduce corporate liability even when not required. </p>\r\n  <h1>When</h1>\r\n  <p>You should consider the level of protection required, and use encryption only when protecting a field is worth the cost incurred. Good candidates for encryption include credit cards numbers, passwords, medical records, government ID numbers, and other highly sensitive and/or personally identifiable information which cannot be stored as salted hashes. </p>\r\n  <h1>How</h1>\r\n  <p>\r\n    <strong>Set Up the Database Master Key</strong>. The Service Master Key, a symmetric key that directly or indirectly encrypts all keys on the server, is created automatically when you install SQL Server. If it is compromised, an attacker can eventually crack every key in every database. For that reason, it's protected by the Data Protection API (DPAPI) in Windows. Within the scope of a database, the database master key is the root encryption object for all keys, certificates, and data in the database, and you must create a database master key (with a user-supplied password) before using it: </p>\r\n  <pre>\tCREATE MASTER KEY ENCRYPTION BY PASSWORD = 'WeZ#6hv*XHq#akAEaqcr7%CUP3aQ'</pre>\r\n  <p>The resulting key is encrypted with triple DES and stored twice. One storage location is in the <strong>sys.symmetric_keys</strong> database table, encrypted by the supplied password, and the second is the <strong>sys.databases</strong> table in the master database, encrypted using the Service Master Key. Note that moving databases with keys set between SQL server installations takes extra work, as the Service Master Keys will be different. </p>\r\n  <p>\r\n    <strong>Create Sub-keys for Application Use. </strong>Once the database master key exists, you can use it to create any of three types of keys, depending on the encryption you need: </p>\r\n  <ul>\r\n    <li>\r\n      <p>Asymmetric keys are used for public key cryptography with a public and private key pair. The following will create an asymmetric key pair with the private key protected by a user-supplied password:</p>\r\n      <pre>CREATE ASYMMETRIC KEY User1AsymmetricKey    AUTHORIZATION User1    WITH ALGORITHM = RSA_2048  <br />  ENCRYPTION BY PASSWORD = 'AVeryVerySecretPassword'</pre>\r\n      <p>Create another that is protected by the database master key:</p>\r\n      <pre>CREATE ASYMMETRIC KEY User2AsymmetricKey <br />   AUTHORIZATION User1    WITH ALGORITHM = RSA_2048</pre>\r\n    </li>\r\n    <li>\r\n      <p>Symmetric keys are used for shared secrets where the same key both encrypts and decrypts data. The following will create a symmetric key pair with the private key protected by a user-supplied password:</p>\r\n      <pre>CREATE SYMMETRIC KEY User1SymmetricKey    WITH ALGORITHM = AES_256   <br /> ENCRYPTION BY PASSWORD = 'AVeryVerySecretPassword'</pre>\r\n    </li>\r\n    <li>\r\n      <p>Certificates are essentially wrappers for a public key. The database master key must already exist. The following will create a certificate associated with User1, encrypted with the database master key:</p>\r\n      <pre>CREATE CERTIFICATE User1Certificate    AUTHORIZATION User1 WITH subject = 'Certificate For User1'GO</pre>\r\n      <p>Create a certificate for User2 that is limited:</p>\r\n      <pre>CREATE CERTIFICATE User2Certificate    AUTHORIZATION User2 WITH subject = 'Certificate For User2',  <br />  EXPIRY_DATE = '12/31/2005',    ENCRYPTION_PASSWORD = 'q%dsabciJ&amp;#QZk#wM5G!WB36z5m7'</pre>\r\n    </li>\r\n  </ul>\r\n  <p>You can have SQL Server create a certificate for its own use or import a certificate created by any trusted certificate authority, such as Microsoft Certificate Server or VeriSign. Options include setting a password to use to encrypt the private key or letting SQL Server use the database master key, as well as setting the creation and expiration dates. </p>\r\n  <p>\r\n    <strong>Encrypt Data in the Database. </strong>Once the keys or certificate exist, you can encrypt data using the appropriate T-SQL function that supports encryption. Imagine that you have a table called Customer defined like this:</p>\r\n  <pre>CREATE TABLE Customer (    CustId int,     name nvarchar(30),     City varchar(20),  <br />   CreditCardType varbinary(300),    CreditCardNumber varbinary(300),     Notes varbinary(4000))GO</pre>\r\n  <p>Encrypted data is binary, so the table must use <strong>varbinary</strong> fields to hold it. Here is how you can insert a row of encrypted data into this table using Asymmetric and Symmetric encryption and Certificates.</p>\r\n  <p>\r\n    <strong>Using Asymmetric Encryption</strong>\r\n  </p>\r\n  <p>\r\n    <strong>To encrypt:</strong>\r\n  </p>\r\n  <pre>OPEN ASYMMETRIC KEY User1AsymmetricKey\t<br />USING PASSWORD = 'AGreatPassword'INSERT INTO Customer VALUES (5, 'Sally Roe', 'Chatinika',\t</pre>\r\n  <pre>EncryptByKey(Key_GUID('User1AsymmetricKey'), 'Visa'),\t<br />EncryptByKey(Key_GUID('User1AsymmetricKey'), '1234-5678-9009-8765'),\t</pre>\r\n  <pre>EncryptByKey(Key_GUID('User1AsymmetricKey'), 'One of our best customers. </pre>\r\n  <pre>Treat like royalty.'))CLOSE ASYMMETRIC KEY User1AsymmetricKey</pre>\r\n  <p>\r\n    <strong>To decrypt:</strong>\r\n  </p>\r\n  <pre>OPEN ASYMMETRIC KEY User1AsymmetricKey\t<br />USING PASSWORD = 'AGreatPassword'SELECT CustID, Name, City,\t</pre>\r\n  <pre>CONVERT(VARCHAR, DecryptByKey(CreditCardType)) AS CardType,\t</pre>\r\n  <pre>CONVERT(VARCHAR, DecryptByKey(CreditCardNumber)) AS CardNumber,\t</pre>\r\n  <pre>CONVERT(VARCHAR, DecryptByKey(Notes)) AS NotesFROM Customer </pre>\r\n  <pre>WHERE CustID = 5CLOSE ASYMMETRIC KEY User1AsymmetricKey</pre>\r\n  <p>\r\n    <strong>Using Symmetric Encryption:</strong>\r\n  </p>\r\n  <p>\r\n    <strong>To encrypt:</strong>\r\n  </p>\r\n  <pre>OPEN SYMMETRIC KEY User1SymmetricKey\t<br />USING PASSWORD = 'AGreatPassword'INSERT INTO Customer VALUES </pre>\r\n  <pre>(5, 'Sally Roe', 'Chatinika',\t</pre>\r\n  <pre>EncryptByKey(Key_GUID('User1SymmetricKey'), 'Visa'),<br />\tEncryptByKey(Key_GUID('User1SymmetricKey'), '1234-5678-9009-8765'),\t</pre>\r\n  <pre>EncryptByKey(Key_GUID('User1SymmetricKey'), 'One of our best customers. Treat like royalty.'))</pre>\r\n  <pre>CLOSE SYMMETRIC KEY <br />User1SymmetricKey</pre>\r\n  <p>\r\n    <strong>To decrypt:</strong>\r\n  </p>\r\n  <pre>OPEN SYMMETRIC KEY User1SymmetricKey\tUSING PASSWORD = 'AGreatPassword'SELECT CustID, Name, City,\t</pre>\r\n  <pre>CONVERT(VARCHAR, DecryptByKey(CreditCardType)) AS CardType,\t</pre>\r\n  <pre>CONVERT(VARCHAR, DecryptByKey(CreditCardNumber)) AS CardNumber,\t</pre>\r\n  <pre>CONVERT(VARCHAR, DecryptByKey(Notes)) AS NotesFROM Customer </pre>\r\n  <pre>WHERE CustID = 5CLOSE SYMMETRIC KEY User1SymmetricKey</pre>\r\n  <p>\r\n    <strong>Using Digital Certificates:</strong>\r\n  </p>\r\n  <p>\r\n    <strong>To encrypt:</strong>\r\n  </p>\r\n  <pre>INSERT INTO Customer VALUES (1, 'Don Kiely', 'Fairbanks',    EncryptByCert(Cert_ID('User1Certificate'),</pre>\r\n  <pre> 'Visa'),    EncryptByCert(Cert_ID('User1Certificate'), '1234-5678-8765-4321'),   </pre>\r\n  <pre> EncryptByCert(Cert_ID('User1Certificate'), 'This customer is a real flake. Don''t trust him!'))</pre>\r\n  <p>\r\n    <strong>To decrypt:</strong>\r\n  </p>\r\n  <pre>SELECT CustID, Name, City,    CONVERT(VARCHAR,         DecryptByCert(Cert_ID('User1Certificate'),            </pre>\r\n  <pre>CreditCardType)) AS CardType,    CONVERT(VARCHAR,         DecryptByCert(Cert_ID('User1Certificate'),           </pre>\r\n  <pre> CreditCardNumber)) AS CardNumber,    CONVERT(VARCHAR,        </pre>\r\n  <pre> DecryptByCert(Cert_ID('User1Certificate'),Notes)) AS NotesFROM Customer</pre>\r\n  <h1>Problem Example</h1>\r\n  <p>An e-commerce site uses the following definition for their customer table in the database: </p>\r\n  <pre>CREATE TABLE Customer (    CustId int,     name nvarchar(30),     City varchar(20),     </pre>\r\n  <pre>CreditCardType varchar(10),    CreditCardNumber varchar(19),    Notes varchar(4000))GO</pre>\r\n  <p>And this query to insert new customers:</p>\r\n  <pre>INSERT INTO Customer VALUES (1, 'Don Kiely', 'Fairbanks', 'Visa',     '1234-5678-8765-4321', </pre>\r\n  <pre>'This customer is a real flake. Don''t trust him!')</pre>\r\n  <p>When the site suffers a security breach via a SQL injection vulnerability their entire customer database, including all the credit card numbers, is lost to the attacker.</p>\r\n  <h1>Solution Example</h1>\r\n  <p>An e-commerce site has configured their database server with a database master key and created a user certificate, and uses the following definition for their customer table in the database:</p>\r\n  <pre>CREATE TABLE Customer (    CustId int,     name nvarchar(30),     City varchar(20),     </pre>\r\n  <pre>CreditCardType varbinary(300),    CreditCardNumber varbinary(300),     Notes varbinary(4000))GO</pre>\r\n  <p>And this query to insert new customers:</p>\r\n  <pre>INSERT INTO Customer VALUES (1, 'Don Kiely', 'Fairbanks',    EncryptByCert(Cert_ID('User1Certificate'), </pre>\r\n  <pre>'Visa'),    EncryptByCert(Cert_ID('User1Certificate'), '1234-5678-8765-4321'),   </pre>\r\n  <pre> EncryptByCert(Cert_ID('User1Certificate'),         'This customer is a real flake. Don''t trust him!'))</pre>\r\n  <p>When the site suffers a security breach via a SQL injection vulnerability they lose only the names and addresses of their customers to the attacker; the credit card details and notes are encrypted and unreadable to the attacker.</p>\r\n  <hr />\r\n  <p>Adapted from Microsoft patterns &amp; practices guidance.</p>"
        ]
      }
    ]
  }
}