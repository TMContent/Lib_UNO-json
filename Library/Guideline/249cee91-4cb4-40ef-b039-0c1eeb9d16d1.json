{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "841900747",
      "Content_Hash": "1520714306"
    },
    "Metadata": [
      {
        "Id": [
          "249cee91-4cb4-40ef-b039-0c1eeb9d16d1"
        ],
        "Id_History": [
          "249cee91-4cb4-40ef-b039-0c1eeb9d16d1,c3600a14-21fb-44c0-8ead-4ba944757cbe,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "0sink Where Possible, Use SecureString Rather than System.String"
        ],
        "Category": [
          "Cryptography"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          ".NET 3.5"
        ],
        "Type": [
          "Guideline"
        ],
        "DirectLink": [
          "Where Possible, Use SecureString Rather than System.String"
        ],
        "Tag": [
          ""
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<h1>What to Do</h1>\r\n  <p>Consider using the <b>System.Security.SecureString</b> type to help protect secrets in memory. <b>SecureString</b> objects use DPAPI encryption to store data in an encrypted format in memory. They are only decrypted when they are accessed.</p>\r\n  <h1>Why</h1>\r\n  <p>Although you have to decrypt the data to use it, by using <b>SecureString</b> instead of <b>System.String</b> you gain a number of benefits: </p>\r\n  <ul>\r\n    <li>You help to minimize the number of copies of the secret held in memory, which reduces the attack surface. <li>You reduce the amount of time that the secret is visible to an attacker who has access either to your process memory address space or to the page file. <li>You increase the likelihood that an encrypted version of the secret rather than a clear text version will end up in a dump file if your process crashes.</li></li></li>\r\n  </ul>\r\n  <blockquote>\r\n    <p>\r\n      <b>Note</b>&amp;nbsp;&amp;nbsp;&amp;nbsp;Unfortunately, in many scenarios you are forced to convert the <b>SecureString</b> to a <b>System.String</b> before you can use it. For example, few .NET Framework API methods currently provide overloads that support <b>SecureString</b>. Use of <b>SecureString</b> is less appropriate in ASP.NET applications. For example, It is unlikely you can take a credit card number from a Web page without the number at some point passing through a <b>System.String</b> because most of the form-related APIs do not have function overloads that permit use of <b>SecureString</b> instead of <b>System.String</b>.</p>\r\n  </blockquote>\r\n  <p>Using System.String for storing sensitive information is not recommended for the following reasons: </p>\r\n  <ul>\r\n    <li>It is not pinned, which means that the garbage collector can move it around and leave the data in memory for indeterminate amounts of time. <li>It is not encrypted; therefore, the data can be read from process memory or from the swap file. <li>It is immutable; therefore, there is no effective way of clearing the data after use. Modification leaves both the old copy and a new copy in memory. </li></li></li>\r\n  </ul>\r\n  <h1>When</h1>\r\n  <p>When working with sensitive data in memory.</p>\r\n  <h1>How</h1>\r\n  <h2>Creating a SecureString</h2>\r\n  <p>You can create a <b>SecureString</b> by supplying a pointer to a character array and supplying the length of that array. When constructed this way, the <b>SecureString</b> type takes a copy of your array. You should replace your source array with zeros as soon as the <b>SecureString</b> is constructed. A <b>SecureString</b> can also be constructed without an existing character array, and data can be copied one character at a time. The following code sample shows how to use the <b>AppendChar</b> method to create a secure string one character at a time.</p>\r\n  <pre>using System.Security;<br />...<br />SecureString securePassword = new SecureString(); <br />Console.WriteLine(\"Enter Password....\"); <br />while (true) <br />&amp;#123;<br />&amp;nbsp; ConsoleKeyInfo conKeyInfo = Console.ReadKey(true);<br />&amp;nbsp; if (conKeyInfo.Key == ConsoleKey.Enter)<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; break;<br />&amp;nbsp; else if (conKeyInfo.Key == ConsoleKey.Escape)<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return;<br />&amp;nbsp; else if (conKeyInfo.Key == ConsoleKey.Backspace)<br />&amp;nbsp; &amp;#123;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if (securePassword.Length &amp;#33;= 0)<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; securePassword.RemoveAt(securePassword.Length - 1);<br />&amp;nbsp; &amp;#125;<br />&amp;nbsp; else<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; securePassword.AppendChar(conKeyInfo.KeyChar);<br />&amp;#125;<br />Console.WriteLine(securePassword.Length.ToString());  </pre>\r\n  <h2>Retrieving Data from a SecureString</h2>\r\n  <p>You retrieve data from a <b>SecureString</b> by using the marshaller. The <b>Marshal</b> class has been extended to provide methods that convert a <b>SecureString</b> into a <b>BSTR</b> data type or a raw block of ANSI or Unicode memory. When you have finished using the unprotected string, you should erase that copy by calling <b>Marshal.ZeroFreeBSTR</b>, as shown in the following example.<b></b></p>\r\n  <pre>using System.Security;<br />using System.Runtime.InteropServices;<br />...<br />void UseSecretData(SecureString secret)<br />&amp;#123;<br />&amp;nbsp; IntPtr bstr = Marshal.SecureStringToBSTR(secret);<br />&amp;nbsp; try<br />&amp;nbsp; &amp;#123;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; // Use the bstr here<br />&amp;nbsp; &amp;#125;<br />&amp;nbsp; finally<br />&amp;nbsp; &amp;#123;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; // Make sure that the clear text data is zeroed out<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; Marshal.ZeroFreeBSTR(bstr);<br />&amp;nbsp; &amp;#125;<br />&amp;#125;</pre>\r\n  <h1>Additional Resources</h1>\r\n  <ul>\r\n    <li>For more information see \"Making Strings more Secure\" at <a href=\"http://blogs.msdn.com/shawnfa/archive/2004/05/27/143254.aspx\">http://blogs.msdn.com/shawnfa/archive/2004/05/27/143254.aspx</a></li>\r\n  </ul>\r\n  <hr />\r\n  <p>Adapted from Microsoft patterns &amp; practices guidance.</p>"
        ]
      }
    ]
  }
}