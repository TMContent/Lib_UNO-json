{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "1655538220",
      "Content_Hash": "-838520876"
    },
    "Metadata": [
      {
        "Id": [
          "9f0fc6bb-7dd0-4e1a-bbeb-d73ab3c25ebf"
        ],
        "Id_History": [
          "9f0fc6bb-7dd0-4e1a-bbeb-d73ab3c25ebf,10ad48f3-f88f-4934-96c0-a3fdf0db4462,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          ".NET Validate All Input Passed to the Database"
        ],
        "Category": [
          "Input and Data Validation"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          ".NET"
        ],
        "Type": [
          "Code Example"
        ],
        "DirectLink": [
          "Validate All Input Passed to the Database"
        ],
        "Tag": [
          "ASP.NET,ASP.NET 4.0,ASP"
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "markdown"
        },
        "Data": [
          "## Applies To ##\r\n\r\n* ASP.NET 4.0+\r\n\r\n\r\n## Problem Example ##\r\n\r\nThe following code validates the user based on a given username and password. It hashes the password with a random salt. Then it compares the username and the produced hash against the data stored in the backend database. Unfortunately, the SQL query is dynamically crafted by using the user's input. If there is no proper input validation, an attacker can access the application's database server through the use of SQL injection.\r\n\r\n~~~~\r\npublic boolean validateUser(String user, char[] pass)\r\n{\r\n      byte[] salt = MyApp.generateSalt();\r\n      String passHash;\r\n      SqlConnection cn;\r\n      SqlCommand sqlCommand;\r\n      String query;\r\n      passHash = hashCredentials(pass, salt);\r\n\r\n      // The application crafts the SQL query based on user's input\r\n      cn = MyApp.getDBConnection();\r\n      sqlCommand = new SqlCommand(\"select user from myappUsers where user = '\"+\r\n      user + \"' + and pass = '\" + passHash + \"' and login_attempts < 3;\", cn);\r\n      SqlDataReader reader = sqlCommand.ExecuteReader();\r\n      updateLastLoginAttempt(user);\r\n      ...\r\n}\r\n~~~~\r\n\r\nIf a user submits a login request with a username of\r\n\r\n~~~~\r\nfoo' or 1 = 1; drop table *; --\r\n~~~~\r\n\r\nthe system will happily first authenticate the user and then drop all the tables in the database.\r\n\r\n\r\n## Solution Example ##\r\n\r\nThe following code validates the user based on a given username and password. It hashes the password with a random salt. Then it compares the username and the produced hash against the data stored in the backend database. Because the application uses the Parameters property, it is much more difficult for an attacker to gain access to the application's database server through the use of SQL injection.\r\n\r\n~~~~\r\npublic boolean validateUser(String user, char[] pass)\r\n{\r\n   byte[] salt = MyApp.generateSalt();\r\n   String passHash; \r\n   SqlConnection cn;\r\n   SqlCommand sqlCommand;\r\n   String query;     \r\n   passHash = hashCredentials(pass, salt);\r\n   // The application crafts the SQL query based on user's input\r\n   cn = MyApp.getDBConnection();\r\n   sqlCommand = new SqlCommand(\"select user from myappUsers where user = @user and \r\n                    + pass = @passHash and login_attempts < 3;\", cn);\r\n   sqlCommand.Parameters.Add(\"@user\", SqlDbType.VarChar, user.Length).Value = user;\r\n   sqlCommand.Parameters.Add(\"@passHash \", SqlDbType.VarChar, passHash.Length).Value = passHash;\r\n   SqlDataReader reader = sqlCommand.ExecuteReader(); \r\n   updateLastLoginAttempt(user);  \r\n   ...\r\n}\r\n~~~~\r\n\r\nEven if the user passes in an arbitrary string for a username or a password, they will not be able to alter the query or otherwise effect the database. An even better solution would involve using a stored procedure instead of a parameterized command, because that would permit the database to be locked down further.\r\n\r\n---\r\nAdapted from Microsoft patterns & practices guidance."
        ]
      }
    ]
  }
}