{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "-1772207906",
      "Content_Hash": "1658104360"
    },
    "Metadata": [
      {
        "Id": [
          "eae5728a-438e-4653-9376-47cc46306fd7"
        ],
        "Id_History": [
          "eae5728a-438e-4653-9376-47cc46306fd7,c2189ac9-ac27-4b3b-b5b3-28f30cb8a7c3,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "[SINK] If You Accept File Names, Validate Them"
        ],
        "Category": [
          "File I/O"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          ".NET 3.5"
        ],
        "Type": [
          "Guideline"
        ],
        "DirectLink": [
          "If You Accept File Names, Validate Them"
        ],
        "Tag": [
          ""
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<h1>What to Do</h1>\r\n  <p>If you do need to receive input file names from the caller, make sure that the file names are strictly formed so that you can determine whether they are valid.</p>\r\n  <h1>Why</h1>\r\n  <p>Accepting file names or paths from users can result in attackers coercing your application into accessing arbitrary files and resources.</p>\r\n  <h1>When</h1>\r\n  <p>You should always validate file name, if you need to accept one from user.</p>\r\n  <h1>How</h1>\r\n  <p>There are two aspects to validating input file paths. You need to: </p>\r\n  <ul>\r\n    <li>Check for valid file system names. <li>Check for a valid location as defined by your application's context. For example, are the file names within the directory hierarchy of your application?</li></li>\r\n  </ul>\r\n  <p>To validate a path and file name, use the <b>System.IO.Path.GetFullPath</b> method as shown in the following code example. This method also canonicalizes the supplied file name.</p>\r\n  <pre>using System.IO;<br />public static string ReadFile(string filename)<br />&amp;#123;<br />&amp;nbsp; // Obtain a canonicalized and valid filename<br />&amp;nbsp; string name = Path.GetFullPath(filename);<br />&amp;nbsp; // Now read the file and return the file content.<br />&amp;#125;  </pre>\r\n  <p>As part of the canonicalization process, <b>GetFullPath</b> performs the following checks: </p>\r\n  <ul>\r\n    <li>It checks that the file name does not contain any invalid characters, as defined by <b>Path.InvalidPathChars</b>. <li>It checks that the file name represents a file and not another device type, such as a physical drive, a named pipe, a mail slot, or a DOS device such as LPT1, COM1, AUX, and other devices. <li>It checks that the combined path and file name is not too long. <li>It removes redundant characters such as trailing dots. <li>It rejects file names that use the //?/ format.</li></li></li></li></li>\r\n  </ul>\r\n  <hr />\r\n  <p>Adapted from Microsoft patterns &amp; practices guidance.</p>"
        ]
      }
    ]
  }
}