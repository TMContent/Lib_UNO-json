{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "-2067316452",
      "Content_Hash": "1933175556"
    },
    "Metadata": [
      {
        "Id": [
          "8e0aea9c-322b-4b3f-9c61-a670c1fcd3e3"
        ],
        "Id_History": [
          "8e0aea9c-322b-4b3f-9c61-a670c1fcd3e3,8376e392-34ba-4214-a94c-5c512526063d,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "Use Page.ViewStateUserKey to Counter Cross Site Request Forgery Attacks"
        ],
        "Category": [
          "Session Management"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          ".NET 3.5"
        ],
        "Type": [
          "Guideline"
        ],
        "DirectLink": [
          "Use Page.ViewStateUserKey to Counter Cross Site Request Forgery Attacks"
        ],
        "Tag": [
          ""
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          "2"
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<h1>What to Do</h1>\r\n  <p>Set the value of Page.ViewStateUserKey to a unique value for each user.</p>\r\n  <h1>Why</h1>\r\n  <p>\r\n    <strong>ViewState </strong>is the mechanism used by ASP.NET to keep track of server control state values that don't otherwise post back as part of the HTTP form. It's a hidden form field managed by the ASP.NET page framework and is an encoded aggregate of values of controls on a page. View state is enabled by default in ASP.NET and it can be disabled or re-enabled at the machine, application, page and control level by setting the <strong>EnableViewState</strong> property to 'false' or 'true' in config files.</p>\r\n  <p>By default, there's nothing in the view state that ties its content to a particular user. The attacker can easily reuse the view state he/she obtained making legal access to the page to build a bogus request on behalf of another user. This is where a <strong>ViewStateUserKey</strong> is useful.</p>\r\n  <p>The <strong>ViewStateUserKey</strong> property adds user-specific information to the view state. Setting the <strong>ViewStateUserKey</strong> property of the page in the <strong>Page_Init</strong> event handler helps prevent Cross Site Request Forgery attacks by ensuring that any form information submitted came from the same user who requested the original page. It binds the content of the <strong>ViewState</strong> variable to individual users so that the malicious users cannot use the variable to generate an attack.</p>\r\n  <p>This prevents Cross Site Request Forgery attacks, where attackers attempt to use their <strong>ViewState</strong> in the context of another user, or to otherwise post form data as though they were another user. These attacks are also called one-click attacks.</p>\r\n  <h1>When</h1>\r\n  <p>The <strong>ViewStateUserKey </strong>property should be used when a web application accepts input that alters the state of the application from authenticated or trusted users without requiring the users to authorize the specific action. The actions that alter the state of the application could include, but are not limited to, modifying the contents of a database, modifying the state of user accounts, submitting data to other systems, etc. Such web applications are more at risk than those that just provide information, and hence, need to use <strong>ViewStateUserKey</strong> to ensure that the user is not allowed to modify state maliciously.</p>\r\n  <h1>How</h1>\r\n  <p>Set the <strong>ViewStateUserKey</strong> property to a value that you know is unique for each user, such as username, user ID, or a session ID as shown below:</p>\r\n  <pre>void Page_Init (object sender, EventArgs e){   ViewStateUserKey = Session.SessionID;}</pre>\r\n  <p>Session ID is a much better fit because a session ID is unpredictable, times out, and varies on a per-user basis.</p>\r\n  <h1>Problem Example</h1>\r\n  <p>A web application does not set the <strong>ViewStateUserKey</strong> property in the Page_Init event handler. If this application allows a user to change the state of the application in a single request, it is susceptible to a Cross Site Request Forgery Attack. </p>\r\n  <p>For example, consider a web application that allows a logged in administrator to create a new user sending a single GET request.</p>\r\n  <p>This GET request looks like this:</p>\r\n  <pre>GET http://teammentorexample.com/adduser.aspx?username=joe&password=1234&usertype=user HTTP/1.1</pre>\r\n  <p>The attacker discovers that this request will create a new user and creates his own request which he embeds an e-mail with the following image tag:</p>\r\n  <pre>&lt;img src=” http://teammentorexample.com/adduser.aspx?username=HACKER&password=TEST&usertype=admin” /&gt;</pre>\r\n  <p>When the victim’s (the administrator in this case) e-mail client attempts to download the image located at the above source the request is made without the knowledge of the victim. </p>\r\n  <p>The Web page contains a hidden form field named __VIEWSTATE that is already filled with ViewState data. The ViewState can be re-used from a valid request that the attacker had previously made to the application. The ViewState content is not checked on the server or is only checked against tampering.The attacker lures the unsuspecting user into opening the email containing the malicious URL, causing the request to be sent to the server where the ViewState is valid. The server has no way of knowing that the ViewState originated from the attacker. ViewState validation does not counter this attack because the ViewState is valid and the page is executed under the security context of the victim user.</p>\r\n  <h1>Solution Example</h1>\r\n  <p>A web application correctly sets the ViewStateUserKey property in the Page_Init event handler as follows:</p>\r\n  <pre>void Page_Init (object sender, EventArgs e){   ViewStateUserKey = m_username;}</pre>\r\n  <p>Now, when an attacker creates a Web page that contains a hidden form field named __VIEWSTATE that is already filled with ViewState data and lures an unsuspecting user into browsing to the page, the server knows that the ViewState does not belong to the victim, but that it originated from the attacker, and the attack is not successful. </p>\r\n  <p>For example, when the attacker sends an email containing the image tag</p>\r\n  <pre>&lt;img src=”http://teammentorexample.com/adduser.aspx?username=HACKER&password=TEST&usertype=admin” /&gt;</pre>\r\n  <p>to the victim (the administrator), and the \"add user\" request is made without the knowledge of the victim, the server denies the request because it detects that the request does not belong to the logged-in user it seems to be coming from.</p>\r\n  <br />\r\n  <hr />\r\n  <p>Adapted from Microsoft patterns & practices guidance. </p>"
        ]
      }
    ]
  }
}