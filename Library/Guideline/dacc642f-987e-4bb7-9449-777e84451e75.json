{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "-1236755268",
      "Content_Hash": "-1263410008"
    },
    "Metadata": [
      {
        "Id": [
          "dacc642f-987e-4bb7-9449-777e84451e75"
        ],
        "Id_History": [
          "dacc642f-987e-4bb7-9449-777e84451e75,79353ef6-ec6d-4570-97a8-f7ccb0a0ff8d,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "[RECYCLEME] Avoid User-supplied File Name And Path Input"
        ],
        "Category": [
          "Canonicalization"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          "WCF"
        ],
        "Type": [
          "Guideline"
        ],
        "DirectLink": [
          "Avoid User-supplied File Name And Path Input"
        ],
        "Tag": [
          "WCF 3.5"
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          "J.D. Meier, Jason Taylor, Prashant Bansode, Carlos Farre, Madhu Sundararajan, Rob Boucher, Steve Gregersen"
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<h1>Applies to</h1>\r\n  <ul>\r\n    <li>Microsoft® Windows Communication Foundation (WCF) 3.5 \r\n<li>Microsoft Visual Studio® 2008</li></li>\r\n  </ul>\r\n  <h1>What to Do</h1>\r\n  <p>Ensure that your code avoids accepting user-supplied file name or path input.</p>\r\n  <h1>Why</h1>\r\n  <p>This prevents the attackers from coercing your application into accessing arbitrary files and resources. </p>\r\n  <h1>When</h1>\r\n  <p>When you are validating client input messages.</p>\r\n  <h1>How</h1>\r\n  <p>Where possible, avoid writing code that accepts user-supplied file or path input. Failure to do this can result in attackers coercing your application into accessing arbitrary files and resources. If your application must accept input file names, file paths, or URL paths, validate that the path is in the correct format and that it points to a valid location within the context of your application.</p>\r\n  <p>\r\n    <strong>File Names</strong>\r\n    <br />Ensure that file paths only refer to files within your application's virtual directory hierarchy if that is appropriate. When checking file names, obtain the full name of the file by using the System.IO.Path.GetFullPath method. </p>\r\n  <p>\r\n    <strong>File Paths</strong>\r\n    <br />If you use MapPath to map a supplied virtual path to a physical path on the server, use the overloaded Request.MapPath method that accepts a bool parameter so that you can prevent cross-application mapping. The following code example shows this technique.</p>\r\n  <pre>try<br />{ <br /> string mappedPath = Request.MapPath( inputPath.Text, Request.ApplicationPath, false);<br />}<br />catch (HttpException)<br />{<br /> // Cross-application mapping attempted <br />}</pre>\r\n  <p>\r\n    <strong>Note</strong>: The final false parameter in Request.MapPath() prevents cross-application mapping. This means that a user cannot successfully supply a path that contains \"..\" to traverse outside of your application's virtual directory hierarchy.</p>\r\n  <hr />\r\n  <p>Adapted from Microsoft patterns &amp; practices guidance.</p>"
        ]
      }
    ]
  }
}