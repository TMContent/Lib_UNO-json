{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "1271215465",
      "Content_Hash": "179999145"
    },
    "Metadata": [
      {
        "Id": [
          "df09332b-a43b-4b5f-98b2-8e9979f40daf"
        ],
        "Id_History": [
          "df09332b-a43b-4b5f-98b2-8e9979f40daf,d4cfc58c-9379-4b0d-abc5-ce3720d9df83,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "[SINK] Identify Mechanisms to Protect Sensitive Data"
        ],
        "Category": [
          "Cryptography"
        ],
        "Phase": [
          "Design"
        ],
        "Technology": [
          ".NET 3.5"
        ],
        "Type": [
          "Guideline"
        ],
        "DirectLink": [
          "Identify Mechanisms to Protect Sensitive Data"
        ],
        "Tag": [
          "ASP.NET,ASP.NET 3.5,ASP"
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          "2"
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<h1>What to Do</h1>\r\n  <p>Identify mechanisms to protect sensitive information over networks and in persistent stores.&nbsp; Your first layer of protection for sensitive data is controlling where it goes; avoid pushing sensitive data to the client whenever possible, instead keeping it in a server-side session, or, idealy, directly in the database. </p>\r\n  <h1>When</h1>\r\n  <p>All applications which handle sensitive information should determine how it will be protected.&nbsp; All applications which authenticate users have at least authentication data to protect, even if they handle no other sensitive information. </p>\r\n  <h1>How</h1>\r\n  <p>To help protect sensitive data: </p>\r\n  <h3>Use Protected Configuration to Protect Sensitive Data in Configuration Files</h3>\r\n  <p>Use .NET protected configuration to protect sensitive data in configuration files. For ASP.NET Web.config files, you<br />can use the Aspnet_regiis tool to encrypt specific sections. The sections of a Web.config file that usually contain sensitive information that you need to encrypt are the following: </p>\r\n  <ul>\r\n    <li>&lt;<b>appSettings</b>&gt;. This section contains custom application settings. <li>&lt;<b>connectionStrings</b>&gt;. This section contains connection strings. <li>&lt;<b>identity</b>&gt;. This section can contain impersonation credentials. <li>&lt;<b>sessionState</b>&gt;. The section contains the connection string for the out-of-process session state provider. </li></li></li></li>\r\n  </ul>\r\n  <p>Protected configuration supports DPAPI and RSA encryption. To use the DPAPI provider with the machine key store (the default configuration) to encrypt the <b>connectionStrings</b> section, run the following command from a command prompt:</p>\r\n  <p>\r\n    <b>aspnet_regiis -pe \"connectionStrings\" -app \"/MachineDPAPI\" </b>\r\n  </p>\r\n  <p>\r\n    <b>-prov \"DataProtectionConfigurationProvider\"</b>\r\n  </p>\r\n  <p>where </p>\r\n  <ul>\r\n    <li>\r\n      <b>-pe</b> specifies the configuration section to encrypt. <li>-<b>app </b>specifies your Web application's virtual path. If your application is nested, you need to specify the nested path from the root directory, for example \"/test/aspnet/MachineDPAPI\" <li><b>-prov</b> specifies the provider name. </li></li></li>\r\n  </ul>\r\n  <h3>Minimize the Exposure of Secrets in Memory</h3>\r\n  <p>When manipulating secrets, consider how the secret data is stored in memory. How long is the secret data retained in clear text format? Clear text secrets held in your process address space are vulnerable if an attacker is able to probe your application's address space. Also, if the page of memory containing the secret is swapped out to the page file, the secret data is vulnerable if someone gains access to the page file. Similarly, clear text secrets held in memory appear in the crash dump file if a process crashes. To minimize the exposure of secrets in memory, consider the following measures: </p>\r\n  <ul>\r\n    <li>\r\n      <b>Avoid creating multiple copies of the secret</b>. Having multiple copies of the secret data increases your attack surface. Pass references to secret data instead of making copies of the data. Also realize that if you store secrets in immutable <b>System.String</b> objects, after each string manipulation, a new copy is created. <li><b>Keep the secret encrypted for as long as possible</b>. Decrypt the data at the last possible moment before you need to use the secret. <li><b>Clean the clear text version of the secret as soon as you can</b>. Replace the clear text copy of the secret data with zeros as soon as you have finished with it. </li></li></li>\r\n  </ul>\r\n  <h3>Where Possible, Use SecureString Rather than System.String</h3>\r\n  <p>Consider using the <b>System.Security.SecureString</b> type to help protect secrets in memory. <b>SecureString</b> objects use DPAPI encryption to store data in an encrypted format in memory. They are only decrypted when they are accessed. Although you have to decrypt the data to use it, by using <b>SecureString</b> instead of <b>System.String</b> you gain a number of benefits: </p>\r\n  <ul>\r\n    <li>You help to minimize the number of copies of the secret held in memory, which reduces the attack surface. <li>You reduce the amount of time that the secret is visible to an attacker who has access either to your process memory address space or to the page file. <li>You increase the likelihood that an encrypted version of the secret rather than a clear text version will end up in a dump file if your process crashes. </li></li></li>\r\n  </ul>\r\n  <blockquote>\r\n    <b>Note</b>&nbsp;&nbsp;&nbsp;Unfortunately, in many scenarios you are forced to convert the <b>SecureString</b> to a <b>System.String</b> before you can use it. For example, few .NET Framework API methods currently provide overloads that support <b>SecureString</b>. Use of <b>SecureString</b> is less appropriate in ASP.NET applications. For example, It is unlikely you can take a credit card number from a Web page without the number at some point passing through a <b>System.String</b> because most of the form-related APIs do not have function overloads that permit use of <b>SecureString</b> instead of <b>System.String</b>.</blockquote>\r\n  <p />\r\n  <hr />\r\n  <p>Adapted from Microsoft patterns & practices guidance. </p>"
        ]
      }
    ]
  }
}