{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "-115863020",
      "Content_Hash": "-951618371"
    },
    "Metadata": [
      {
        "Id": [
          "d7682043-0095-4700-97dd-01ce797c4ada"
        ],
        "Id_History": [
          "d7682043-0095-4700-97dd-01ce797c4ada,145cfb84-3da3-410c-b3b2-0bc4ec145f17,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "How to Test for Deserialization of Untrusted Data Bugs in Java"
        ],
        "Category": [
          "Testing"
        ],
        "Phase": [
          "Test"
        ],
        "Technology": [
          "Java"
        ],
        "Type": [
          "How To"
        ],
        "DirectLink": [
          "How to Test for Deserialization of Untrusted Data Bugs in Java"
        ],
        "Tag": [
          ""
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<h1>\n     Applies to \n  </h1>\n  <ul>\n    <li>J2EE applications</li>\n  </ul>\n  <h1>\n     Summary \n  </h1>\n  <p>J2EE applications that use serialization/deserialization of data might be vulnerable to deserialization of untrusted data bugs.   To exploit this bug, an attacker tampers with the data that will be deserialized by the application so that the application deserializes a malicious data stream.    An attacker can use malicious serialization data in order to inject client-side scripts, perform denial-of-service (DoS) attacks, or execute logical attacks on the target application.</p>\n  <p>Follow these steps to test for deserialization of untrusted data bugs in J2EE:</p>\n  <ul>\n    <li>Step 1: Understand attack scenarios </li>\n    <li>Step 2: Analyze causes and countermeasures </li>\n    <li>Step 3: Execute test cases</li>\n  </ul>\n  <h1>\n     Step 1: Understand Attack Scenarios \n  </h1>\n  <p>The first step in learning how to test for deserialization bugs in J2EE is to understand the anatomy of the attack scenarios.   Attack scenarios include but are not limited to:</p>\n  <ul>\n    <li>Client-side script injection </li>\n    <li>Denial-of-service attacks </li>\n    <li>Logical attacks<br /></li>\n  </ul>\n  <p>During a deserialization of untrusted data attack, an attacker tampers with serialized data or submits malicious serialized data so that the application behaves unexpectedly when it starts to deserialize it.    </p>\n  <p>In detail:</p>\n  <ol>\n    <li>The attacker determines where an application’s functionality inputs serialized data dynamically or from a permanent store. </li>\n    <li>If the application dynamically inputs serialized data, the attacker inputs malicious serialized data.<br />If the application inputs serialized data from a permanent store such as a file or database, the attacker tampers with this store and writes the malicious serialized data. </li>\n    <li>The attacker waits for the application to react upon deserializing the malicious data. </li>\n  </ol>\n  <h2>\n    <em>Scenario 1: Client-side script injection</em>\n  </h2>\n  <p>Data deserialization, the opposite of data serialization, is used by J2EE applications that extract a sequence of bytes into an object.   For instance, a J2EE application uses the <i>Person</i> class defined as follows:</p>\n  <pre>package com.example.servlet;<br />import java.io.Serializable;<br />import java.io.ObjectInputStream;<br /><br />public class Person implements <strong>Serializable<br /></strong>{    <br />    private String firstName;<br />    private String lastName;<br />    private int age;<br /><br />    public Person()<br />    {<br />    }<br /><br />    public String getFirstName()<br />    {<br />        return firstName;<br />    }<br /><br />    public void setFirstName(String firstName)<br />    {<br />        this.firstName = firstName;<br />    }<br /><br />    public String getLastName()<br />    {<br />        return lastName;<br />    }<br /><br />    public void setLastName(String lastName)<br />    {<br />        this.lastName = lastName;<br />    }<br /><br />    public int getAge()<br />    {<br />        return age;<br />    }<br /><br />    public void setAge(int age)<br />    {<br />        this.age = age;<br />    }   <br /> } \n  </pre>\n  <p>In a separate class, the application has code that creates a sample output file named <i>out.obj</i> using two elements of the <i>Person</i> class<i>:</i></p>\n  <pre>String filename = \"c:\\\\tests\\\\out.obj\";<br />outputStream = new ObjectOutputStream(new FileOutputStream(filename));<br /><br />Person person = new Person();<br />person.setFirstName(\"John\");<br />person.setLastName(\"Smith\");<br />person.setAge(19);<br /><br />outputStream.writeObject(person);<br /><br />person = new Person();<br />person.setFirstName(\"Paul\");<br />person.setLastName(\"Rocks\");<br />person.setAge(39);<br /><br />outputStream.writeObject(person);<br />outputStream.close();</pre>\n  <p>A separate application’s functionality reads the serialized data from the file and prints the last name value of the first element in the file:</p>\n  <pre>String filename  = \"c:\\\\tests\\\\out.obj\";<br />ObjectInputStream in = new ObjectInputStream(new FileInputStream(filename));<br />Person person2 = (Person)in.readObject();<br />out.write(person2.getLastName()); </pre>\n  <p>If the file remains unchanged, as when originally written by the application, the output is the following:    <i>Smith.</i>   The object file <i>out.obj </i>looks like Figure 1 under a hex editor.  Note that the highlighted data of the object file is the last name <i>Smith</i> preceded by the length of the last name (5).    </p>\n  <p />\n   However, an attacker might tamper with the serialized data in order to inject a malicious client-side script.  \n   \n     \n       This results in the browser displaying an alert box that confirms that the client-side script has been injected.  An attacker who is able to modify the untrusted data source used might be able to inject a client-side script that is displayed to all clients.   This attack scenario is similar to stored Cross-Site Scripting (XSS) where the attacker injects a client-side script in a data source.<p /><p /><h2><em>Scenario 2: Denial-of-service attack</em></h2><p>An attacker might also attempt a denial-of-service attack on the application by trying to crash the J2EE application or put it into a state that prevents the application from properly servicing its users.   For example, a J2EE application might use JSON (JavaScript Object Notation) to transmit serialized data.</p><p>Here the attacker can tamper with opening and closing characters of the JSON notation:</p><pre>{\"Addresses\": <br />[{\"City\":\"Seatle\",\"State\":\"WA\",\"Street\":\"123 Wall St.\",\"Zip\":\"98101\"}, <br />{\"City\":\"Boston\",\"State\":\"MA\",\"Street\":\"33 St. Paul St\",\"Zip\":\"02109\"}], <br />\"Entered\":\"\\/Date(1191992400000-0500)\\/\",<br />\"Name<strong>\":\"}]}})} </strong></pre><p>The attacker is trying to cause a parsing error in the application that will cause an unhandled exception that might eventually cause the application thread to terminate.</p><p>Additionally, an attacker can attempt to exploit recursive elements by adding an excessive number of recursion levels or try to exploit array elements by adding an excessive number of array elements.   For example, if the application uses an <i>Addresses</i> array, an attacker might add numerous array elements to the <i>Addresses</i> array:  </p><pre>{\"Addresses\": <br /><strong>[{\"City\":\"a\",\"State\":\"b\",\"Street\":\"c\",\"Zip\":\"d\"}{\"City\":\"a\",\"State\":\"b\",\"Street\":\"c\",\"Zip\":\"d\"}<br />{\"City\":\"a\",\"State\":\"b\",\"Street\":\"c\",\"Zip\":\"d\"}{\"City\":\"a\",\"State\":\"b\",\"Street\":\"c\",\"Zip\":\"d\"}<br />{\"City\":\"a\",\"State\":\"b\",\"Street\":\"c\",\"Zip\":\"d\"}{\"City\":\"a\",\"State\":\"b\",\"Street\":\"c\",\"Zip\":\"d\"}<br />{\"City\":\"a\",\"State\":\"b\",\"Street\":\"c\",\"Zip\":\"d\"}{\"City\":\"a\",\"State\":\"b\",\"Street\":\"c\",\"Zip\":\"d\"}<br />{\"City\":\"a\",\"State\":\"b\",\"Street\":\"c\",\"Zip\":\"d\"}{\"City\":\"a\",\"State\":\"b\",\"Street\":\"c\",\"Zip\":\"d\"}<br />{\"City\":\"a\",\"State\":\"b\",\"Street\":\"c\",\"Zip\":\"d\"}{\"City\":\"a\",\"State\":\"b\",\"Street\":\"c\",\"Zip\":\"d\"}<br />{\"City\":\"a\",\"State\":\"b\",\"Street\":\"c\",\"Zip\":\"d\"}{\"City\":\"a\",\"State\":\"b\",\"Street\":\"c\",\"Zip\":\"d\"}<br />{\"City\":\"a\",\"State\":\"b\",\"Street\":\"c\",\"Zip\":\"d\"}{\"City\":\"a\",\"State\":\"b\",\"Street\":\"c\",\"Zip\":\"d\"}<br />{\"City\":\"a\",\"State\":\"b\",\"Street\":\"c\",\"Zip\":\"d\"}{\"City\":\"a\",\"State\":\"b\",\"Street\":\"c\",\"Zip\":\"d\"}<br />{\"City\":\"a\",\"State\":\"b\",\"Street\":\"c\",\"Zip\":\"d\"}{\"City\":\"a\",\"State\":\"b\",\"Street\":\"c\",\"Zip\":\"d\"}</strong><br />{\"City\":\"a\",\"State\":\"b\",\"Street\":\"c\",\"Zip\":\"d\"}<br />{\"City\":\"Seatle\",\"State\":\"WA\",\"Street\":\"123 Wall St.\",\"Zip\":\"98101\"}, <br />{\"City\":\"Boston\",\"State\":\"MA\",\"Street\":\"33 St. Paul St\",\"Zip\":\"02109\"}],<br />\"Entered\":\"\\/Date(1191992400000-0500)\\/\",<br />\"Name\":\"John Smith\"}  </pre><p /><p /><h2><em>Scenario 3: Logical attacks</em></h2><p>The last scenario is logical attacks on the application where the data modified by the attacker causes the application to behave differently by following an unexpected execution path or executing additional attacker-provided code.     </p><p>For example, an application deserializes the <i>Lottery</i> class below.   The class makes sure that when a new lottery is created in the constructor, the <i>ticket</i> is always below 20,000.   However, the application fails to perform input validation after deserialization, so  a n attacker can tamper with the deserialized data and force a larger number for the ticket variable in order to create a different logical flow or a potential integer overflow [i]: </p><pre>import java.io.Serializable;<br />import java.io.ObjectInputStream;<br />import java.io.IOException;<br />import java.util.Random;<br /><br />public class Lottery implements <strong>Serializable</strong><br />{<br /><br />  private int ticket = 1;<br />  Random draw = new Random();<br /><br />  public Lottery(int ticket)<br />  {<br />    this.ticket = (int) (Math.abs(ticket % 20000) + 1);<br />  }<br /><br />  public int getTicket()<br />  {<br />    return this.ticket;        <br />  }<br /><br />  public int roll()<br />  {<br />    this.ticket = (int) ((Math.abs(draw.nextInt()) % 20000) + 1);<br />    return this.ticket;<br />  }<br /><br />  private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException<br />  {<br />    in.defaultReadObject();<br />  }<br />}</pre><p>The application is vulnerable because any calls to <i>readObject()</i>   to read from the <em>Lottery</em> object after deserialization will not go through the constructor and the ticket value will not be validated against a maximum allowed integer value of 20,000 after deserialization.</p><h1> Step 2: Analyze Causes and Countermeasures </h1><p>Next it is necessary to analyze what causes and how to protect against deserialization of untrusted data attacks.</p><h2><em>Accepting untrusted serialized data</em></h2><p>This attack is possible when an application accepts untrusted data as input to a deserialization routine without validating the integrity of the untrusted data.  As a result, the attacker is able to submit malicious data for the application to deserialize.  A possible mitigation consists adding a cryptographic checksum to serialized messages to detect tampering of serialized data.</p><h2><em>Using a secure channel</em></h2><p>A similar option to implementing a cryptographic framework for serialized data is to send all serialized data using a secure channel.   Developers can choose different secure channel implementations such as SSL/TLS and IPSec.</p><h2><em>Perform input validation in the readObject() method</em></h2><p>Applications written in Java can protect against deserialization of untrusted data attacks by overriding the <i>readObject()</i> method in the target class and doing the necessary input validation in the <i>readObject()</i> override.  For example, in order to deactivate deserialization of the <i>Person</i> object, the J2EE application can add the following code to <em>Person.java</em>:</p><pre>private final void readObject(ObjectInputStream in)<br />                         throws java.io.IOException <br />{<br />     throw new java.io.IOException(\"Cannot be deserialized\");<br />}</pre><p>However, deserialization might be needed so it would be better to validate the object here.  For example, in the final scenario of the previous section, the application might have added the check for an incorrect ticket value in the <i>readObject()</i> overload:    </p><pre>private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException<br />{<br />     in.defaultReadObject();<br />     this.ticket = (int) (Math.abs(this.ticket % 20000) + 1);  //perform input validation<br />}</pre><h1> Step 3: Execute Test Cases </h1><p> Now that you’ve reviewed the theoretical aspects of deserialization of untrusted data bugs, it is necessary to execute the following test cases to check if your application is vulnerable. </p><h2><em>Test for deserialization of untrusted data dynamically</em></h2><p> Follow these steps: </p><ol><li> Discover an application’s functionality that dynamically takes untrusted serialized data (from the URL, Web form, or other client-accessible input point) and deserializes the data. </li><li> Modify the input data to add malicious data (such as an injected script) and feed the data to the application. </li><li> Wait till the application deserializes the data. </li></ol><p> Expected results:   The application is vulnerable if it allows for malicious modification of the serialized data.   That is, if modification results in an insecure condition such as script injection, denial-of-service, or a logical attack on the application. </p><p><b><i></i></b></p><h2><em>Test for deserialization of untrusted data through a data store</em></h2><p> Follow these steps: </p><ol><li> Discover an application’s functionality that takes untrusted serialized data from a physical store (from a file, database, or other client-accessible data store) and deserializes the data. </li><li> Modify the data store to add malicious data (such as an injected script) and feed the data to the application. </li><li> Wait till the application deserializes the data. </li></ol><p> Expected results:   The application is vulnerable if it allows for malicious modification of the serialized data.  That is, if modification results in an insecure condition such as script injection, denial-of-service, or a logical attack on the application. </p><p /><h1> Conclusions </h1><p>Deserialization of untrusted data is a security concern as it allows attackers to execute different attacks on the application such as injecting a client-side script, denying the service of the application, and logically exploiting the application’s behavior for the attacker’s benefit.  To test for this vulnerability in J2EE applications, it is suggested to start by understanding the different attack scenarios.   Continue by reviewing what causes this vulnerability and how to protect against it.   Finally, execute different test cases based on the input point that the application uses to gather the serialized data.</p><p /><div><div><p>    [i]    <b>SER04-J. Validate deserialized objects</b>. Added by Dhruv Mohindra, last edited by Dean Sutherland on Oct 22, 2010.    CERT. <a href=\"http://www.securecoding.cert.org/confluence/display/java/SER04-J.+Validate+deserialized+objects\">http://www.securecoding.cert.org/confluence/display/java/SER04-J.+Validate+deserialized+objects</a></p></div></div><br />"
        ]
      }
    ]
  }
}