{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "1260908198",
      "Content_Hash": "1200866527"
    },
    "Metadata": [
      {
        "Id": [
          "f4bd754a-d9af-4d51-b04a-f9ba7c333650"
        ],
        "Id_History": [
          "f4bd754a-d9af-4d51-b04a-f9ba7c333650,c0944d22-6d8e-44e1-888c-e55d3f56b3a7,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "[SINK] How to Use SecureString To Protect Data In Memory"
        ],
        "Category": [
          "Cryptography"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          ".NET 3.5"
        ],
        "Type": [
          "How To"
        ],
        "DirectLink": [
          "How to Use SecureString To Protect Data In Memory"
        ],
        "Tag": [
          ""
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<h1>Description</h1>\r\n  <p>You can take sensitive data directly from the user and construct a <b>SecureString</b> object one character at a time by using the <b>AppendChar</b> method. The following code example shows how to do this. </p>\r\n  <pre>\r\n    <pre>using System.Securtiy;<br />SecureString securePassword = new SecureString();<br /> Console.WriteLine(\"Enter Password....\");<br /> while (true)<br /> &#123;<br />    ConsoleKeyInfo conKeyInfo = Console.ReadKey(true);<br />    if (conKeyInfo.Key == ConsoleKey.Enter)<br />        break;<br />    else if (conKeyInfo.Key == ConsoleKey.Escape)<br />        return;<br />    else if (conKeyInfo.Key == ConsoleKey.Backspace)<br />    &#123;<br />        if (securePassword.Length &#33;= 0)<br />            securePassword.RemoveAt(securePassword.Length - 1);<br />    &#125;<br />    else<br />        securePassword.AppendChar(conKeyInfo.KeyChar);<br />&#125;<br />Console.WriteLine(securePassword.Length.ToString());  </pre>\r\n  </pre>\r\n  <blockquote>\r\n    <p>\r\n      <b>Note</b>&nbsp;&nbsp;&nbsp;<b>SecureString</b> does not support inspection, comparison, or conversion functionality. It cannot be manipulated to reveal the data.</p>\r\n  </blockquote>\r\n  <p>To subsequently use the data from <b>SecureString</b>, use the <b>Marshal.SecureStringToBSTR</b> method, as follows.</p>\r\n  <pre>\r\n    <p>\r\n    </p>\r\n    <pre>using System.Runtime.InteropServices;<br />void UseSecretData(SecureString secret)<br />&#123;<br />    IntPtr bstr = Marshal.SecureStringToBSTR(secret);<br />    try<br />    &#123;<br />        // Use the bstr here<br />    &#125;<br />    finally<br />    &#123;<br />        // Make sure that the clear text data is zeroed out.<br />        Marshal.ZeroFreeBSTR(bstr);<br />    &#125;<br />&#125;  </pre>\r\n  </pre>\r\n  <p>As soon as you are finished with the data, make sure that you use the <b>Marshal.ZeroFreeBSTR</b> method to clear the text data. </p>\r\n  <blockquote>\r\n    <b>Note</b>&nbsp;&nbsp;&nbsp;Avoid converting back and forth between regular strings and secure strings because regular strings are immutable and you cannot clear them. As a result, you could have multiple copies of unencrypted strings in memory.</blockquote>Use of the <b>SecureString</b> class is less appropriate in ASP.NET applications. It is unlikely that you can extract data from a Web page that contains sensitive data (such as a credit card number) and place it inside a <b>SecureString</b> without it having already passed through intermediate <b>System</b>.<b> String</b> objects. <hr /><p>Adapted from Microsoft patterns & practices guidance.</p>"
        ]
      }
    ]
  }
}