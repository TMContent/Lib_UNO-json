{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "164291799",
      "Content_Hash": "-1813286134"
    },
    "Metadata": [
      {
        "Id": [
          "61d1685d-2cda-4566-9da5-9f57d239c395"
        ],
        "Id_History": [
          "61d1685d-2cda-4566-9da5-9f57d239c395,d1aa73f2-db6d-4734-9d7b-56c350610d47,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "How to Test for Denial-of-service (DoS) Vulnerabilities"
        ],
        "Category": [
          "Testing"
        ],
        "Phase": [
          "Test"
        ],
        "Technology": [
          "Technology Independent"
        ],
        "Type": [
          "How To"
        ],
        "DirectLink": [
          "How to Test for Denial-of-service (DoS) Vulnerabilities"
        ],
        "Tag": [
          ""
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<h1>Applies To</h1>\r\n  <ul>\r\n    <li>Software applications and services&nbsp;</li>\r\n  </ul>\r\n  <h1>Summary</h1>\r\n  <p>A software application must protect the confidentiality and integrity of its assets and the continuity of its service. In Denial-of-service (DoS) attacks, the attacker forces an application or the application’s environment into a state in which the application stops serving legitimate users.&nbsp; Although DoS attacks were first launched on networks, they have since expanded to application-level attacks. This article focuses on testing for application-level DoS vulnerabilities.</p>\r\n  <p>Follow these steps to test for DoS vulnerabilities:</p>\r\n  <ul>\r\n    <li>Step 1: Understand attack scenarios </li>\r\n    <li>Step 2: Analyze causes and countermeasures </li>\r\n    <li>Step 3: Start testing and exploring </li>\r\n    <li>Step 4: Execute additional testing<b>&nbsp;</b></li>\r\n  </ul>\r\n  <h1>Step 1: Understand Attack Scenarios</h1>\r\n  <p>The first step in testing for DoS vulnerabilities is to understand the common attack scenarios:</p>\r\n  <ul>\r\n    <li>Crashing the application </li>\r\n    <li>Forcing the application into an incorrect state </li>\r\n    <li>Creating an unstable environment</li>\r\n  </ul>\r\n  <h2>\r\n    Scenario 1: Crashing the Application\r\n  </h2>\r\n  <p>Application crashes result in DoS situations, since the application becomes unusable for a period of time. An attacker can force a buffer overflow, integer overflow, division by zero, or other exception to see if the application properly handles the error. When an application doesn’t handle these errors, its process generates a second-chance exception (an exception that is triggered right before the program terminates). The second-chance exception is handled by the structured/default exception handler (SEH), which in turn usually kills the process, resulting in all application users being temporarily unable to use the application.&nbsp;</p>\r\n  <h2>\r\n    Scenario 2: Forcing the Application into an Incorrect State\r\n  </h2>\r\n  <p>An application needn’t crash to stop providing service; if the application goes into an unexpected state, it can become useless and stop serving users. For instance, attackers who generate an infinite loop in the target application can deny service to the application’s users. This situation usually happens when applications use customer input as a loop index. An attacker can maliciously modify the loop index so that the loop takes too long to exit, or never exits at all. As a result, the application will not be able to handle additional user requests.<b></b></p>\r\n  <p>Account lockouts are also a common DoS situation, since they put the application into a state that allows an attacker to prevent users from logging in to the application. The attack is simple: The attacker repeatedly makes failed login attempts using the victim’s username. Applications usually employ lockout policies and human interaction proofs (such as CAPTCHAs) to deal with this kind of attack.</p>\r\n  <p>Additional application-level DoS attacks that attempt to put the application into a useless state include those in which the attacker uses another vulnerability to execute the attack. For instance, an attacker might find a stored cross-site scripting vulnerability in a main page of an application site. If the attacker stores a script with an infinite loop that prompts an alert box, any user who visits the site will be prompted with consecutive alert boxes and will be unable to use the application. Similarly, an attacker might execute an active SQL injection attack to drop a database table that is required by the application.</p>\r\n  <h2>\r\n    Scenario 3: Creating an Unstable Environment\r\n  </h2>\r\n  <p>An application might also fail to provide proper service if the environment in which the application operates becomes unstable. For instance, when memory becomes scarce, it is quite likely that the availability and quality of service to end users will be affected. In this scenario, the attacker uses programming errors in the application, such as unsafe memory allocations or memory leaks, or executes transaction flood attacks, in order to create an unstable system.</p>\r\n  <p>Unsafe memory allocations happen when an application allocates memory based on user input. An attacker can craft specific input to trick the application into allocating an excessive quantity of memory, thus causing the operating system to become unstable. While the system lacks memory, the application cannot properly service user requests.</p>\r\n  <p>Memory leaks happen when an application fails to properly release unused memory. An attacker with knowledge of a possible leak may force the application into allocating memory that will not be released. By repeatedly executing certain actions, the attacker can force the application to consume all available system memory, and thus to stop servicing legitimate users.</p>\r\n  <p>Transaction floods consist of repeatedly submitting transactions in order to consume memory and processor time. Attackers often take advantage of stress-testing tools to execute transaction flood attacks. If the application is vulnerable, while the attacker is submitting transactions the application will become unstable and unable to respond to legitimate user transactions.</p>\r\n  <h1>Step 2: Analyze causes and countermeasures</h1>\r\n  <p>The next step in testing for DoS vulnerabilities is to understand why they occur and how to protect against them.</p>\r\n  <h2>\r\n    Application Crashes\r\n  </h2>\r\n  <p>Application crashes occur due to unhandled second-chance exceptions caused by conditions such as buffer overflows, integer overflows, divisions by zero, referencing an invalid handle, and so on. To protect against application crashes and their exploitation by DoS attacks, developers must understand the conditions described above, properly handle user input, validate integer values, allocate memory carefully, and use structured exception handling.&nbsp;</p>\r\n  <h2>\r\n    Incorrect State\r\n  </h2>\r\n  <p>An infinite loop may cause an application to go into a DoS condition. This variation occurs when the attacker controls the index of a loop, creating a condition in which the execution control of the application doesn’t exit from the loop. Consider the following code posted by OWASP:</p>\r\n  <p>\r\n    <font face=\"'Courier New'\">public class MyServlet extends ActionServlet {<br />&nbsp; public void doPost(HttpServletRequest request,<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;HttpServletResponse response)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;throws ServletException, IOException {<br />&nbsp; &nbsp; . . .&nbsp;<br />&nbsp; &nbsp; String [] values = request.getParameterValues(\"CheckboxField\");<br />&nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; // Process the data without length check for reasonable range&nbsp;<br />&nbsp; &nbsp; for ( int i=0; i&lt; values.length; i++) {&nbsp;&nbsp; // wrong<br />&nbsp; &nbsp; &nbsp; // lots of logic to process the request<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; . . .&nbsp;<br />&nbsp; }<br />&nbsp; . . .&nbsp;<br />}&nbsp;</font>\r\n  </p>\r\n  <p>An attacker can pass a large number of values of the <i>CheckboxField</i> control to force the server to execute functionality with higher CPU and memory demands. This can easily result in a DoS condition on the application server. To protect against this DoS variation, developers must check any client-supplied loop counter against a reasonable range. &nbsp;</p>\r\n  <p>Additional DoS conditions that occur through other bugs, such as SQL injection or cross-site scripting, must be defended against based on the specific vulnerability. For instance, developers can protect against SQL injection by using white lists, stored procedures, and parameterized queries; developers can protect against cross-site scripting by encoding all user-supplied script tags before sending them to an Internet client.</p>\r\n  <h2>\r\n    Unstable Environment\r\n  </h2>\r\n  <p>Unsafe memory allocations occur when the application uses a client-supplied value as a size during memory allocation. In the example shown, an application uses client input as an array size:</p>\r\n  <p>\r\n    <font face=\"'Courier New'\">int arraySize = Convert.ToInt32(Request.QueryString[\"sz\"]);<br />int ServerObject[] objArray = new ServerObject[arraySize]; // wrong!!</font>\r\n  </p>\r\n  <p>The second instruction uses a client-controlled variable to allocate an array. An attacker who passes a large value in the <i>sz </i>parameter of the URL can force the application to allocate an extremely large memory block, putting the application in a DoS condition. To defend against unsafe memory allocations, it is necessary to allocate all arrays internally or, where arrays need to be dynamically allocated, to check if the client input is within the boundaries of a safe memory allocation. </p>\r\n  <p>Memory leaks occur because an application allocates a resource and doesn’t release it properly when it is done using it. Leaks are common when allocating and de-allocating objects in C/C++. Developers might use functions such as <i>new, malloc, or HeapAlloc </i>to allocate a memory object, but fail to invoke <i>delete, free,</i> or <i>HeapFree</i> to release the object from memory. An attacker who finds this error can force the application into multiple allocations in order to consume memory and create an unstable system. Another example occurs in web applications using database connections. Each database connection needs memory, and if not closed properly can lead to a memory leak. Developers must make sure to close all database connections and release any other objects from memory as soon as they are done with them.</p>\r\n  <p>To protect against transaction floods, developers must use thresholds to limit the number of transactions originating from a specific client. To achieve this, some sort of client authentication is required. For instance, an application might use the client’s IP address to identify a unique client. However, a client can execute an IP spoofing attack to make it seem as though the transactions are coming from different clients. Applications vulnerable to transaction floods should implement thresholds with a more secure authentication scheme such as SSL/TLS or IPSec.&nbsp;</p>\r\n  <h1>Step 3: Start Testing and Exploring</h1>\r\n  <p>Now that you are familiar with the different DoS attack scenarios as well with what causes them and how to defend against them, you must continue testing for them in your application.</p>\r\n  <h2>\r\n    Test for Application Crashes: Buffer Overflows\r\n  </h2>\r\n  <p>To test for DoS bugs through application crashes, start by attaching the application to a debugger. Application crashes such as buffer overflows occur when submitting malformed data, such as exceedingly long input strings or escape and special characters. Identify all places in the application that may be vulnerable, such as interfaces written in unmanaged code (C/C++). Try different ranges of lengths and combinations of characters.</p>\r\n  <h2>\r\n    Test for Application Crashes: Integer Overflows\r\n  </h2>\r\n  <p>Integer overflow testing consists of trying to feed the application a large integer that will cause an integer addition that wraps up the integer to a smaller value. Test for integer overflows by intercepting input data and modifying any integer or numeric values with large values. Unexpected integer values might cause the application to crash, so make sure to have a debugger attached to the application during these tests.</p>\r\n  <h2>\r\n    Test for Application Crashes: Divisions by Zero/Invalid Handles\r\n  </h2>\r\n  <p>Application crashes caused by division by zero or by referencing invalid handles occur when the application receives incorrectly formatted input. To test against this kind of crash, it is important to understand the underlying format of input data. For instance, to attempt forcing division by zero, try modifying integer variables to zero or deleting elements from an array or parameter list. If the application uses files or network packets as input, understand any tags and offsets that divide the input data. Then, overwrite offsets with zero values as well as escape and special characters to try to force the application into divisions by zero and into illegal access operations. Always attach a debugger to the application to catch any second-chance exceptions.&nbsp;</p>\r\n  <h2>\r\n    Test for Incorrect State: Infinite Loops\r\n  </h2>\r\n  <p>To test for infinite loops, you must look for any place where the application uses a client-supplied value as a loop counter. Try inserting items into lists of parameters used by the application by looking for name/value pairs, which may indicate a parameter list. For instance, the following URL has a list of similarly named parameters that the application might parse inside a <i>while </i>loop:</p>\r\n  <p>\r\n    <font face=\"'Courier New'\">http://example.com/processData.php?input1=a&input2=bc&input3=xz</font>\r\n  </p>\r\n  <p>Try modifying the URL by injecting an exceedingly large number of name/value pairs:</p>\r\n  <p>\r\n    <font face=\"'Courier New'\">http://example.com/processData.php?input1=a&input2=bc&input3=xz&input4=abc&input5=abc&input6=abc&input7=abc&input8=abc&input9=abc&input10=abc&input11=abc&input12=abc&input15=abc&input16=abc ...&input9999998=abc&input9999999=abc</font>\r\n  </p>\r\n  <p>To check if the attack has succeeded, try to use the application from a second host (different than the attacker) and measure its response time.</p>\r\n  <h2>\r\n    Test for Incorrect State: Cross-site Scripting\r\n  </h2>\r\n  <p>To test for DoS bugs using XSS, you must insert an XSS script that will create an unstable condition in an application. For instance, injecting the string</p>\r\n  <p>\r\n    <font face=\"'Courier New'\">&lt;script&gt;while(true)alert('XSS');&lt;/script&gt;</font>\r\n  </p>\r\n  <p>prompts the user repeatedly with a message box. If a persistent XSS bug exists in a main page or a profile page of an application, the user or users might be unable to use the application.</p>\r\n  <h2>\r\n    Test for Incorrect State: SQL Injection\r\n  </h2>\r\n  <p>To test for DoS bugs using SQL injection, you must execute a SQL injection string that will cause the application to drop a dependant table from the database, making the application unstable or unusable. For instance, submitting the following attack string</p>\r\n  <p>\r\n    <font face=\"'Courier New'\">x');DROP Table 'Accounts';--</font>\r\n  </p>\r\n  <p>might cause the application to drop the <i>Accounts</i> table. If the application relies on this table to function properly, dropping the table will result in the application being unable to serve users.</p>\r\n  <h2>\r\n    Test for Unstable Environment: Unsafe Memory Allocations\r\n  </h2>\r\n  <p>To test for unsafe memory allocations, start by looking for places in the application where a size value is taken. Once you find a variable or parameter used by the application to calculate a size, modify it to an extremely large value. Then perform a separate operation to see if the application responds the same as before you submitted the modified value. If the application slows down, it is a clear indication that the large value that you submitted was used internally by the application and that a DoS attack is possible.</p>\r\n  <h2>\r\n    Test for Unstable Environment: Memory Leaks\r\n  </h2>\r\n  <p>Memory leaks are common programming errors that must be tested as part of the application’s functional testing. Different tools are used to detect memory leaks, such as IBM<i> Rational Purify</i> and Compuware <i>BoundsChecker</i>. Test for memory leaks by submitting different ranges of string lengths and by putting the application under different stress conditions. Operating system tools such as Windows T<i>ask Manager</i> or UNIX <i>top</i> can be used to check the amount of memory consumed by the application under test.</p>\r\n  <h2>\r\n    Test for Unstable Environment: Transaction Floods\r\n  </h2>\r\n  <p>To test for transaction floods, use a CPU/memory monitoring tool such as Windows <i>Task Manager</i> or UNIX <i>top</i>. Then have a single client submit transactions in an infinite loop while checking how much CPU and memory are consumed by the server. If CPU and memory usage are high with a single client making transactions, the application is likely to be vulnerable to transaction flood DoS attacks.</p>\r\n  <h1>Step 4: Execute additional testing</h1>\r\n  <p>Now that you’ve learned how to execute basic DoS test cases, the final step in learning to discover DoS bugs is test different application-level scenarios and to extend any existing test automation to cover DoS attacks.</p>\r\n  <h2>\r\n    Additional Application-Level Scenarios\r\n  </h2>\r\n  <p>It is possible to launch DoS attacks using application-specific commands such as SQL wildcards. SQL wildcards will make a query run slower and will consume more server resources.</p>\r\n  <h2>\r\n    Extend Automation\r\n  </h2>\r\n  <p>Finally, extend any existing automation to cover application-level DoS tests. Add the test cases presented in this article to the test suite and to the current checks. Automating DoS testing is beneficial because it enables running a larger number of cases with multiple ranges and character combinations than would be possible to execute by hand.</p>\r\n  <h1>Conclusions</h1>\r\n  <p>DoS bugs stop legitimate users from using an application. DoS attacks are usually accomplished by crashing the application, putting the application into an incorrect state, or creating an unstable environment. It is important that you understand the different variations of DoS bugs, as well as their causes and countermeasures. Testing for DoS bugs relies on testing for other security and non-security bugs, such as buffer and integer overruns, and for memory leaks. Extend existing test automation to cover DoS bugs.</p>\r\n  <h1>Additional Resources</h1>\r\n  <p>\r\n  </p>\r\n  <ul>\r\n    <li>For information about testing for user input as a loop counter, see&nbsp;<a href=\"http://www.owasp.org/index.php/DoS_Testing:_User_Input_as_a_Loop_Counter\">http://www.owasp.org/index.php/DoS_Testing:_User_Input_as_a_Loop_Counter</a></li>\r\n    <li>For information about testing for denial of service, see&nbsp;<a href=\"http://www.owasp.org/index.php/Testing_for_Denial_of_Service\">http://www.owasp.org/index.php/Testing_for_Denial_of_Service</a></li>\r\n  </ul>\r\n  <p />\r\n  <div>\r\n    <p />\r\n    <p />\r\n  </div>\r\n  <div>\r\n  </div>"
        ]
      }
    ]
  }
}