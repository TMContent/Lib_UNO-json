{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "-602501019",
      "Content_Hash": "121509663"
    },
    "Metadata": [
      {
        "Id": [
          "c3779529-cd66-42d4-9930-3091a9916448"
        ],
        "Id_History": [
          "c3779529-cd66-42d4-9930-3091a9916448,0a7685ea-96ff-4677-9488-e626b857ad10,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "[VERIFYME] How to Use Windows Authentication"
        ],
        "Category": [
          "Authentication"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          ".NET"
        ],
        "Type": [
          "How To"
        ],
        "DirectLink": [
          "How to Use Windows Authentication"
        ],
        "Tag": [
          "ASP.NET,ASP.NET 4.0,ASP"
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<h1>Applies To</h1>\r\n  <ul>\r\n    <li>ASP.NET 4.0</li>\r\n  </ul>\r\n  <h1>Summary</h1>\r\n  <p>This How to shows you how to configure and use Windows authentication in an ASP.NET Web application. Windows authentication is the preferred approach whenever users are a part of your Windows domain. This approach enables you to use an existing identity store such as your corporate Active Directory, and does not transmit passwords over the network. This How to also shows various impersonation options available with Windows authentication and how to configure and use them with ASP.NET applications. It also explains how to use the various authorization mechanisms including file authorization, URL authorization, and role-based authorization, with Windows authentication.</p>\r\n  <h1>Contents</h1>\r\n  <ul>\r\n    <li>Objectives <li>Overview <li>Configuring Windows Authentication <li>Using Impersonation with Windows Authentication <li>Authorizing Windows Users <li>Kerberos Authentication <li>Additional Resources</li></li></li></li></li></li></li>\r\n  </ul>\r\n  <h1>Objectives</h1>\r\n  <ul>\r\n    <li>Learn how to configure your Web application for using Windows authentication. <li>Use impersonation with Windows authentication in ASP.NET applications. <li>Authorize users authenticated with Windows authentication. </li></li></li>\r\n  </ul>\r\n  <h1>Overview</h1>\r\n  <p>ASP.NET supports various authentication modes, including Windows authentication, forms authentication, Passport authentication, and custom authentication. You should choose Windows authentication if your user accounts are maintained by a Microsoft&amp;#174; Windows&amp;nbsp;NT&amp;#174; domain controller or within Microsoft Windows&amp;#174; Active Directory&amp;#8482; and there are no firewall issues. </p>\r\n  <p>The main benefit of using Windows authentication is that it can be coupled with IIS authentication so that you don't have to write any custom code. Compared to other authentication mechanisms, Windows authentication does not pass the user credentials over the wire. Windows authentication also provides a seamless user experience. Therefore Windows authentication should be used wherever possible. </p>\r\n  <p>When you configure ASP.NET for Windows authentication, it can be coupled with IIS authentication where IIS authenticates your application's users by using Basic authentication, Integrated Windows authentication, Digest authentication, or Client Certificate authentication. Both Integrated Windows authentication and Client Certificate authentication provide strong authentication, but Integrated Windows authentication is recommended unless you have a PKI infrastructure and your clients have certificates. </p>\r\n  <p>IIS authenticates the user and passes a Windows token for the authenticated user to ASP.NET along with each Web request. </p>\r\n  <h2>Impersonation Options</h2>\r\n  <p>You can use Windows authentication with ASP.NET in a number of ways: </p>\r\n  <ul>\r\n    <li>\r\n      <b>Windows authentication without impersonation.</b> This is the default setting. ASP.NET performs operations and accesses resources by using your application's process identity, which by default is the <em>Network Service </em>account on Windows Server 2003. <li><b>Windows authentication with impersonation. </b>With this approach, you impersonate the authenticated user and use that identity to perform operations and access resources. <li><b>Windows authentication with fixed-identity impersonation.</b> With this approach, you impersonate a fixed Windows account to access resources using a specific identity. On Windows Server 2003, you should avoid this impersonation approach; instead, use a custom application pool with a custom service identity. </li></li></li>\r\n  </ul>\r\n  <h2>Authorization Options</h2>\r\n  <p>Regardless of impersonation, you can authorize users and control access to resources and business operations by using the following mechanisms: </p>\r\n  <ul>\r\n    <li>\r\n      <p>\r\n        <b>URL authorization. </b>You use URL authorization to control access to requested files and folders based on the request URL. You configure URL authorization by using an &lt;<em>authorization</em>&gt; element in the Web.config file to control which users and groups of users should have access to requested resources. Authorization is based on the <em>IPrincipal</em> object stored in <em>HttpContext.User</em>. With Windows authentication, this object is of type <em>WindowsPrincipal</em> and it contains a <em>WindowsIdentity</em> object that holds the Windows token for the authenticated user. </p>\r\n      <li>\r\n        <p>\r\n          <b>File authorization.</b> For file types mapped by IIS to the ASP.NET ISAPI extension (<em>Aspnet_isapi.dll</em>), automatic access checks are performed using the authenticated user's Windows access token against the access control list (ACL) attached to the requested ASP.NET file. The <em>FileAuthorizationModule</em> class only performs access checks against the requested file. For example, if you request <em>Default.aspx</em> and it contains an embedded user control (<em>Usercontrol.ascx</em>), which in turn includes an image tag (pointing to Image.gif), the <em>FileAuthorizationModule</em> performs an access check for <em>Default.aspx</em> and <em>Usercontrol.ascx</em>, because these file types are mapped by IIS to the ASP.NET ISAPI extension. The <em>FileAuthorizationModule</em> does not perform a check for Image.gif, because this is a static file handled internally by IIS. However, because access checks for static files are performed by IIS, the authenticated user must still be granted read permission to the file with an appropriately configured ACL. <b>Note:</b>&amp;nbsp;Impersonation is not required for file authorization.<b></b></p>\r\n        <li>\r\n          <p>\r\n            <b>Role checks. </b>You can check the authenticated user's role membership by using methods such as <em>User.IsInRole</em> and <em>Roles.IsUserInRole</em>. This allows you to perform fine-grained authorization logic. To use the <em>Roles</em> API, you need to enable role manager for your application. You can also use principal permission demands and use class-level and method-level declarative security to control which users should be allowed to call classes and methods. </p>\r\n        </li>\r\n      </li>\r\n    </li>\r\n  </ul>\r\n  <h1>Configuring Windows Authentication</h1>\r\n  <p>To configure your application to use Integrated Windows authentication, you must use IIS Manager to configure your application's virtual directory security settings and you must configure the &lt;<em>authentication</em>&gt; element in the <em>Web.config</em> file.</p>\r\n  <h2>To configure Windows authentication </h2>\r\n  <ol>\r\n    <li>Start Internet Information Services (IIS). <li>Right-click your application's virtual directory, and then click <em>Properties</em>. <li>Click the <em>Directory Security</em> tab. <li>Under <em>Anonymous access and authentication control</em>, click <em>Edit</em>. <li>Make sure the <em>Anonymous access</em> check box is not selected and that <em>Integrated Windows authentication</em> is the only selected check box. </li></li></li></li></li>\r\n  </ol>\r\n  <p>In your application's <em>Web.config</em> file or in the machine-level <em>Web.config</em> file, ensure that the authentication mode is set to Windows as shown here.</p>\r\n  <pre>...<br />&amp;nbsp;&lt;system.web&gt;<br />&amp;nbsp; ...<br />&amp;nbsp; &lt;authentication mode=\"Windows\"/&gt;<br />&amp;nbsp; ...<br />&amp;nbsp;&lt;/system.web&gt;<br />&amp;nbsp;...  </pre>\r\n  <h1>Using Impersonation with Windows Authentication </h1>\r\n  <p>By using impersonation, ASP.NET applications can execute code or access resources with the identity of the authenticated user or a fixed Windows identity. Standard impersonate-level impersonation tokens that are usually created when you enable impersonation allow you to access local resources only. To be able to access remote network resources, you require a delegate-level token. To generate a delegate-level token when you impersonate, you need to use Kerberos authentication and your process account needs to be marked as trusted for delegation in Active Directory. </p>\r\n  <p>By default, ASP.NET applications are not configured for impersonation. You can confirm this by reviewing the identity settings in the <em>Machine.config.comments</em> file located in the following folder: <em>&amp;#37;windir&amp;#37;\\Microsoft.Net\\Framework\\&amp;#123;Version&amp;#125;\\CONFIG</em>.</p>\r\n  <p>The &lt;<em>identity</em>&gt; element is configured as follows. Note that impersonation is disabled.</p>\r\n  <pre>&lt;identity impersonate=\"false\" userName=\"\" password=\"\" /&gt;  </pre>\r\n  <h2>Impersonating the Original Caller with Windows Authentication</h2>\r\n  <p>When you configure your application for impersonation, an impersonation token for the authenticated user is attached to the Web request thread. As a result, all local resource access is performed using the caller's identity. </p>\r\n  <p>To configure ASP.NET to use Windows authentication with impersonation, use the following configuration.</p>\r\n  <pre>...<br />&amp;nbsp;&lt;system.web&gt;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; ...<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;authentication mode=\"Windows\"/&gt;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;identity impersonate=\"true\"/&gt;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; ...<br />&amp;nbsp;&lt;/system.web&gt;<br />&amp;nbsp;...  </pre>\r\n  <p>The resulting impersonation token and associated logon session does not have network credentials. If you access this Web site from a browser while logged onto a different machine in the same domain and the Web site attempts to access network resources, you end up with a null session on the remote server and the resource access will fail. To access remote resources, you need delegation. </p>\r\n  <h2>Impersonating a Fixed Identity with Windows Authentication </h2>\r\n  <p>You can configure ASP.NET to impersonate a fixed identity. You specify the credentials of the impersonated identity on the &lt;<em>identity</em>&gt; element in the <em>Web.config</em> file as shown here.</p>\r\n  <pre>...<br />&amp;nbsp;&lt;system.web&gt;<br />&amp;nbsp; ...<br />&amp;nbsp; &lt;authentication mode=\"Windows\"/&gt;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;identity impersonate=\"true\" userName=\"&lt;domain&gt;\\&lt;UserName&gt;\" password=\"&lt;password&gt;\"/&gt;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; ...<br />&amp;nbsp;&lt;/system.web&gt;<br />&amp;nbsp;...<br /></pre>\r\n  <p>If you specify credentials on the &lt;<em>identity</em>&gt; element, make sure they are stored in encrypted format by using the <em>Aspnet_regiis.exe</em> tool. Specifying credentials on the &lt;<em>identity</em>&gt; element should be avoided where possible. If you need a specific identity to access resources,&amp;nbsp;use a custom application pool with a custom service account identity instead. This approach avoids impersonation.<b></b></p>\r\n  <h2>Impersonating the Original Caller Programmatically</h2>\r\n  <p>If you only require an impersonated identity to access specific resources or perform specific operations and can use your process identity the rest of the time, you can use programmatic impersonation to temporarily enable impersonation.</p>\r\n  <h3>To temporarily impersonate the authenticated user</h3>\r\n  <p>This procedure shows you how to temporarily impersonate the original caller by using the Windows token that is passed by IIS to your Web application and is available through the <em>HttpContext</em> object. </p>\r\n  <ol>\r\n    <li>Check that your ASP.NET application is not configured for impersonation by ensuring that impersonate is set to <em>false</em> on the &lt;<em>identity</em>&gt; element in the <em>Web.config</em> file. <pre>...<br />&amp;nbsp;&lt;system.web&gt;<br />&amp;nbsp; ...<br />&amp;nbsp; &lt;authentication mode=\"Windows\"/&gt;<br />&amp;nbsp; &lt;identity impersonate=\"false\"/&gt;<br />&amp;nbsp; ...<br />&amp;nbsp;&lt;/system.web&gt;<br />&amp;nbsp;...  </pre><li>Obtain the authenticated user's Windows token. <pre>IIdentity WinId= HttpContext.Current.User.Identity;<br />WindowsIdentity wi = (WindowsIdentity)WinId;  </pre><li>Use the authenticated user's Windows token to temporarily impersonate the original user and remove the impersonation token from the current thread when you are finished impersonating. <pre>// Temporarily impersonate the original user.<br />WindowsImpersonationContext wic = wi.Impersonate();<br />try<br />&amp;#123;<br />&amp;nbsp; // Access resources while impersonating.<br />&amp;#125;<br />catch<br />&amp;#123;<br />&amp;nbsp; // Prevent exceptions propagating.<br />&amp;#125;<br />finally<br />&amp;#123;<br />&amp;nbsp; // Revert impersonation.<br />&amp;nbsp; wic.Undo();<br />&amp;#125;  </pre></li></li></li>\r\n  </ol>\r\n  <h1>Authorizing Windows Users</h1>\r\n  <p>When you use Windows authentication to authenticate users, you can use the following authorization options: </p>\r\n  <ul>\r\n    <li>File authorization provided by the <em>FileAuthorizationModule</em>. <li>URL authorization provided by the <em>UrlAuthorizationModule</em>. <li>Role-based authorization. </li></li></li>\r\n  </ul>\r\n  <p>\r\n    <b>Note: </b>File authorization requires Windows authentication. The other authorization options are available with other authentication mechanisms.<b></b></p>\r\n  <h2>Configuring Windows ACLs for File Authorization</h2>\r\n  <p>Requests for file types mapped to the ASP.NET ISAPI extension are checked by the <em>FileAuthorizationModule</em>. When you use Windows authentication, the authenticated user's Windows token is compared against the ACL attached to the requested file. For static files types that are not mapped to the ASP.NET ISAPI extension, IIS performs access checks again by using the authenticated user's access token and the ACL attached to the file. You need to configure appropriate ACLs on the file types directly requested by the user and on the files and other Windows resources accessed by your application, as described here: </p>\r\n  <ul>\r\n    <li>\r\n      <b>For</b>\r\n      <b>resources directly requested by the user.</b> For resources such as Web pages (.aspx files) and Web services (.asmx files) directly requested by the user, the authenticated user's Windows access token is compared against the Windows ACL attached to the file. Make sure that the authenticated user is allowed to access the appropriate Web pages and Web services. <li><b>For resources that the application accesses.</b> If impersonation is enabled, resources such as files, databases, registry keys, and Active Directory objects are accessed by using the impersonated identity. Otherwise, your application's process identity, such as the <em>Network Service</em> account, is used for resource access. For the resource access attempt to succeed, the ACL attached to these resources must be suitably configured to allow the process account or impersonated identity the access it requests, such as read access, or write access. </li></li>\r\n  </ul>\r\n  <h2>Configuring URL Authorization</h2>\r\n  <p>When you use Windows authentication, the <em>UrlAuthorizationModule</em> checks the access to requested files and folders based on the authenticated caller's identity. This is true regardless of whether your application is configured for impersonation.</p>\r\n  <p>To configure URL authorization, add an &lt;<em>authorization</em>&gt; element to the <em>Web.config</em> file, and specify the domain name and user or group name when configuring &lt;<em>deny</em>&gt; and &lt;<em>allow</em>&gt; elements, as shown here.</p>\r\n  <pre>&lt;authorization&gt;<br />&amp;nbsp;&lt;deny users=\"DomainName\\UserName\" /&gt;<br />&amp;nbsp;&lt;allow roles=\"DomainName\\WindowsGroup\" /&gt;<br />&lt;/authorization&gt;  </pre>\r\n  <p>When you use Windows authentication, user names take the form <i>domainName\\userName</i>. Windows groups are used as roles and they take the form <i>domainName\\windowsGroupName</i>. Well known local groups such as <em>Administrators</em> and <em>Users</em> are referenced by using the \"<em>BUILTIN</em>\" prefix as shown here. </p>\r\n  <pre>&lt;authorization&gt;<br />&amp;nbsp; &lt;allow users=\"DomainName\\Bob, DomainName\\Mary\" /&gt;<br />&amp;nbsp; &lt;allow roles=\"BUILTIN\\Administrators, DomainName\\Manager\" /&gt;<br />&amp;nbsp; &lt;deny users=\"&amp;#42;\" /&gt;<br />&lt;/authorization&gt;  </pre>\r\n  <h2>Checking Role Membership in Code</h2>\r\n  <p>With Windows authentication, the user's Windows group membership can be used to determine the role membership and Window groups become the roles. You can perform role-based authorization in code either by performing explicit role checks (<em>User.IsInRole</em> or <em>Roles.IsUserInRole</em>), or by using <em>PrincipalPermission</em> demands. You can do the latter either imperatively in the body of a method or declaratively by adding attributes to your classes and methods.</p>\r\n  <h3>To use explicit role checks: </h3>\r\n  <ul>\r\n    <li>Use the <em>IPrincipal</em> interface of the <em>User</em> object attached to the current HTTP request. When using Windows authentication, make sure to use the <i>domainName\\userName</i> format for the user name and the format <i>domainName\\groupName</i> for the group name.<b></b><pre>if(User.IsInRole(&amp;#64;\"DomainName\\Manager\"))<br />&amp;nbsp; // Perform restricted operation<br />else<br />&amp;nbsp; // Return unauthorized access error.  </pre><li>Alternatively, use role manager APIs, which supports a similar <em>Roles.IsUserInRole</em> method, as shown here. <pre>if(Roles.IsUserInRole(&amp;#64;\"DomainName\\Manager\"))<br />&amp;nbsp; // Perform restricted operation<br />else<br />&amp;nbsp; // Return unauthorized access error.  </pre><p>To use the role manager API, you must enable role manager. With Windows authentication, you can use the built-in <em>AspNetWindowsTokenRoleProvider</em>, which uses Windows groups as roles. To enable role manager and select this provider, add the following configuration to your <em>Web.config</em> file. </p><pre>&lt;roleManager enabled=\"true\"<br />             defaultProvider=\"AspNetWindowsTokenRoleProvider\"/&gt;  </pre><p>When you use Windows authentication, you can use alternate role providers, such as the <em>AuthorizationStoreRoleProvider</em> and <em>SqlRoleProvider</em>, if you need to store roles in alternate role stores such as Authorization Manager policy stores or SQL Server databases. </p></li></li>\r\n  </ul>\r\n  <h3>To use PrincipalPermission demands </h3>\r\n  <ul>\r\n    <li>Construct a <em>PrincipalPermission</em> object, and then call its <em>Demand</em> method to perform authorization. <li>For fine grained authorization, call <em>PrincipalPermission.Demand</em> within code, as shown here. <pre>using System.Security.Permissions;<br />...<br />// Imperative checks <br />PrincipalPermission permCheckUser = new PrincipalPermission(&amp;#64;\"Domain\\Bob\", null);<br />permCheckUser.Demand();  </pre><li>Alternatively, you can decorate your classes or methods with the <em>PrincipalPermissionAttribute</em>, as shown here. <pre>using System.Security.Permissions;<br />...<br /> &amp;#91;PrincipalPermission(SecurityAction.Demand,Role=&amp;#64;\"Builtin\\Administrators\")&amp;#93;  </pre><p>The advantage of this approach is that the security requirements of your methods are visible to tools such as <em>Permview.exe</em>. </p></li></li></li>\r\n  </ul>\r\n  <h1>Kerberos Authentication</h1>\r\n  <p>When you configure IIS for Integrated Windows authentication, it uses either NTLM or Kerberos authentication, depending on the configuration of client and servers. Kerberos authentication offers a performance benefit and also supports additional features such as the ability to use delegation and mutual authentication.</p>\r\n  <h2>To use Kerberos authentication </h2>\r\n  <ul>\r\n    <li>All computers must be in a Windows Server&amp;nbsp;domain. <li>Internet Explorer security settings must be configured to enable Integrated Windows authentication. By default, Integrated Windows authentication is not enabled in Internet Explorer. To enable the browser to respond to a negotiate challenge and perform Kerberos authentication, select the <em>Enable Integrated Windows Authentication</em> check box in the <em>Security</em> section of the <em>Advanced</em> tab of the <em>Internet Options</em> menu, and then restart the browser. <li>If you use a custom service account to run your ASP.NET application, you a Service Principal Name (SPN) must be registered for the account in Active Directory. </li></li></li>\r\n  </ul>\r\n  <p>To register an SPN, use the <em>Setspn.exe</em> utility by running the following commands from a command prompt:</p>\r\n  <pre>setspn -A HTTP/webservername domain\\customAccountName</pre>\r\n  <pre>setspn -A HTTP/webservername.fullyqualifieddomainname domain\\customAccountName</pre>\r\n  <p>Note that you cannot have multiple Web applications with the same host name if you want them to have multiple identities and to use Kerberos authentication. This is an HTTP limitation, not a Kerberos limitation. The workaround is to have multiple Domain Name System (DNS) names for the same host, and then start the URLs for each Web application with a different DNS name. For example, you would use <em>http://app1</em> and <em>http://app2</em> instead of <em>http://site/app1</em> and <em>http://site/app2</em>.</p>\r\n  <hr />\r\n  <p>Adapted from Microsoft patterns &amp; practices guidance.</p>"
        ]
      }
    ]
  }
}