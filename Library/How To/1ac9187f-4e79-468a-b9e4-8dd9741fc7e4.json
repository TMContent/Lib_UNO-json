{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "-378001256",
      "Content_Hash": "2092397170"
    },
    "Metadata": [
      {
        "Id": [
          "1ac9187f-4e79-468a-b9e4-8dd9741fc7e4"
        ],
        "Id_History": [
          "1ac9187f-4e79-468a-b9e4-8dd9741fc7e4,4b5650b3-9edd-4d94-8b6a-feeac285a5cf,"
        ],
        "Library_Id": [
          "92718d53-36b2-47bc-b6f5-e60994385f46"
        ],
        "Title": [
          "How to Use Passwords To Generate Keys"
        ],
        "Category": [
          "Cryptography"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          ".NET 3.5"
        ],
        "Type": [
          "How To"
        ],
        "DirectLink": [
          "How to Use Passwords To Generate Keys"
        ],
        "Tag": [
          ""
        ],
        "Security_Demand": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ],
        "Source": [
          "SI"
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "true",
          "DataType": "Html"
        },
        "Data": [
          "<h1>Description</h1>\r\n  <p>Instead of using <b>PasswordDeriveBytes</b> to generate keys from a password you should use <b>Rfc2898DeriveBytes</b>. The main advantage is that it supports the RSA Password-Based Key Derivation Function version 2 (PBKDF2), which is an improved version of the PBKDF1 standard implementation used by <b>PasswordDeriveBytes</b>. </p>\r\n  <p>To use <b>Rfc2898DeriveBytes</b>, supply at minimum a password and salt value. You can also specify a number of iterations to derive the key if you want to override the default 1000 iterations. <b>Rfc2898DeriveBytes</b> uses HMACSHA1 as an underlying pseudo-random generator. After the key is used to encrypt the data, clear it from memory but persist the salt and the number of iterations if you changed the default value. These values should be protected and are needed to regenerate the key for decryption. </p>\r\n  <p>The following code shows how to call <b>Rfc2898DeriveBytes</b>. </p>\r\n  <pre>using System.Security.Cryptography;...<br />// Get salt (random bytes) <br />using RNGCryptoServiceProvider.byte&#91;&#93; salt = new byte&#91;8&#93;;<br />new RNGCryptoServiceProvider().GetBytes(salt);<br />// Get the Password derived bytes using password and salt.<br />Rfc2898DeriveBytes passwordBytes = new Rfc2898DeriveBytes (\"P&#64;ssword&#33;\",salt);<br />// Create a TripleDESCryptoServiceProvider object.<br />TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();<br />// Get the password derived bytes key of length 16 bytes and add <br />// it to the Key property.<br />tdes.Key = passwordBytes.GetBytes(16);<br />// Use the TripleDESCryptoServiceProvider object to encrypt and decrypt data....  </pre>\r\n  <blockquote>\r\n    <b>Note</b>&nbsp;&nbsp;&nbsp;To decrypt the data you will need the initialization vector (IV) value used by the encryption routine, so that must also be available to the decryption code.</blockquote>\r\n  <hr />\r\n  <p>Adapted from Microsoft patterns & practices guidance.</p>"
        ]
      }
    ]
  }
}