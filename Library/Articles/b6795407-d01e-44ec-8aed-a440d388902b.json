{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "0",
      "Content_Hash": "0"
    },
    "Metadata": [
      {
        "Id": [
          "b6795407-d01e-44ec-8aed-a440d388902b"
        ],
        "Id_History": [
          "b6795407-d01e-44ec-8aed-a440d388902b,17e2f87d-6497-43bc-837d-c315774022f9,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "Validate Input for Length, Range, Format, And Type"
        ],
        "Category": [
          "Input and Data Validation"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          "Scala Play"
        ],
        "Type": [
          "Guideline"
        ],
        "DirectLink": [
          "Validate Input for Length, Range, Format, And Type"
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "false",
          "DataType": "html"
        },
        "Data": [
          "<h1>Applies to</h1>\n  <p>Applications written using Scala and Play Framework 2.1.0+</p>\n  <h1>What to Do</h1>\n  <p>Treat all input as untrusted data. Validate untrusted data using whitelist techniques to check against known good input.</p>\n  <h1>Why</h1>\n  <p>Unchecked malicious input may lead to integer overflows, injection based attacks, denial of service or information disclosure.</p>\n  <h1>When</h1>\n  <p>Always validate input. Do not assume that input is good based on origin.</p>\n  <h1>How</h1>\n  <p>Input can vary in length, data type, and contents. Verify that all input meets your application's expectations.</p>\n  <ol>\n    <li>\n      <p />\n      <strong>Validating length</strong>: Validate an input's length by checking a string's length or the number of bits in a numeric value. Checking the length can help prevent buffer overflows as well as integer overflows in numeric values. A simple way to validate the numeric value for forms is through the use of&nbsp;<i>minLength(length: Int)</i>&nbsp;and<i>&nbsp;maxLength(length: Int)</i>&nbsp;from the&nbsp;<i>play.api.data.validation</i>constraints object of Play Framework:<pre>object SignUp extends Controller {\n  \n  /**\n   * Sign Up Form definition.\n   */\n  val signupForm: Form[User] = Form(\n    \n    // Define a mapping that will handle User values\n    mapping(\n      \"firstname\" -&gt; text(maxLength = 20),\n      \"lastname\" -&gt; text(maxLength = 20),\n      \"username\" -&gt; text(minLength = 4),\n      \"password\" -&gt; text(minLength = 6),   \n      // Create a tuple mapping for the password/confirm\n      \"password\" -&gt; tuple(\n        \"main\" -&gt; text(minLength = 6),\n        \"confirm\" -&gt; text\n      ),\n\n    )\n  )\n  }</pre>Also, you can validate any numeric value through the use of BigInt/BigDecimal as follows:&nbsp;<pre>def productcheck = Action { implicit request =&gt;\n    prodForm.bindFromRequest.fold(\n      errors =&gt; BadRequest(views.html.index(errors, \"There is some error\")),\n      prodForm =&gt; {\n\n        val proname = prodForm.pname\n        val prodprice = prodForm.price\n        if(prodprice.compare(BigInt(0)) &gt; -1\n          && prodprice.compare(BigInt(Integer.MAX_VALUE)) \n        {\n          println(\"true\")\n          ............ //code for true\n        }\n        else\n        {\n          println(\"false\")\n          ............ // code for exception\n        }</pre></li>\n    <li>\n      <p />\n      <strong>Validating type</strong>: Validating the input's data type is important when your application expects a specific non-string parameter. Difference in data type can trigger unhandled exceptions that would throw your application into an unknown state. The following is an example for validating in forms:<pre>object ContactForm extends Controller {\n  \n  /**\n   * Contact Form definition.\n  */\n  val appointmentMapping = tuple(\n  \"location\" -&gt; text,\n  \"start\" -&gt; tuple(\n    \"date\" -&gt; date,\n    \"time\" -&gt; text),\n  \"attendees\" -&gt; list(mapping(\n    \"name\" -&gt; text,\n    \"email\" -&gt; email)\n)}\n</pre><div><br /></div></li>\n    <li>\n      <p />\n      <strong>Validating contents</strong>: Use whitelist and blacklist techniques to validate the input's contents. Choose the technique based on the constraints that are imposed on the input: If the input follows a tight structure and format, you can use whitelisting alone to weed out malicious input. If there are unknowns about the input, you'll need a combination of black and white listing. In general, use blacklisting as a backup to whitelisting, through a spiral-out approach: Use whitelisting for the initial validation. If whitelisting cannot validate the input, then fall back to blacklisting. If blacklisting cannot validate, then discard the input. The following is an example of implementing this technique using forms:<pre>object ValidateProduct extends Controller {\n\n  val productForm = Form(mapping(\n    \"ean\" -&gt; longNumber.verifying(\"This product already exists!\", Product.findByEan(_).isEmpty),\n    \"name\" -&gt; nonEmptyText,\n    \"description\" -&gt; text,\n    \"pieces\" -&gt; number,\n    \"active\" -&gt; boolean)(Product.apply)(Product.unapply).verifying(\n      \"Product can not be active if the description is empty\", product =&gt;\n        !product.active || product.description.nonEmpty))\n}</pre><p>Using regular expressions, the fix would be as below:</p><p /><pre>val pid = ProductForm.productid\nval pname = ProductForm.productname\nval products = Product.findProduct(pid, pname)\nval whitelistPattern = \"(\\\\w|\\\\d)+\".r\nval issafe =whitelistPattern.pattern.matcher(pname).matches</pre><pre>if (issafe){</pre><pre>...... //Code for Action</pre><pre>}else{</pre><pre>...... //Code for Exception</pre><pre>}</pre><pre></pre><br />Examples of useful regular expressions:<p /><p /><table><tbody><tr><td>Use</td><td>Regular Expression</td><td>Scala String</td></tr><tr><td>Valid E-Mail Address</td><td>^\\w+(\\.|_|-){0,1}\\w+@(\\w+\\.)*\\w{3,1024}\\.([a-zA-Z]{2}\\.){0,1}[a-zA-Z]{2,4}$</td><td>^\\\\w+(\\\\.|_|-){0,1}\\\\w+@(\\\\w+\\\\.)*\\\\w{3,}\\\\.([a-zA-Z]{2}\\\\.){0,1}[a-zA-Z]{2,4}$</td></tr><tr><td>Alpha-numeric free text</td><td>(\\w|\\d|\\s|;|\\?|!|,|\\.|-|:)+</td><td>(\\\\w|\\\\d|\\\\s|;|\\\\?|!|,|\\\\.|-|:)+</td></tr><tr><td>Word characters</td><td>\\w+</td><td>\\\\w+</td></tr><tr><td>Numbers</td><td>\\d+</td><td>\\\\d+</td></tr></tbody></table><p /><ul></ul></li>\n  </ol>\n  <h1>Problem Example</h1>\n  <p />\n  <p>\n    <font face=\"Arial\" size=\"2\">The following code shows how a user registers for an account. Post-registration, when the user logs in, the registered name is reflected back on the screen. Because it does not HTML encode the echoed input, the application is vulnerable to persistent cross-site scripting.</font>\n  </p>\n  <font face=\"Arial\" size=\"2\">\n  </font>\n  <p>\n    <font face=\"Arial\" size=\"2\">Code for the User creation model -- notice that the name is a String object with no validations and allows special characters:</font>\n  </p>\n  <p style=\"font-size: 10pt;\" />\n  <pre>object User extends UserInfoService[String, User] {\n\n  val passwordService = MyPasswordService\n\n  def register(email: String, name:String, password: String) : User = {\n    val encryptedPassword = passwordService.encryptPassword(password)\n    val user = User(email, name, encryptedPassword)\n    create(user)\n  }\n\ndef create(user: User): User = {\n    DB.withConnection {\n      implicit connection =&gt;\n        SQL(\n          \"\"\"\n          insert into user values (\n            {email}, {name}, {password}\n          )\n          \"\"\"\n        ).on(\n          'email -&gt; user.email,\n          'name -&gt; user.name,\n          'password -&gt; user.password.underlying\n        ).executeUpdate()\n\n        user\n    }\n  }</pre>\n  <pre>\n    <br />\n  </pre>\n  <pre>\n    <font face=\"Arial\">\n      <span style=\"white-space: normal;\">Code for the Signup Controller</span>:</font>\n  </pre>\n  <p />\n  <p />\n  <pre>  val signupForm = Form(\n    mapping(\n      \"email\" -&gt; email,\n      \"fullName\" -&gt; text,\n      \"password\" -&gt; weakPassword\n    )(SignupData.apply)(_ =&gt; None)\n  )\n\n  case class SignupData(email: String, fullName: String, password: String)</pre>\n  <pre>\n    <br />\n  </pre>\n  <pre>\n    <font face=\"Arial\">\n      <span style=\"white-space: normal;\">Code for the HTML template where the user is redirected after successful login--notice that the name, which is not sanitized, is reflected back as raw HTML:</span>\n    </font>\n  </pre>\n  <pre>@()(implicit ctx: MyContext[_])\n\n@base.layout() {\n  &lt;div class=\"container\"&gt;\n    &lt;div class=\"row\"&gt;\n      &lt;div class=\"span12\"&gt;\n        &lt;div class=\"well\" style=\"height: 600px\"&gt;\n          &lt;h1 style=\"text-align: center\"&gt;Main Page&lt;/h1&gt;\n\n          &lt;p style=\"font-size: 20px; text-align: center; margin-top: 15px\"&gt;\n            @ctx.me match {\n              case None =&gt; {\n                You are anonymous.\n              }\n              case Some(user) =&gt; {\n                You are currently logged in as @Html(user.name).\n              }\n            }\n          &lt;/p&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n}<font face=\"Arial, Verdana\" size=\"3\"></font></pre>\n  <div>\n    <br />\n  </div>\n  <p />\n  <h1>Solution Example</h1>\n  <p />\n  <p>\n    <font face=\"Arial\" size=\"2\">The following code shows how a user registers for an account, Again, post-registration, when the user logs in, the registered name is reflected back on the screen. But this time the play framework automatically performs HTML encoding of all the entries in the HTML template. This protects the application from XSS. Additionally, there should be regex validation on the Name<font face=\"Courier New\"></font>&nbsp;parameter to make sure that the user is not able to enter malicious names into the application.</font>\n  </p>\n  <font face=\"Arial\" size=\"2\">\n  </font>\n  <p>\n    <font face=\"Arial\" size=\"2\">Regex validation for Name:</font>\n  </p>\n  <p />\n  <pre>val pid = SignupForm.empid\nval name = SignupForm.productname\nval emp = Emp.findEmp(pid, name)\nval whitelistPattern = \"(\\\\w|\\\\d)+\".r\nval issafe =whitelistPattern.pattern.matcher(name).matches\nif (issafe){\n...... //Code for Action\n}else{\n...... //Code for Exception\n}</pre>\n  <p />\n  <p>\n    <font face=\"Arial\" size=\"2\">Code for HTML template:</font>\n  </p>\n  <p />\n  <pre>@()(implicit ctx: MyContext[_])\n\n@base.layout() {\n  &lt;div class=\"container\"&gt;\n    &lt;div class=\"row\"&gt;\n      &lt;div class=\"span12\"&gt;\n        &lt;div class=\"well\" style=\"height: 600px\"&gt;\n          &lt;h1 style=\"text-align: center\"&gt;Main Page&lt;/h1&gt;\n\n          &lt;p style=\"font-size: 20px; text-align: center; margin-top: 15px\"&gt;\n            @ctx.me match {\n              case None =&gt; {\n                You are anonymous.\n              }\n              case Some(user) =&gt; {\n                You are currently logged in as @user.name.\n              }\n            }\n          &lt;/p&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n}</pre>\n  <p />\n  <pre>\n    <br />\n  </pre>\n  <h1>Additional Resources</h1>\n  <ul>\n    <li>A tutorial on regular expressions is available at&nbsp;<a href=\"http://www.regular-expressions.info/\">Regular-Expressions.info</a>.</li>\n    <li>For more information on using regular expression in Scala, see: Documentation for&nbsp;<a href=\"http://www.scala-lang.org/api/current/index.html#scala.util.matching.Regex\">Regex Pattern</a>&nbsp;in Scala documentation.</li>\n  </ul>\n  <div>\n    <br />\n  </div>"
        ]
      }
    ]
  }
}