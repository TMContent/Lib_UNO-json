{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "0",
      "Content_Hash": "0"
    },
    "Metadata": [
      {
        "Id": [
          "07f4ded0-a494-4367-8141-90e68cab1f44"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "Use Strong Cryptographic Algorithms"
        ],
        "Category": [
          "Cryptographic Storage"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          "Ruby"
        ],
        "Type": [
          "How To"
        ],
        "DirectLink": [
          ""
        ],
        "Tag": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "false",
          "DataType": "markdown"
        },
        "Data": [
          "## Applies To ##\r\n\r\n- Ruby\r\n\r\n\r\n## What to Do ##\r\n\r\nSelect a well-vetted cryptographic algorithm that is currently considered by experts in the field to be strong, such as AES-256 or RSA-2048. Implement the algorithm in Ruby applications by using complete programmatic methods that are well-documented, and have been thoroughly tested.\r\n\r\n\r\n## Why ##\r\n\r\nThe omission or misuse of cryptography can result in sensitive information exposure. If a broken, risky, or non-standard algorithm is used, an attacker may break the algorithm with well-known techniques.\r\n\r\nDo not develop your own cryptographic algorithms. They will likely be exposed to attacks that are well-understood by cryptographers. Reverse engineering techniques are mature, and your algorithm can be compromised once attackers identify it as especially weak, and find out how it works.\r\n\r\nProper use of cryptography ensures the confidentiality, integrity, and non-repudiation of data. Strong algorithms assure that an attacker cannot break encryption in a timely manner.\r\n\r\n\r\n## When ##\r\n\r\nDecide on an appropriate crypto method after reviewing available options that are maintained and tested for secured applications. Implement strong cryptography in the application design whenever sensitive data is handled.\r\n\r\nAs commercially available computing power rapidly increases and new threats emerge, it becomes more and more important to use strong cryptographic algorithms to secure sensitive data.\r\n\r\nMake sure that the source code is available for analysis. For items on the FIPS 140-2 cryptographic modules list, source code has been submitted for validation. Remember, when using industry-approved techniques, you also need to implement cryptography correctly.\r\n\r\nUsing the correct key size will also result in a more secure encryption. Different encryption algorithms require different key sizes for a similar level of security. For example, according to NIST guidelines, 15360-bit RSA keys are equivalent to 256-bit AES keys.\r\n\r\nWith AES and other symmetric cryptology, you do not directly use the cipher primitives. Rather, you will select from available modes for the cryptology, such as these NIST-approved methods of operation for AES:\r\n\r\n- **Electronic Code Book (ECB) mode.** ECB mode uses AES without applying feedback. This is considered a vulnerable mode since the function applied in this way always returns the same cipher text. In ECB mode, AES processes data in same-size blocks as the encryption function, and synchronization is required between encryption/decryption engines. Performance of ECB mode is poor if used for large data movement.\r\n\r\n- **Cipher Block Chaining (CBC) mode.** With CBC mode, data is first processed by AES function, then feedback is used to modify data before encryption. Each block of cipher text will depend on the previous message block. Again, message block size must match the function size, and synchronization is required between encryption/decryption engines. CBC mode is used in IPsec, for a common example.\r\n\r\n- **Cipher FeedBack (CFB) mode.** CFB mode provides a method where the block cipher can work like a stream cipher, and process data shorter than a block. This mode is described as self-synchronizing. Still, synchronization between encryption/decryption is required, but this occurs at the data width, rather than at a larger block size. Other advantages are that the cipher block is used in the encrypting direction, and padding is not required for an unfilled cipher block.\r\n\r\n- **Output FeedBack (OFB) mode.** OFB mode uses a block cipher as a synchronous stream cipher. Keystream blocks are XORed with message blocks to produce ciphertext. An advantage of this mode is that error correcting codes will work when applied before or after encryption. A weakness of this mode is evident when the algorithm block size does not match the data width. Synchronization is required between encryption/decryption engines.\r\n\r\n- **Counter (CTR) mode.** CTR mode uses the block cipher as a stream cipher. Each successive keystream block is a product of encrypted successive counter values. The result is XORed with message data to produce encrypted output. The block output does not need to be padded, and synchronization is required between encryption/decryption engines. CTR mode operates optimally with multiple processors since parallel block encryption can be performed more efficiently.\r\n\r\n**Encryption mode characteristics.** As with the AES modes described, a developer always selects from various algorithm characteristics and encryption method behaviors. Consideration should be given to data bit errors, block sync errors, message length growth, padding, etc. A balance needs to be established between speed and cost by examining the effect of various mode characteristics in strong cryptographic algorithms.\r\n\r\nThe following are examples of Ruby libraries and gems which support higher levels of encryption such as AES-256 and RSA-2048.\r\n\r\n- `attr_encrypted` (Rubygem). Generates `attr_accessors` that encrypt and decrypt attributes transparently. The default Encryptor uses the standard Ruby OpenSSL library. Default algorithm is aes-256-cbc.\r\n- Chilkat (Ruby library). Use in applications and websites to encrypt files, strings, and byte arrays using public/private key pairs.\r\n- Crypt (Ruby library) Pure-ruby implementation of a number of popular encryption algorithms.\r\n- Strongbox (Plugin). Provides public key encryption for `ActiveRecord`. Supports RSA-2048, etc.\r\n- `crypt_keeper` (Rubygem). Performs encryption by using AES-256 via Ruby OpenSSL library.\r\n- krypt (Ruby library). Platform- and library-independent cryptography for Ruby.\r\n- OpenSSL (Ruby built-in library). Provides SSL, TLS and general purpose cryptography.\r\n- `pkcs11` (Rubygem). Module that allows Ruby programs to interface with RSA Security Inc. PKCS #11 Cryptographic Token Interface (Cryptoki). Requires an installed PKCS #11 v2.20 implementation library.\r\n- `RSA.rb` (Ruby library). Ruby implementation of the RSA encryption algorithm and the PKCS#1 cryptography standard.\r\n- `symmetric-encryption` (Rubygem). Uses OpenSSL to encrypt and decrypt data with all encryption algorithms supported by Ruby OpenSSL library.\r\n\r\n\r\n## How ##\r\n\r\nCryptographic implementation should exactly follow the algorithm definitions. Otherwise, encryption can be weaker than expected. There are a wide variety of cryptographic solutions. The specific steps for implementation must always be carried out according to vendor directions. Do not cut corners by skipping resource-intensive steps, as this is a documented weakness (CWE-325). These guideline steps are essential for preventing common attacks:\r\n\r\n1. **Identify sensitive data.** Review the application design to determine what kinds of sensitive data will be handled. Record the findings in a data flow diagram that can be used to confirm the completion of protective measures.\r\n\r\n2. **Choose cryptographic algorithms.** Strong symmetric algorithms are AES and, to a lesser extent, 3-DES. Strong asymmetric encryption algorithms are RSA, Elliptic Curve, and NTRU. The recommended key strengths are:\r\n - 256-bit or more for AES\r\n - 3-DES key length is fixed at 168-bit\r\n - 2048-bit or more for RSA\r\n - 384-bit for Elliptic Curve cryptography\r\n - 80-bit for NTRU.\r\n\r\n3. **Choose libraries and APIs.** Find libraries that implement your chosen cryptographic algorithms, or use a library implemented by the platform, such as Ruby OpenSSL. Review documentation to find best practices for the APIs using these algorithms.\r\n\r\n4. **Add encryption keys.**  Make sure that any secret key is protected from unauthorized access. This example code creates a 2048-bit RSA keypair and writes it to the current directory:\r\n\r\n        key = OpenSSL::PKey::RSA.new 2048\r\n\r\n        open 'private_key.pem', 'w' do |io| io.write key.to_pem end\r\n        open 'public_key.pem', 'w' do |io| io.write key.public_key.to_pem end\r\n\r\n5. **Use encryption.** Find code that handles sensitive data, and apply encryption. Add code that calls the functions to encrypt sensitive data as appropriate. This example instantiates a Cipher for encryption, and generates a random IV plus a key derived from the password (using PBKDF2). PKCS #5 v2.0 recommends at least 8 bytes for the salt. The number of iterations largely depends on the hardware being used.\r\n\r\n        cipher = OpenSSL::Cipher.new 'AES-128-CBC'\r\n        cipher.encrypt\r\n        iv = cipher.random_iv\r\n\r\n        pwd = 'some hopefully not to easily guessable password'\r\n        salt = OpenSSL::Random.random_bytes 16\r\n        iter = 20000\r\n        key_len = cipher.key_len\r\n        digest = OpenSSL::Digest::SHA256.new\r\n\r\n        key = OpenSSL::PKCS5.pbkdf2_hmac(pwd, salt, iter, key_len, digest)\r\n        cipher.key = key\r\n\r\n        # Now encrypt the data:\r\n\r\n        encrypted = cipher.update document\r\n        encrypted << cipher.final\r\n\r\n6. **Use Decryption.** Find code that handles encrypted sensitive data, and apply decryption code as appropriate. In this example, use steps as before to derive the symmetric AES key. Then setup the Cipher for decryption.\r\n\r\n        cipher = OpenSSL::Cipher.new 'AES-128-CBC'\r\n        cipher.decrypt\r\n        cipher.iv = iv # the one generated with #random_iv\r\n\r\n        pwd = 'some hopefully not to easily guessable password'\r\n        salt = ... # the one generated above\r\n        iter = 20000\r\n        key_len = cipher.key_len\r\n        digest = OpenSSL::Digest::SHA256.new\r\n\r\n        key = OpenSSL::PKCS5.pbkdf2_hmac(pwd, salt, iter, key_len, digest)\r\n        cipher.key = key\r\n\r\n        # Now decrypt the data:\r\n\r\n        decrypted = cipher.update encrypted\r\n        decrypted << cipher.final\r\n"
        ]
      }
    ]
  }
}