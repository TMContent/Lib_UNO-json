{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "0",
      "Content_Hash": "0"
    },
    "Metadata": [
      {
        "Id": [
          "178b26f6-689b-4a0e-a117-eadf1af3404c"
        ],
        "Id_History": [
          "178b26f6-689b-4a0e-a117-eadf1af3404c,48d7b6bf-8989-47be-9454-033171ce2339,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "Unique Tokens Are Included in HTTP Requests"
        ],
        "Category": [
          "Session Management"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          "Scala Play"
        ],
        "Type": [
          "Checklist Item"
        ],
        "DirectLink": [
          "Unique Tokens Are Included in HTTP Requests"
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "false",
          "DataType": "html"
        },
        "Data": [
          "<h1>Applies to</h1>\n  <p>Scala and Play Framework 2.1.0+<br /></p>\n  <h1>What to Check For</h1>\n  <p>Verify that unique tokens are included in HTTP requests in hidden fields.</p>\n  <h1>Why</h1>\n  <p>CSRF may be possible when an attacker can form a URL, which performs an action on the behalf of an authenticated user. Forming such URLs becomes much more difficult if unique tokens are included in HTTP requests. Including difficult to predict tokens in HTTP requests is an effective defense against CSRF attacks.</p>\n  <h1>How to Check</h1>\n  <p>To verify that unique tokens are included in HTTP requests:</p>\n  <ol>\n    <li>\n      <p>\n        <strong>Identify sensitive operations.</strong>&nbsp;Review application design and code to identify all operations that require authorization.</p>\n    </li>\n    <li>\n      <p>\n        <strong>Identify code that performs sensitive operations.</strong>&nbsp;Identify all pages that are involved in performing sensitive operations - this includes both the pages that link to sensitive operations and the code that actually carries out the sensitive operations.</p>\n    </li>\n    <li>\n      <p>\n        <strong>Examine code that performs sensitive operations.</strong>&nbsp;Review each page that allows calling sensitive operations to make sure that it stores a unique token in a session variable. Review each page that allows calling sensitive operations to make sure that it sends the unique token with the request in a hidden field. Review each page that performs sensitive information to make sure that it validates the unique token.</p>\n    </li>\n  </ol>\n  <h1>How to Fix</h1>\n  <p />\n  <p>To include unique tokens in HTTP requests:</p>\n  <ol>\n    <li>\n      <p>\n        <strong>Identify sensitive operations.</strong>&nbsp;Review application design and code to identify all operations that require authorization.</p>\n    </li>\n    <li>\n      <p>\n        <strong>Identify code that performs sensitive operations.&nbsp;</strong>Identify all pages that are involved in performing sensitive operations - this includes both the pages that link to sensitive operations and the code that actually carries out the sensitive operations.</p>\n    </li>\n    <li>\n      <p />\n      <strong>Choose a method for generating unique tokens.</strong>&nbsp;There are different ways to generate unique tokens.&nbsp;<a href=\"https://github.com/orefalo/play2-authenticitytoken\">Play 2 Authenticity tokens</a>&nbsp;can be used for this purpose. Every form post would contain a hidden parameter containing a signed UUID. Its signature is stored in the session. When the user submits the form, it includes the uuid, the signature and the other form inputs. The validation passes if the signatures match (session.sign=uuid.sign). An attacker would not be able to generate the correct signature, thus protecting the application from a CSRF attack</li>\n    <li>\n      <p />\n      <strong>Add unique tokens to HTTP requests.</strong>&nbsp;Add code that sends the generated unique tokens in HTTP requests to the pages that link to sensitive operations. Adding the authenticity token is trivial: For every form, add @authenticityToken() inside the form elements. For example:<pre>@import _root_.views.html.authtoken.authenticityToken\n\n&lt;form action=\"@routes.Application.process()\" method=\"post\" /&gt;\n   @authenticityToken()\n   Please input your name\n   &lt;input name=\"name\" /&gt;&lt;input type=\"submit\" /&gt;\n&lt;/form&gt;</pre></li>\n    <li>\n      <p />\n      <strong>Add token validation code.</strong>&nbsp;Add code to the pages that carry out sensitive operations to check if the tokens sent in HTTP requests are valid or not. To validate the token, use the @AuthenticityToken Play validator, as follows:<pre>import authtoken.validator.AuthenticityToken;<br /><br />public class FormData {<br /><br />    @AuthenticityToken<br />    public String authtoken;<br /><br />    public String name;<br />}<br /><br />public static Result process() {<br /><br />    Form<formdata> form = form(FormData.class).bindFromRequest();<br /><br />    if (form.hasErrors()) {<br />        return badRequest(\"authenticity validation FAILED\");<br />    } else {<br />        return ok(\"authenticity validation PASSED\");<br />    }<br />}</formdata></pre></li>\n  </ol>\n  <p />\n  <ol>\n  </ol>\n  <h1>Additional Resources</h1>\n  <ul>\n    <li>For information about the OWASP CSRFGuard project, please see&nbsp;<a href=\"https://www.owasp.org/index.php/Category:OWASP_CSRFGuard_Project\">https://www.owasp.org/index.php/Category:OWASP_CSRFGuard_Project</a></li>\n  </ul>\n  <div>\n    <br />\n  </div>"
        ]
      }
    ]
  }
}