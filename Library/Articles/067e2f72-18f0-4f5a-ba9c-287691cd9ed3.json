{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "0",
      "Content_Hash": "0"
    },
    "Metadata": [
      {
        "Id": [
          "067e2f72-18f0-4f5a-ba9c-287691cd9ed3"
        ],
        "Id_History": [
          "067e2f72-18f0-4f5a-ba9c-287691cd9ed3,d57eba16-ea05-41b2-8bb4-a4f107c68413,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "Input Is Validated for Length, Range, Format And Type"
        ],
        "Category": [
          "Input and Data Validation"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          "Scala Play"
        ],
        "Type": [
          "Checklist Item"
        ],
        "DirectLink": [
          "Input Is Validated for Length, Range, Format And Type"
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "false",
          "DataType": "html"
        },
        "Data": [
          "<h1>Applies To</h1>\r\n  <h1>\r\n    <p style=\"font-size: medium; font-weight: normal;\">Applications written using Scala and Play Framework 2.1.0+</p>\r\n  </h1>\r\n  <h1>What to Check For</h1>\r\n  <h1>\r\n    <p style=\"font-size: medium; font-weight: normal;\">Check that all input is validated and treated as untrusted data. Ensure data is validated using whitelisting techniques to check against known good input.</p>\r\n  </h1>\r\n  <h1>Why</h1>\r\n  <h1>\r\n    <p style=\"font-size: medium; font-weight: normal;\">Unchecked malicious input may lead to integer overflows, injection based attacks, denial of service or information disclosure.</p>\r\n  </h1>\r\n  <h1>How to Check</h1>\r\n  <h1>\r\n    <p style=\"font-size: medium; font-weight: normal;\">To check for this problem, use the following steps:</p>\r\n    <ol style=\"font-size: medium; font-weight: normal;\">\r\n      <li>\r\n        <p>\r\n          <strong>Find all input sources.&nbsp;</strong>During design time, identify all of the potential input sources to your application. Scour the source code to discover sources of input that may have been missed in the design. The most common sources are:</p>\r\n        <ul>\r\n          <li>URL based parameters</li>\r\n          <li>Form based parameters</li>\r\n          <li>Hidden fields</li>\r\n          <li>Cookies</li>\r\n          <li>HTTP headers (Host, accept types, www authentication, cache settings, encodings, etc)</li>\r\n          <li>Local filesystem</li>\r\n          <li>Database</li>\r\n          <li>Other services running on the system</li>\r\n          <li>Javascript variables</li>\r\n          <li>File upload and attributes (filename, size, data, etc)</li>\r\n          <li>DNS results or host names</li>\r\n          <li>External component call return values (AJAX, etc)</li>\r\n        </ul>\r\n      </li>\r\n      <li>\r\n        <p>\r\n          <strong>Trace data from source to sink.&nbsp;</strong>Trace each source of input through your application until you find its ultimate destination. The final sink may be in memory, on the hard drive, sent over the network or stored in a data store such as a database.</p>\r\n      </li>\r\n      <li>\r\n        <p>\r\n          <strong>Identify validation routines.&nbsp;</strong>Each input source should have a data validation routine associated with it. Ideally the validation will occur as soon as the input reaches your application. Shared validation routines are better than creating many spread throughout your code base, so check for consolidation of routines to aid testing and reduce the chance of one-off bugs. If an input source does not have a validation routine associated with it, flag it for fixing.</p>\r\n      </li>\r\n      <li>\r\n        <p>\r\n          <strong>Ensure quality of validation routines.&nbsp;</strong>Validation routines should check for length, range, format and type.</p>\r\n        <ul>\r\n          <li>Validation routines should check for known good data and constrain input against each of the four categories: length, range, format and type.</li>\r\n          <li>In web applications, look for application-supplied validators, such as a Custom Scala Validator, to validate and constrain input after it is received from an input source.</li>\r\n          <li>Ensure that all numeric fields are validated for type and range. Check for the use of regular expressions and&nbsp;<strong>scala.util.matching</strong>&nbsp;or the use of a validator that checks numeric ranges by converting the input value to an integer or double and then performing a range check.</li>\r\n          <li>Check that validators validate input against the least permissive expression possible that will accept all the input expected for that field.</li>\r\n          <li>If you know that the field will have a certain internal structure, ensure that is checked for.</li>\r\n          <li>If the input has an internal checksum, like a credit card number, ensure that is checked.&nbsp;<br /><br />Validation should check first for whitelisted data, ie, known valid, safe data, and then for blacklisted data, ie, malicious, dangerous data. Do not rely only on filtering out malicious data as it is too easy to miss something. Validate on the server--do not rely on client-side validation alone as it can be easily bypassed.</li>\r\n        </ul>\r\n      </li>\r\n    </ol>\r\n    <blockquote style=\"font-size: medium; font-weight: normal;\">\r\n      <p>\r\n        <strong>Options for Constraining and Sanitizing Data</strong>\r\n      </p>\r\n      <table>\r\n        <tbody>\r\n          <tr>\r\n            <th>Requirement</th>\r\n            <th>Options</th>\r\n          </tr>\r\n          <tr>\r\n            <td>Type checks</td>\r\n            <td>Regular expressions (<strong>scala.util.matching</strong><strong>.regex</strong>)<p>Scala type system</p></td>\r\n          </tr>\r\n          <tr>\r\n            <td>Length checks</td>\r\n            <td>Regular expressions (<strong>scala.util.matching</strong><strong>.regex</strong>)<br /><p><i><b>play.api.data.validation</b></i>&nbsp;object</p><p>Custom Scala&nbsp;<strong>Validator</strong></p></td>\r\n          </tr>\r\n          <tr>\r\n            <td>Format checks</td>\r\n            <td>Regular expressions for pattern matching (<strong>Pattern</strong>,&nbsp;<strong>Matcher</strong>)<p>Scala type system</p><p><i><b>play.api.data.validation</b></i>&nbsp;object</p></td>\r\n          </tr>\r\n          <tr>\r\n            <td>Range checks</td>\r\n            <td>Custom Scala&nbsp;<strong>Validator</strong><p>Typed data comparisons</p><p><i><b>play.api.data.validation</b></i>&nbsp;object</p></td>\r\n          </tr>\r\n        </tbody>\r\n      </table>\r\n    </blockquote>\r\n  </h1>\r\n  <h1>How to Fix</h1>\r\n  <h1>\r\n    <p style=\"font-size: medium; font-weight: normal;\">Input can vary in length, data type, and content. Validate that all input meets your application's expectations.</p>\r\n    <ol style=\"font-size: medium; font-weight: normal;\">\r\n      <li>\r\n        <p />\r\n        <strong>Validating length</strong>: Your application should check a string's length or the number of bits in a numeric value. Checking the length can help prevent buffer overflows as well as integer overflows in numeric values. A simple way to validate the numeric value for forms is through the use of&nbsp;<i>minLength(length: Int)</i>&nbsp;and<i>&nbsp;maxLength(length: Int)</i>&nbsp;from the&nbsp;<i>play.api.data.validation</i>&nbsp;constraints object of Play Framework:<pre>object SignUp extends Controller {\r\n  \r\n  /**\r\n   * Sign Up Form definition.\r\n   */\r\n  val signupForm: Form[User] = Form(\r\n    \r\n    // Define a mapping that will handle User values\r\n    mapping(\r\n      \"firstname\" -&gt; text(maxLength = 20),\r\n      \"lastname\" -&gt; text(maxLength = 20),\r\n      \"username\" -&gt; text(minLength = 4),\r\n      \"password\" -&gt; text(minLength = 6),   \r\n      // Create a tuple mapping for the password/confirm\r\n      \"password\" -&gt; tuple(\r\n        \"main\" -&gt; text(minLength = 6),\r\n        \"confirm\" -&gt; text\r\n      ),\r\n\r\n    )\r\n  )\r\n  }</pre>Also, you can validate any numeric value through the use of<font color=\"#ff0000\"></font>&nbsp;BigInt/BigDecimal as follows:&nbsp;<pre>def productcheck = Action { implicit request =&gt;\r\n    prodForm.bindFromRequest.fold(\r\n      errors =&gt; BadRequest(views.html.index(errors, \"There is some error\")),\r\n      prodForm =&gt; {\r\n\r\n        val proname = prodForm.pname\r\n        val prodprice = prodForm.price\r\n        if(prodprice.compare(BigInt(0)) &gt; -1\r\n          && prodprice.compare(BigInt(Integer.MAX_VALUE)) \r\n        {\r\n          println(\"true\")\r\n          ............ //code for true\r\n        }\r\n        else\r\n        {\r\n          println(\"false\")\r\n          ............ // code for exception\r\n        }</pre></li>\r\n      <li>\r\n        <p />\r\n        <strong>Validating type</strong>:&nbsp;Validating the input's data type is important when your application expects a specific non-string parameter. Difference in data type can trigger unhandled exceptions that would throw your application into an unknown state. The following is an example of validating in forms:<pre>object ContactForm extends Controller {\r\n  \r\n  /**\r\n   * Contact Form definition.\r\n  */\r\n  val appointmentMapping = tuple(\r\n  \"location\" -&gt; text,\r\n  \"start\" -&gt; tuple(\r\n    \"date\" -&gt; date,\r\n    \"time\" -&gt; text),\r\n  \"attendees\" -&gt; list(mapping(\r\n    \"name\" -&gt; text,\r\n    \"email\" -&gt; email)\r\n)}</pre></li>\r\n      <li>\r\n        <strong>Validating contents</strong>: Use whitelist and blacklist techniques to validate the input's contents, based on the constraints that are imposed on the input: If the input follows a tight structure and format, you can use whitelisting alone to weed out malicious input. If there are unknowns about the input, you'll need a combination of whitelisting and blacklisting. In general, use blacklisting as a backup to whitelisting, through a spiral-out approach: Use whitelisting for the initial validation. If whitelisting cannot validate the input, then fall back to blacklisting. If blacklisting cannot validate, then discard the input. The following is an example of implementing this technique using forms:<pre>object ValidateProduct extends Controller {\r\n\r\n  val productForm = Form(mapping(\r\n    \"ean\" -&gt; longNumber.verifying(\"This product already exists!\", Product.findByEan(_).isEmpty),\r\n    \"name\" -&gt; nonEmptyText,\r\n    \"description\" -&gt; text,\r\n    \"pieces\" -&gt; number,\r\n    \"active\" -&gt; boolean)(Product.apply)(Product.unapply).verifying(\r\n      \"Product can not be active if the description is empty\", product =&gt;\r\n        !product.active || product.description.nonEmpty))\r\n}</pre><p>Using regular expressions, the fix would be as below:</p><p /><pre>val pid = ProductForm.productid\r\nval pname = ProductForm.productname\r\nval products = Product.findProduct(pid, pname)\r\nval whitelistPattern = \"(\\\\w|\\\\d)+\".r\r\nval issafe =whitelistPattern.pattern.matcher(pname).matches</pre><pre>if (issafe){</pre><pre>...... //Code for Action</pre><pre>}else{</pre><pre>...... //Code for Exception</pre><pre>}</pre><pre><br /></pre><p>Examples of useful regular expressions:</p><p /><table><tbody><tr><td>Use</td><td>Regular Expression</td><td>Scala String</td></tr><tr><td>Valid E-Mail Address</td><td>^\\w+(\\.|_|-){0,1}\\w+@(\\w+\\.)*\\w{3,1024}\\.([a-zA-Z]{2}\\.){0,1}[a-zA-Z]{2,4}$</td><td>^\\\\w+(\\\\.|_|-){0,1}\\\\w+@(\\\\w+\\\\.)*\\\\w{3,}\\\\.([a-zA-Z]{2}\\\\.){0,1}[a-zA-Z]{2,4}$</td></tr><tr><td>Alpha-numeric free text</td><td>(\\w|\\d|\\s|;|\\?|!|,|\\.|-|:)+</td><td>(\\\\w|\\\\d|\\\\s|;|\\\\?|!|,|\\\\.|-|:)+</td></tr><tr><td>Word characters</td><td>\\w+</td><td>\\\\w+</td></tr><tr><td>Numbers</td><td>\\d+</td><td>\\\\d+</td></tr></tbody></table></li>\r\n    </ol>\r\n  </h1>\r\n  <h1>Additional Resources</h1>\r\n  <h1>\r\n    <ul style=\"font-size: medium; font-weight: normal;\">\r\n      <li>A tutorial on regular expressions is available at&nbsp;<a href=\"http://www.regular-expressions.info/\">Regular-Expressions.info</a>.</li>\r\n      <li>For more information on using regular expression in Scala, see: Documentation for&nbsp;<a href=\"http://www.scala-lang.org/api/current/index.html#scala.util.matching.Regex\">Regex Pattern</a>&nbsp;in Scala documentation.</li>\r\n    </ul>\r\n  </h1>\r\n  <br />\r\n  <div>\r\n    <ul style=\"margin: 10px 0px 10px 25px; padding: 0px 0px 0px 30px; font-family: 'Segoe UI', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: small;\">\r\n    </ul>\r\n  </div>"
        ]
      }
    ]
  }
}