{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "0",
      "Content_Hash": "0"
    },
    "Metadata": [
      {
        "Id": [
          "7d0bc73e-2ce1-4e5b-ac93-04349672993a"
        ],
        "Id_History": [
          "7d0bc73e-2ce1-4e5b-ac93-04349672993a,5a755ccf-074d-422e-810a-2c2429ca5aeb,"
        ],
        "Library_Id": [
          "d9c2b53f-5b05-4152-be72-e79d72854707"
        ],
        "Title": [
          "Assume All Input Is Malicious"
        ],
        "Category": [
          "Input and Data Validation"
        ],
        "Phase": [
          "Design"
        ],
        "Technology": [
          "Web Application"
        ],
        "Type": [
          "Guideline"
        ],
        "DirectLink": [
          "Assume All Input Is Malicious"
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "false",
          "DataType": "html"
        },
        "Data": [
          "<h1>Applies to</h1>\n  <ul>\n    <li>Web Application</li>\n  </ul>\n  <h1>What to Do</h1>\n  <p>Applications should assume that all of their input is malicious, and take action accordingly.&nbsp; Input should&nbsp;be validated and either rejected or sanitized immediately, carefully quarantined during use, and encoded appropriately on output.</p>\n  <h1>Why</h1>\n  <p>Malicious input is the single largest cause of vulnerabilities in web applications, and, in the most general sense, is the root cause of almost every issue.&nbsp; The only way to ensure safety is by a defense in depth, default deny policy that starts with the fundamental supposition that all input is malicious until proven otherwise. For example, if you call an external Web service that returns strings, how do you know that malicious commands are not present? Also, if several applications write to a shared database, when you read data, how do you know whether it is safe?</p>\n  <h1>When</h1>\n  <p>All applications should assume that all their input is malicious.</p>\n  <h1>How</h1>\n  <p>Getting input validation correct is tricky; there's a reason that it's the number one security problem for web applications.&nbsp; However, when approached systematically, it's not too hard of a&nbsp;problem to solve.&nbsp; Follow these steps:</p>\n  <h2>1. Determine all inputs</h2>\n  <p>The first step is to determine all the things in the application which can be controlled by the user. There are some surprises here -- a lot of the variables in a normal HTTP server environment are actually taken from the user's request, so make sure you know exactly where everything is coming from. It's a good idea to leave a brief comment in the code where the input comes in mentioning where it comes from (if it isn't obvious from context), the expected format, and where it's validated (again, if it isn't obvious).</p>\n  <h2>2. Determine all trusted data stores</h2>\n  <p>Every application has at least one, usually multiple data stores.&nbsp; It's important to know when a data store can be trusted.&nbsp; The guideline here is simple: if the system in question is the only input into the data store, then you can rely on the semantics enforced by your input validation routines to apply to all data found in the store.&nbsp; If other applications access the data store, then you can't.&nbsp; While it is possible to check the semantics of every validation routine in every other system that accesses the data store, it's simpler and safer to assume that the data store is untrusted, and treat it as a potential source of malicious data, validating all input from it as you would any other input.</p>\n  <h2>3. Determine all crossover points</h2>\n  <p>A crossover point is anywhere where user input is included textually in \nsome larger body of command text, or where a security-relevant decision \nis made based on it. A good example of a crossover point is a dynamic \nSQL query. Note that output may or may not occur at a crossover point; often, crossover points occur many layers deep within a large application.&nbsp;&nbsp; <br /></p>\n  <p>The risk here is of the user input crossing over into the \nassociated command data, allowing an attacker to execute commands.&nbsp; <br /></p>\n  <p>In addition to the above injection attacks, Xpath and other XML injections are another examples. The worst case here is when user input is evaluated by a language's built-in \"eval\" command or something similar -- these commands<font color=\"#ff0000\">&nbsp;</font>should never be used, even with values that look safe, because of the possible risks of server compromise or sensitive information disclosure.</p>\n  <p>Determine all crossover points. Then, trace all inputs back to make sure that they've been validated appropriately, and insert a comment stating the format, source, and validation point of the input.&nbsp; Depending on the technology involved, all crossover points have different sets of safe characters.&nbsp; Using the whitelist approach, compare the safe set of characters for that crossover point against what the validator will allow through. The allowed characters must be a subset of the safe ones. <br /></p>\n  <p>Whenever possible, remove crossover points entirely.&nbsp; For example, switching from dynamic SQL to stored procedures with bound parameters removes an entire category of crossover points from the system, and greatly reduces risk to an entire class of attacks.&nbsp; Seek out similar ways to eliminate other types of crossovers.</p>\n  <h2>4. Determine all outputs</h2>\n  <p>The last point of concern is the list of outputs from the system.&nbsp; This will likely have a certain amount of overlap with the list of crossover points, which is fine.&nbsp; Determine the allowable format for each output, and look at where the associated input is being validated.&nbsp; If there's a possibility that the input may contain dangerous characters, encode it in a manner appropriate to the specific output.&nbsp; There are more output contexts than you might think: the contents of HTML attributes, the tags themselves, free text between the tags, and JavaScript strings all have different sets of safe characters (and a different encoding, in the last case).&nbsp; Insert a comment on the input source, format, validation point, and encoding point of each output.</p>\n  <h2>5. Build a centralized validation module</h2>\n  <p>One of the biggest dangers of implementing input validation is inconsistent validation. An attack may be caught on one data path, but not on another; an attacker, however, will try all of them.&nbsp; The way to solve this problem is to have a single point of responsibility for input validation.&nbsp; Its location depends on the design.&nbsp; If every piece of input is an object, then it may be appropriate to have the object constructs and setters perform the validation for that object's input.&nbsp; In a less strictly object oriented system, a single module with methods for each different input format may be more appropriate.</p>\n  <p>Whichever method you choose, use very strict input validation routines for each data type.&nbsp; For example, for a US zip code, allow either 5 or 9 numbers, and nothing else.&nbsp; For international postal codes, either validate them separately with a looser format that also allows letters, or, to ensure a higher level of integrity, build a more complex validator that recognizes the postal codes of each nation.</p>\n  <h2>6. Build a centralized encoding module</h2>\n  <p>In an ideal world, all encoding routines would be done via the same libraries that are used to create output.&nbsp; While many HTML control libraries attempt this, none of them take the whitelist approach.&nbsp; Instead, they try to guess which characters might be harmful, a list that is categorically incomplete.&nbsp; Unless you want to build a new output library (which might be an option on a large enough application), you should build a set of data encoders for each output context that you have.&nbsp; Use these encoders as close as possible to the actual point of output; this minimizes the chance that an alternate data path will skip the encoding, and ensures that the developer knows exactly in what context the output is being used.&nbsp; Avoid the temptation to store encoded data, because even if it is initially only used in the context for which you encoded it, this may change over time.</p>\n  <h2>7. Ensure that all paths through the system preserve validation</h2>\n  <p>Once the validation system is complete, check all the paths that data takes through the system to ensure that they preserve the expected validation properties.&nbsp; Input that is sent round-trip through a client or another system must be re-validated, unless a cryptographic signature is used to ensure that it has not been tampered with.&nbsp; Validation that occurs on an untrusted system must also be repeated.&nbsp; Client-side validation in JavaScript is a nice UI touch, but it is <i>not</i> a security measure, as it is trivial to circumvent.</p>\n  <h1>Problem Example</h1>\n  <p>A suite of web applications on an e-commerce site share a common back-end database.&nbsp; The largest application is&nbsp;the&nbsp;order-entry system and shopping cart.&nbsp; This was the first application built, and was designed with the assumption that the database was trusted.&nbsp; Later, a lightweight app to allow users to quickly check stock levels was built.&nbsp; Because it was a small \"read-only\" use of the database, input validation was not built into the application.&nbsp; The application contained a SQL injection, allowing an attacker to alter the database in such a way that they could&nbsp;inject JavaScript into pages which displayed the shopping cart application and steal user's passwords.&nbsp;</p>\n  <h1>Solution Example</h1>\n  <p>A suite of web applications on an e-commerce site share a common back-end database.&nbsp; The largest application is&nbsp;the&nbsp;order-entry system and shopping cart.&nbsp; This was the first application built, and was designed with the assumption that the database was trusted.&nbsp; Later, a lightweight app to allow users to quickly check stock levels was built.&nbsp;&nbsp;When the new application was added, the developers realized that the database could no longer be treated as a trusted data store, and added code to the main application to perform data validation on input from the database.&nbsp;&nbsp;&nbsp;Because the new application was a small \"read-only\" use of the database, the input validation routines written were not properly checked.&nbsp; When an attacker found a SQL injection via the new application and altered the back-end database, they were unable to make that attack chain go through to the main application.&nbsp; Furthermore, the logging performed by the main application's data validation routines alerted the operations group to the problem, allowing them to fix the smaller application.</p>\n  <h1>Additional Resources</h1>\n  <ul>\n    <li>For more information see, \"Chapter 4 - Design Guidelines for Secure Web Applications\" at&nbsp;<a href=\"http://msdn2.microsoft.com/en-us/library/aa302420.aspx\">http://msdn2.microsoft.com/en-us/library/aa302420.aspx</a></li>\n  </ul>\n  <hr />\n  <p>Adapted from Microsoft patterns & practices guidance.</p>"
        ]
      }
    ]
  }
}