{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "0",
      "Content_Hash": "0"
    },
    "Metadata": [
      {
        "Id": [
          "40ed1ed0-8081-4675-9e8e-8b83ffbfd7b9"
        ],
        "Id_History": [
          "40ed1ed0-8081-4675-9e8e-8b83ffbfd7b9,70234fd5-ba73-4207-a881-176e9e7da22b,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "Accounts Are Locked After Consecutive Failed Login Attempts"
        ],
        "Category": [
          "Authentication"
        ],
        "Phase": [
          "Design"
        ],
        "Technology": [
          "Scala Play"
        ],
        "Type": [
          "Checklist Item"
        ],
        "DirectLink": [
          "Accounts Are Locked After Consecutive Failed Login Attempts"
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "false",
          "DataType": "html"
        },
        "Data": [
          "<h1>Applies to</h1>\n  <p>Scala and Play Framework 2.1.0+<br /></p>\n  <h1>What to Check For</h1>\n  <p>Ensure that accounts&nbsp;are locked after consecutive failed login attempts.</p>\n  <h1>Why</h1>\n  <p>Multiple, consecutive failed login attempts over a short time period can sometimes be a symptom of an attack. Locking the account will prevent the attacker from continuing the break-in attempt.</p>\n  <h1>How to Check</h1>\n  <p>To ensure your application will lock an account after consecutive failed login attempts:</p>\n  <ol>\n    <li>\n      <p>\n        <strong>Verify that your application has a lockout policy.&nbsp;</strong>An account lockout policy is typically application specific. Review your application's requirements and design specifications and verify the&nbsp;following functionality:</p>\n      <ul>\n        <li>A mechanism to determine failed login attempts.</li>\n        <li>A mechanism to specify an allowed number of login attempts.<br /></li>\n        <li>A mechanism to lock accounts that have exceeded the allowed number of login attempts.</li>\n        <li>A mechanism to unlock these accounts.<br /></li>\n      </ul>\n    </li>\n    <li>\n      <p>\n        <strong>Verify that your application tracks login attempts for each user. </strong>Ensure that all authentication procedures track the number of login attempts, and that the login counter is reset to 0 upon a successful login.</p>\n    </li>\n    <li>\n      <p>\n        <strong>Verify that your application enforces the lockout policy. </strong>Ensure that all authentication procedures enforce your application's lockout policy. The implementation should&nbsp;match the lockout policy per the business requirements of your organization, which may change over time.</p>\n    </li>\n  </ol>\n  <blockquote>\n    <p>\n      <strong>Note &nbsp;</strong> PCI DSS certification requires that logs must include failed login attempts, and that an account must be locked for at least 30 minutes after no more than six failed login attempts.</p>\n  </blockquote>\n  <h1>How to Fix</h1>\n  <p>To successfully lock accounts after consecutive failed login attempts:</p>\n  <ol>\n    <li>\n      <p>\n        <strong>Determine a lockout policy. </strong>There are two variables to consider when determining a lockout policy:</p>\n      <ul>\n        <li>Number of allowed consecutive failed login attempts</li>\n        <li>Amount of time that a locked account will remain locked</li>\n      </ul>\n      <p>A\n simple policy would be to lock an account after&nbsp;five failed login \nattempts for the duration of 15 minutes. Although this is an effective \nmethod for blocking a brute force attack, it exposes your application to\n denial of service as an attacker can easily keep an account locked \nthrough a small stream of authentication requests.<br /><br />When \ndetermining the lockout policy, it is important to evaluate the risk of \nattacks against the user and the support costs associated with \nreactivating a locked account. For example, requiring the user to \ncontact your organization's support staff&nbsp;to reactivate a locked account\n will have a direct impact on support costs and would add general user \nfrustration.&nbsp;However, it is important to use extra care when designing \nmore sophisticated variations of your application's lockout policy, such\n as correlating a single or multiple user login attempts with a source \nIP. When adding extra levels of complexity, carefully consider and \nevaluate the scenarios where your application's lockout policy can be \ncircumvented or can harm your business. For instance, consider scenarios\n where an attacker would attempt to compromise a user through the use of\n multiple hosts, or multiple users would authenticate using a shared \noffice IP.</p>\n    </li>\n    <li>\n      <p>\n        <strong>Track login attempts. </strong>Use a login counter. Increment the counter when a user tries to log in. Reset the counter to 0 after a successful login. Example:</p>\n      <pre>-- Authenticate the user<br />sql&gt; select login_attempts from users<br />      where user = {{username}} and pass = {{passDigest}};<br /> -- Reset the login counter<br />sql&gt; update users set login_attempts = 0 where user = {{username}};</pre>\n    </li>\n    <li>\n      <p>\n        <strong>Enforce the lockout policy. </strong>Enforce the policy at all points in the application where authentication is necessary. Example:</p>\n      <pre>String dbStatement = \"select login_attempts from users\"<br />                   + \"where user = ? and pass = ?;\";<br />PreparedStatement st = dbConnection.prepareStatement(dbStatement);<br />st.setString(1, user);st.setString(2, passDigest);<br />ResultSet rs = st.executeQuery();<br /><br />if (rs.first())<br />{      <br />userIsValid = true;<br />      loginCount = rs.getInt(1);<br />}<br />else<br />{<br />      userIsValid = false;<br />}<br /><br />rs.close();<br /><br />if(userIsValid)<br />{<br />      if(loginCount &gt; 3)<br />      {<br />            throw new AccountIsLockedException();<br />      }<br /><br />      // The application checks the password's maturity<br />      checkPasswordMaturity(user);<br />}<br />else<br />{<br />      updateLastLoginAttempt(user);<br />}</pre>\n    </li>\n    <li>\n      <p>\n        <strong>Set an unlocking mechanism.&nbsp;</strong>Keep track of the lockout period. Based on your application's lockout \npolicy, unlock the account after the lockout period has expired. Example:</p>\n      <pre>-- Unlock all locked accounts whose 45 minute lockout period has expired<br />sql&gt; update users set login_attempts = 0<br />      where last_login </pre>\n    </li>\n  </ol>\n  <blockquote>\n    <p>\n      <strong>Note &nbsp;</strong> PCI DSS requirements state that an account must be locked for at least 30 minutes after no more than six failed login attempts.</p>\n  </blockquote>\n  <h1>Problem Example</h1>\n  <p>The following code executes the database transaction required during authentication. Because the transaction fails to check the login counter, it is possible for an attacker to compromise an account through the use of a brute force or a dictionary attack.</p>\n  <pre>// The application fails to check the number of login attempts<br />String dbStatement = \"select user from users where user = ? and pass = ?;\";<br />st = dbConnection.prepareStatement(dbStatement);<br />st.setString(1, user);<br />st.setString(2, passDigest);<br />rs = st.executeQuery();</pre>\n  <h1>Solution Example</h1>\n  <p>The following code executes the database transaction required during authentication. Because the transaction checks the login counter, it would be very expensive for an attacker to compromise an account through the use of a brute force or a dictionary attack. <br /></p>\n  <pre>// The application checks the number of login attempts<br />String dbStatement = \"select login_attempts from users where user = ? and pass = ?;\";<br />PreparedStatement st = dbConnection.prepareStatement(dbStatement);<br />st.setString(1, user);<br />st.setString(2, passDigest);<br />ResultSet rs = st.executeQuery();<br /><br />if (rs.first())<br />{<br />      userIsValid = true;<br />      loginCount = rs.getInt(1);<br />}<br />else<br />{<br />      userIsValid = false;<br />}<br /><br />rs.close();<br /><br />if(userIsValid)<br />{<br />      if(loginCount &gt; 3)<br />      {<br />            throw new AccountIsLockedException();<br />      }<br />      checkPasswordMaturity(user);<br />}<br />else<br />{<br />      updateLastLoginAttempt(user);<br />}</pre>\n  <br />"
        ]
      }
    ]
  }
}