{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "0",
      "Content_Hash": "0"
    },
    "Metadata": [
      {
        "Id": [
          "60e358de-01d1-480a-8693-23aec03297e2"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "Cryptographic Storage"
        ],
        "Category": [
          ""
        ],
        "Phase": [
          ""
        ],
        "Technology": [
          ""
        ],
        "Type": [
          ""
        ],
        "DirectLink": [
          ""
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "false",
          "DataType": "wikitext"
        },
        "Data": [
          "Attention is often paid to data when it is in transit, but the safety and sustainability should also be ensured when it is at rest. Storing data with a proper form of encryption provides an extra layer of security even if attackers are able to access the encrypted data. If a data breach does occur, the information will be harder or even impossible to use if it is stored securely. View this room to learn the proper way to store data and ensure its integrity even when it is not being accessed.\n\n==Use Iterative Hashing to Protect Stored Passwords==\n\nStoring hashes instead of plain-text passwords assures that an attacker cannot easily recover the passwords if he gains access to the password files. Adding salt to hashed files makes hashes much harder to break with dictionary attacks. Hashing should be applied multiple times to make hashing take longer and thus increase the computational resources required to attack the hashes. Iterative hashing applies a hashing function multiple times to a password and a salt, drastically increasing the time required to perform dictionary attacks.\n\n* [[6e0918c1-90db-46d5-9f0e-8a98ddbcd7d5|Java]]\n* [[62593693-31c2-441a-b6f8-4fc47acac06d|PHP]]\n\n==Use Strong Cryptographic Algorithms==\n\nAs commercially available computing power rapidly increases and new threats emerge, it becomes more and more important to use strong cryptographic algorithms to secure sensitive data. Strong cryptographic algorithms assure that an attacker cannot break encryption in a timely manner.\n\n* [[1734c6d5-8c96-42ad-89a5-b858d7258f55|Any]]\n\n==Use Strong Keys==\n\nUse strong encryption keys to make your encryption hard to break. The strength of the encryption keys used is one of the major factors determining the overall strength of a cryptographic solution.\n\n* [[58b12785-2ca7-48b0-89c5-8bee7aaa1cf8|Any]]\n* [[a7f6ef97-eec1-4832-ad2c-ff67c9bb3a57|.NET]]\n* [[294e468f-1774-49f2-a5f8-8d7943f8658d|Java]]\n* [[c0e94eb7-79a2-4602-9bf5-0a446689510f|PHP]]\n\n==Minimize Sensitive Data in Memory==\n\nSensitive data residing in memory for more time than is strictly necessary is at high risk to be swapped out to disk. This could leave fragments of data available well after the application has terminated. Such data may be gathered by inspecting the contents of the disk, temporary files or the swap file.\n\n* [[ffa14c84-64d3-42db-9a48-73e4a9ce1877|.NET]]\n* [[53c570b1-0628-404e-ae77-7045b05d6f33|C++]]\n\n==Do Not Cache Sensitive Data==\n\nIf the cached sensitive data is not encrypted, it might become an easy target for attackers.\n\n* [[c52a1216-5e56-48a1-8f06-b2524c6c35d4|WCF]]\n* [[e3bdbea7-92cb-4407-998a-eaa95cb955e9|Java]]\n* [[f9d523ec-7328-4be5-93c6-00e671ecd068|Scala]]\n\n==Protect Encryption Keys==\n\nProtect the encryption keys to prevent your encrypted data from being compromised. If the encryption keys are stored together with the data, then an attacker may be able to get the keys together with the data and then use them to decrypt the data. Therefore, keeping the keys together with the encrypted data defeats the purpose of encrypting the data.\n\n* [[00000000-0000-0000-0000-00000060ef71|.NET]]\n* [[1057099e-dd79-4f41-8b7e-36f00f1343e4|Java]]\n* [[00000000-0000-0000-0000-0000003480b5|PHP]]\n* [[b017f172-171b-4aa3-96d4-47cbaaf362e2|C++]]\n\n==Use a Strong PRNG==\n\nMost common encryption algorithms rely on difficult to predict random numbers to be used properly. The level of difficulty to predict or enumerate the output of a random number generator is called its entropy. Cryptographically strong PRNGs are software algorithms that produce pseudo-random numbers considered to have sufficient entropy to be suitable for use in cryptography.\n\n* [[603cc670-a592-486e-8e85-629f2d9e531e|Java]]\n* [[c38d8837-682c-4b0b-bde3-3530053fb1c0|PHP]]\n\n[[bcbbe5c7-95c3-468d-9371-6eb42f9b93e6|Back to the Programming Best Practices Area]]"
        ]
      }
    ]
  }
}