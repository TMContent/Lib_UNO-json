{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "0",
      "Content_Hash": "0"
    },
    "Metadata": [
      {
        "Id": [
          "48f6c35c-1b24-4497-b344-56827c92573f"
        ],
        "Id_History": [
          "48f6c35c-1b24-4497-b344-56827c92573f,95468457-982f-49a4-9e7b-e6d85929b128,"
        ],
        "Library_Id": [
          "c037d0d2-0617-44f3-b846-21dc3d02c4f8"
        ],
        "Title": [
          "Uploaded Files Are Stored Outside of Web Root"
        ],
        "Category": [
          "File I/O"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          "PHP"
        ],
        "Type": [
          "Checklist Item"
        ],
        "DirectLink": [
          "Uploaded Files Are Stored Outside of Web Root"
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "false",
          "DataType": "wikitext"
        },
        "Data": [
          "==Applies To==\n\n* PHP\n\n==What to Check For==\n\nVerify that uploaded files are stored in a location that is not web accessible.\n\n==Why==\n\nStoring uploaded files in a location that is not web accessible prevents shell upload vulnerabilities. Even if an attacker manages to upload a malicious script, they won't be able to execute it if the malicious script is stored in a location that is not accessible from the web.\n\n==How to Check==\n\nTo verify that uploaded files are stored in a location that is not web accessible:\n\n# **Determine where the application stores uploaded files.** Examine the application design and file structure to determine where the application stores uploaded files. Uploaded files might be stored in a database, in which case they won't show up on the filesystem, and storing files in a database passes this checklist item.\n# **Verify that the location where uploaded files are stored is not web accessible.** If uploaded files are stored on the filesystem, determine their relative path in the application. Attempt to access some uploaded files and the uploads directory using HTTP requests on a deployed application. \n\n==How to Fix==\n\nTo store uploaded files in a location that is not web accessible:\n\n# **Find all code used to upload files.** Search your application code for calls to move_uploaded_files(). Make a spreadsheet of this code. \n# **Determine where to store uploaded files.** It's possible to store uploaded files in a folder outside of the web root or in a database.\n## Storing uploaded files outside the web root is a strong and easy to implement measure. However, it makes installing the application on a large amount of servers slightly more difficult, because the servers then need to be configured to allow storing files outside of the web root by creating a folder to store the uploaded files and granting the web server permissions to write to that folder. This additional configuration work is why many commercial applications store uploaded files in a web accessible location, and subsequently suffer from shell upload vulnerabilities. \n## Files stored in a database cannot be accessed directly via HTTP requests, so even if an attacker is able to upload a shell, they won't be able to access it. If the application is already using a database, there is no additional end-user configuration required. However, this method is harder to code, and there is some maintenance overhead because the database and backups might become quite large. \n# **Change code to store uploaded files outside web root.** Change each piece of code that is used to handle uploaded files so that the uploaded files are stored in the chosen location that is not accessible from the web. In the application installation instructions, document any special server configuration settings required to protect the uploads directory, and explain the risks of not protecting it. The main risk is that a web accessible uploads directory makes it easier for attackers to upload malicious code.\n"
        ]
      }
    ]
  }
}