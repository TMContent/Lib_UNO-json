{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "0",
      "Content_Hash": "0"
    },
    "Metadata": [
      {
        "Id": [
          "19f2779c-14ec-43fb-8e8d-4505cb0801c9"
        ],
        "Id_History": [
          "19f2779c-14ec-43fb-8e8d-4505cb0801c9,fc26c955-5914-4baa-a35c-dfcd37b03d78,"
        ],
        "Library_Id": [
          "be5273b1-d682-4361-99d9-6234f2d47eb7"
        ],
        "Title": [
          "Include Unique Tokens in HTTP Requests"
        ],
        "Category": [
          "Session Management"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          "Scala Play"
        ],
        "Type": [
          "Guideline"
        ],
        "DirectLink": [
          "Include Unique Tokens in HTTP Requests"
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "false",
          "DataType": "html"
        },
        "Data": [
          "<h1>Applies to</h1>\r\n  <p>Scala and Play Framework 2.1.0+</p>\r\n  <h1>What to Do</h1>\r\n  <p>Include unique tokens in HTTP requests when performing sensitive operations to prevent Cross-Site Request Forgery (CSRF).</p>\r\n  <h1>Why</h1>\r\n  <p>Unique tokens in HTTP requests help prevent CSRF attacks. An attacker who does not have the unique token will not be able to successfully form a URL that can carry out a malicious action on the behalf of an authenticated user. <br /></p>\r\n  <h1>How</h1>\r\n  <p>To include unique tokens in HTTP requests:</p>\r\n  <ol>\r\n    <li>\r\n      <p>\r\n        <strong>Identify sensitive operations.</strong>&nbsp;Review application design and code to identify all operations that require authorization.</p>\r\n    </li>\r\n    <li>\r\n      <p>\r\n        <strong>Identify code that performs sensitive operations.&nbsp;</strong>Identify all pages that are involved in performing sensitive operations. This includes both the pages that link to sensitive operations and the code that actually carries out the sensitive operations.</p>\r\n    </li>\r\n    <li>\r\n      <p />\r\n      <strong>Choose a method for generating unique tokens.</strong>&nbsp;There are different ways to generate unique tokens. In Play Framework, use a <a href=\"https://github.com/orefalo/play2-authenticitytoken\">Play 2 Authenticity token</a>\r\n for this purpose.&nbsp; Every form post will contain a hidden parameter \r\ncontaining a UUID. The UUID is signed and its signature is stored in the\r\n session. When the user submits the form, it includes the UUID and the \r\nsignature. The validation passes if the signatures match: <font face=\"Courier New\">session.sign=uuid.sign</font>.\r\n An attacker who does not have the token cannot generate the correct \r\nsignature. This protects the application from a CSRF attack. </li>\r\n    <li>\r\n      <p />\r\n      <strong>Add unique tokens to HTTP requests.</strong>&nbsp;Add code that sends\r\n the generated unique tokens in HTTP requests to the pages that link to \r\nsensitive operations. Adding the authenticity token is trivial: For \r\nevery form, add @authenticityToken() inside the form elements. For example:<pre>@import _root_.views.html.authtoken.authenticityToken\r\n\r\n&lt;form action=\"@routes.Application.process()\" method=\"post\"&gt;\r\n   @authenticityToken()\r\n   Please input your name\r\n   &lt;input name=\"name\" /&gt;\r\n   &lt;input type=\"submit\"/&gt;\r\n&lt;/form&gt;</pre></li>\r\n    <li>\r\n      <p />\r\n      <strong>Add token-validation code.</strong> On the pages that carry out sensitive operations, add code that checks if the tokens sent in HTTP requests are valid or not. To validate the token, use the @AuthenticityToken Play validator. For example:<pre>import authtoken.validator.AuthenticityToken;<br /><br />public class FormData {<br /><br />    @AuthenticityToken<br />    public String authtoken;<br /><br />    public String name;<br />}<br /><br />public static Result process() {<br /><br />    Form<formdata> form = form(FormData.class).bindFromRequest();<br /><br />    if (form.hasErrors()) {<br />        return badRequest(\"authenticity validation FAILED\");<br />    } else {<br />        return ok(\"authenticity validation PASSED\");<br />    }<br />}</formdata></pre></li>\r\n  </ol>\r\n  <h1>Additional Resources</h1>\r\n  <ul>\r\n    <li>For information about the OWASP CSRFGuard project, please see&nbsp;<a href=\"https://www.owasp.org/index.php/Category:OWASP_CSRFGuard_Project\">https://www.owasp.org/index.php/Category:OWASP_CSRFGuard_Project</a></li>\r\n    <li>Sample code for Play 2 Authenticity Token can be seen&nbsp;<a href=\"https://github.com/orefalo/play2-authenticitytoken\">https://github.com/orefalo/play2-authenticitytoken</a></li>\r\n    <li>\r\n      <a href=\"https://github.com/jacobgroundwater/Scala-Play-CSRF\">Here</a> is another way of implementing unique tokens in Play Framework successfully using cookie and hidden-field approach.</li>\r\n  </ul>\r\n  <div>\r\n    <br />\r\n  </div>"
        ]
      }
    ]
  }
}