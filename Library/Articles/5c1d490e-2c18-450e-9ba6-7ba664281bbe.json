{
  "TeamMentor_Article": {
    "$": {
      "Metadata_Hash": "0",
      "Content_Hash": "0"
    },
    "Metadata": [
      {
        "Id": [
          "5c1d490e-2c18-450e-9ba6-7ba664281bbe"
        ],
        "Id_History": [
          "5c1d490e-2c18-450e-9ba6-7ba664281bbe,c816c981-91f5-42c1-a57f-7fd6f7bf175b,"
        ],
        "Library_Id": [
          "f215ceee-9a08-41d9-b2c1-bbcc058a8f32"
        ],
        "Title": [
          "Use the Java UUID Class to Identify Each Installation Uniquely "
        ],
        "Category": [
          "Privacy"
        ],
        "Phase": [
          "Implementation"
        ],
        "Technology": [
          "Android"
        ],
        "Type": [
          "Guideline"
        ],
        "DirectLink": [
          "Use the Java UUID Class to Identify Each Installation Uniquely "
        ],
        "Author": [
          ""
        ],
        "Priority": [
          ""
        ],
        "Status": [
          ""
        ]
      }
    ],
    "Content": [
      {
        "$": {
          "Sanitized": "false",
          "DataType": "wikitext"
        },
        "Data": [
          "==Applies To==\r\n\r\n* Android\r\n\r\n==What to Do==\r\n\r\nCreate a randomly generated globally unique identifier (GUID) for the application using the Java UUID class. Do not use elements such as phone number, media access control address, or Android ID. These device elements require additional permissions, are not always reliable, and in most cases are unnecessary.\r\n\r\n==Why==\r\n\r\nThe UUID class does not require additional permissions and is highly reliable. In addition, it does not use personal information, which helps avoid an overly permissive application that opens unnecessary security holes. UUID also produces an identifier that has a high level of uniqueness. In contrast, using device information such as a phone number or Android ID to identify an installation is unreliable and can negatively affect user privacy. Phone numbers are especially problematic, because they survive device wipes, are not unique to a specific installation, and constitute personal data. They also will not appear on Wi-Fi–only devices. \r\n\r\n==When==\r\n\r\nWhenever an application requires a unique identifier for its installation, use the UUID class to generate it. For example, an application may require an identifier if you want to count the number of unique installations for statistical purposes, or if you want  to tie such an identifier to an actual user without having to store personal information on the device itself. (Note that most applications, especially ones that interact solely on the device, will not need a unique identifier.)\r\n\r\n==How==\r\n\r\nTo generate unique GUIDs by using UUID:\r\n\r\n# **Upon installation, call the static method UUID.randomUUID() to create a 128-bit unique identifier.** For most purposes, this identifier provides more than enough uniqueness. Note that you should not use a subset of the number except with the //UUID.randomUUID().getLeastSignificantBits()// or //UUID.randomUUID().getMostSignificantBits()// methods. For instance, do not take the first 8 digits of the returned long value and store that as your unique value, as the randomness can be significantly degraded when you do that.\r\n# **Store the GUID in a persistent location such as a SQLite database.** Since the value will be 8 bytes in size, an INTEGER column will be able to store it. The application will call this column when it needs to retrieve or store the unique value. \r\n# **In the onCreate() method of the launcher activity, verify that the GUID value exists.** If not, use UUID to create it and, then store the value in the SQLite database.\r\n\r\n==Problem Example==\r\n\r\nAs the MyApp developer, you need a unique identifier so that a cloud-based database can track installations for license management. You use the phone number on the device. To retrieve it, you use the //TelephonyManager//:\r\n\r\n{{{\r\nTelephonyManager tMgr = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);\r\nString mPhone= tMgr.getLine1Number();\r\n}}}\r\n\r\nThis method initially appears to work well as the company rolls out the MyApp application. After a few months, though, procurement notices that Wi-Fi–only devices are not appearing in the database. When a senior executive finds out that this is because the phone number is being used for installation identification, she becomes concerned that the company may be violating local privacy legislation, because these are personal, not work-owned, devices and contain personal phone numbers. In addition, the company may have an unknown number of licenses for which they cannot account.\r\n\r\n==Solution Example==\r\n\r\nInstead of using the device’s phone number, the application uses the UUID class to generate a unique GUID upon installation:\r\n\r\n{{{\r\nlong _id = UUID.randomUUID().getLeastSignificantBits();\r\n}}}\r\n\r\nThe application stores the long value in the SQLite database and retrieves it on demand through a database helper function. \r\n\r\nAssume a table called ID_TABLE that stores the value in a column called APP_ID.\r\n\r\n{{{\r\npublic String getAppId () {\r\n  String[] resultColumns = new String[] {APP_ID };\r\n  try {\r\n    Cursor allRows = db.query(ID_TABLE, resultColumns, null, null, null, null, null);\r\n    if (allRows.moveToFirst()){\r\n      return allRows.getLong(0);\r\n    }\r\n    else{\r\n      return Long.MIN_VALUE;\r\n    }\r\n  }\r\n  catch (SQLException e){\r\n    Log.i(getClass().getSimpleName(), “SQL Error” + e.getMessage();\r\n  }\r\n}\r\n}}}\r\n\r\nThe application includes this method in a class that extends //SQLiteOpenHelper//. Upon startup, the application will run this method to determine whether the ID already exists. If it doesn’t, the app creates the identifier using UUID and inserts it into the database with a method such as:\r\n\r\n{{{\r\npublic int insertId () {\r\n  try {\r\n    long _id = UUID.randomUUID().getLeastSignificantBits();\r\n    ContentValues values = new ContentValues();\r\n    values.put(COL_CODE, _id);\r\n    db.insert(ID_TABLE, null, values);\r\n    values.clear();\r\n    return 1;\r\n  }\r\n  catch (SQLException e){\r\n    Log.i(getClass().getSimpleName(), “SQL Error” + e.getMessage();\r\n    return -1;\r\n  }\r\n}\r\n}}}\r\n\r\nIn the event the application is uninstalled and reinstalled, the unique value will be regenerated through the //onCreate()// method of the launcher activity.\r\n\r\n"
        ]
      }
    ]
  }
}