<h2>Applies To</h2>
<ul>
<li>ASP.NET 4.0+</li>
</ul>
<h2>Problem Example</h2>
<p>The following code validates the user based on a given username and password. It hashes the password with a random salt. Then it compares the username and the produced hash against the data stored in the backend database. Unfortunately, the SQL query is dynamically crafted by using the user's input. If there is no proper input validation, an attacker can access the application's database server through the use of SQL injection.</p>
<pre><code>public boolean validateUser(String user, char[] pass)
{
      byte[] salt = MyApp.generateSalt();
      String passHash;
      SqlConnection cn;
      SqlCommand sqlCommand;
      String query;
      passHash = hashCredentials(pass, salt);

      // The application crafts the SQL query based on user's input
      cn = MyApp.getDBConnection();
      sqlCommand = new SqlCommand(&quot;select user from myappUsers where user = '&quot;+
      user + &quot;' + and pass = '&quot; + passHash + &quot;' and login_attempts &lt; 3;&quot;, cn);
      SqlDataReader reader = sqlCommand.ExecuteReader();
      updateLastLoginAttempt(user);
      ...
}
</code></pre>
<p>If a user submits a login request with a username of</p>
<pre><code>foo' or 1 = 1; drop table *; --
</code></pre>
<p>the system will happily first authenticate the user and then drop all the tables in the database.</p>
<h2>Solution Example</h2>
<p>The following code validates the user based on a given username and password. It hashes the password with a random salt. Then it compares the username and the produced hash against the data stored in the backend database. Because the application uses the Parameters property, it is much more difficult for an attacker to gain access to the application's database server through the use of SQL injection.</p>
<pre><code>public boolean validateUser(String user, char[] pass)
{
   byte[] salt = MyApp.generateSalt();
   String passHash; 
   SqlConnection cn;
   SqlCommand sqlCommand;
   String query;     
   passHash = hashCredentials(pass, salt);
   // The application crafts the SQL query based on user's input
   cn = MyApp.getDBConnection();
   sqlCommand = new SqlCommand(&quot;select user from myappUsers where user = @user and 
                    + pass = @passHash and login_attempts &lt; 3;&quot;, cn);
   sqlCommand.Parameters.Add(&quot;@user&quot;, SqlDbType.VarChar, user.Length).Value = user;
   sqlCommand.Parameters.Add(&quot;@passHash &quot;, SqlDbType.VarChar, passHash.Length).Value = passHash;
   SqlDataReader reader = sqlCommand.ExecuteReader(); 
   updateLastLoginAttempt(user);  
   ...
}
</code></pre>
<p>Even if the user passes in an arbitrary string for a username or a password, they will not be able to alter the query or otherwise effect the database. An even better solution would involve using a stored procedure instead of a parameterized command, because that would permit the database to be locked down further.</p>
<hr>
<p>Adapted from Microsoft patterns &amp; practices guidance.</p>
