{
  "id": "28e97ee2-fce7-4c63-80ab-47393e4be9df",
  "checksum": "880b0c087070377e6156b4fa91bd2cc6a8eba682",
  "words": {
    "0": [
      "ol",
      "ol",
      "li",
      "li"
    ],
    "2": [
      "p",
      "p"
    ],
    "10514": [
      "p"
    ],
    "applies": [
      "h2"
    ],
    "to": [
      "h2",
      "h2",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "title"
    ],
    "android": [
      "ul",
      "li",
      "ol",
      "li",
      "p"
    ],
    "what": [
      "h2"
    ],
    "do": [
      "h2",
      "ol",
      "ol",
      "li",
      "li"
    ],
    "if": [
      "p",
      "p",
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "you": [
      "p",
      "ol",
      "ol",
      "li",
      "strong",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "need": [
      "p",
      "p"
    ],
    "restrict": [
      "p",
      "p"
    ],
    "access": [
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "li",
      "strong",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "an": [
      "p",
      "ol",
      "li"
    ],
    "instance": [
      "p",
      "ol",
      "li",
      "p"
    ],
    "of": [
      "p",
      "ol",
      "ol",
      "li",
      "li",
      "strong",
      "p",
      "p",
      "p",
      "p"
    ],
    "accountmanager": [
      "p",
      "em",
      "p",
      "em",
      "p",
      "em",
      "p",
      "em",
      "p",
      "em",
      "p",
      "em",
      "pre",
      "title"
    ],
    "that": [
      "p",
      "p",
      "p",
      "ol",
      "li",
      "p",
      "p",
      "p"
    ],
    "uses": [
      "p",
      "p"
    ],
    "oauth": [
      "p",
      "p"
    ],
    "authenticate": [
      "p",
      "p"
    ],
    "with": [
      "p",
      "ol",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "a": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "strong",
      "strong",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "cloud-based": [
      "p",
      "p",
      "p",
      "p"
    ],
    "service": [
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li",
      "strong",
      "strong",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "use": [
      "p",
      "ol",
      "li",
      "p",
      "p",
      "p",
      "p",
      "title"
    ],
    "the": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "strong",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "strong",
      "strong",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "strong",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "method": [
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li",
      "strong",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "getpackagemanager).checksignatures(uid1,": [
      "p",
      "em",
      "ol",
      "li",
      "em"
    ],
    "uid2": [
      "p",
      "em",
      "ol",
      "li",
      "em"
    ],
    "test": [
      "p"
    ],
    "whether": [
      "p",
      "ol",
      "li",
      "p"
    ],
    "signature": [
      "p"
    ],
    "for": [
      "p",
      "p",
      "p",
      "p",
      "ol",
      "li",
      "strong",
      "p",
      "p",
      "p",
      "p"
    ],
    "one": [
      "p",
      "p"
    ],
    "package": [
      "p"
    ],
    "uid1)": [
      "p"
    ],
    "is": [
      "p",
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p",
      "p"
    ],
    "same": [
      "p"
    ],
    "as": [
      "p",
      "ol",
      "li",
      "p",
      "p"
    ],
    "another": [
      "p"
    ],
    "uid2).": [
      "p"
    ],
    "why": [
      "h2"
    ],
    "allows": [
      "p"
    ],
    "user": [
      "p",
      "ol",
      "li"
    ],
    "account": [
      "p",
      "pre",
      "pre"
    ],
    "services": [
      "p"
    ],
    "through": [
      "p"
    ],
    "protocol": [
      "p"
    ],
    "this": [
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "certain": [
      "p"
    ],
    "applications": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "title"
    ],
    "cloud": [
      "p",
      "p",
      "p"
    ],
    "contains": [
      "p",
      "p"
    ],
    "sensitive": [
      "p"
    ],
    "information": [
      "p"
    ],
    "or": [
      "p",
      "ol",
      "ol",
      "li",
      "li"
    ],
    "requires": [
      "p"
    ],
    "special": [
      "p",
      "ol",
      "li"
    ],
    "subscription": [
      "p",
      "p"
    ],
    "when": [
      "h2",
      "ol",
      "li",
      "strong"
    ],
    "perform": [
      "p"
    ],
    "check": [
      "p",
      "ol",
      "li"
    ],
    "implement": [
      "p"
    ],
    "and": [
      "p",
      "ol",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "oauth2": [
      "p"
    ],
    "authentication": [
      "p",
      "p",
      "p"
    ],
    "how": [
      "h2"
    ],
    "prior": [
      "p"
    ],
    "calling": [
      "p",
      "ol",
      "ol",
      "li",
      "li",
      "strong"
    ],
    "getauthtoken)": [
      "p",
      "em",
      "em"
    ],
    "which": [
      "p",
      "ol",
      "li",
      "strong",
      "p"
    ],
    "will": [
      "p",
      "ol",
      "li",
      "p",
      "p"
    ],
    "retrieve": [
      "p",
      "ol",
      "li"
    ],
    "token": [
      "p",
      "p",
      "pre"
    ],
    "accessing": [
      "p",
      "title"
    ],
    "into": [
      "p"
    ],
    "determine": [
      "ol",
      "li",
      "strong",
      "p"
    ],
    "packages": [
      "ol",
      "li",
      "strong"
    ],
    "are": [
      "ol",
      "li",
      "strong",
      "p",
      "p"
    ],
    "authorizing": [
      "ol",
      "li",
      "strong"
    ],
    "their": [
      "ol",
      "li"
    ],
    "id": [
      "ol",
      "li"
    ],
    "uid)": [
      "ol",
      "li"
    ],
    "call": [
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "bindergetcallinguid().": [
      "ol",
      "li",
      "p",
      "p"
    ],
    "take": [
      "ol",
      "li"
    ],
    "care": [
      "ol",
      "li"
    ],
    "from": [
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p"
    ],
    "within": [
      "ol",
      "li"
    ],
    "application": [
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "strong",
      "li",
      "p",
      "p",
      "p"
    ],
    "itself": [
      "ol",
      "li"
    ],
    "store": [
      "ol",
      "li",
      "p"
    ],
    "uids": [
      "ol",
      "li",
      "p"
    ],
    "in": [
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li",
      "strong",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "location": [
      "ol",
      "li",
      "p"
    ],
    "accessible": [
      "ol",
      "ol",
      "li",
      "li"
    ],
    "bound": [
      "ol",
      "ol",
      "li",
      "li",
      "strong",
      "p"
    ],
    "invokes": [
      "ol",
      "li",
      "strong"
    ],
    "your": [
      "ol",
      "ol",
      "li",
      "li",
      "strong",
      "p",
      "p",
      "p",
      "pre",
      "p"
    ],
    "capture": [
      "ol",
      "li",
      "strong",
      "p"
    ],
    "uid": [
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "strong",
      "li",
      "li",
      "strong",
      "p",
      "p",
      "p",
      "em",
      "pre",
      "p",
      "p"
    ],
    "doing": [
      "ol",
      "li"
    ],
    "so": [
      "ol",
      "li"
    ],
    "can": [
      "ol",
      "li",
      "p",
      "p"
    ],
    "be": [
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p"
    ],
    "tricky": [
      "ol",
      "li"
    ],
    "many": [
      "ol",
      "li"
    ],
    "programmers": [
      "ol",
      "li"
    ],
    "onbind)": [
      "ol",
      "ol",
      "li",
      "li",
      "em",
      "em",
      "p",
      "em"
    ],
    "application’s": [
      "ol",
      "li",
      "p"
    ],
    "thinking": [
      "ol",
      "li"
    ],
    "bindergetcallinguid()": [
      "ol",
      "em",
      "li",
      "em",
      "em",
      "p",
      "em",
      "em"
    ],
    "return": [
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "p",
      "p"
    ],
    "remote": [
      "ol",
      "ol",
      "li",
      "li"
    ],
    "process": [
      "ol",
      "li",
      "p"
    ],
    "it": [
      "ol",
      "li",
      "p"
    ],
    "does": [
      "ol",
      "li",
      "p"
    ],
    "not": [
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "p",
      "p"
    ],
    "because": [
      "ol",
      "li"
    ],
    "remotely": [
      "ol",
      "ol",
      "li",
      "li"
    ],
    "called)": [
      "ol",
      "li"
    ],
    "instead": [
      "ol",
      "li"
    ],
    "place": [
      "ol",
      "li"
    ],
    "interface": [
      "ol",
      "li"
    ],
    "definition": [
      "ol",
      "li"
    ],
    "language": [
      "ol",
      "li"
    ],
    "override": [
      "ol",
      "li"
    ],
    "sendmessageattimemessage": [
      "ol",
      "li",
      "em",
      "pre"
    ],
    "m": [
      "ol",
      "li",
      "em"
    ],
    "long": [
      "ol",
      "li",
      "em",
      "pre"
    ],
    "l": [
      "ol",
      "li",
      "em",
      "pre"
    ],
    "service’s": [
      "ol",
      "li"
    ],
    "handler": [
      "ol",
      "li",
      "p"
    ],
    "obtain": [
      "ol",
      "li"
    ],
    "validate": [
      "ol",
      "li",
      "strong"
    ],
    "against": [
      "ol",
      "li"
    ],
    "those": [
      "ol",
      "li",
      "p"
    ],
    "have": [
      "ol",
      "li"
    ],
    "used": [
      "ol",
      "li"
    ],
    "authorize": [
      "ol",
      "li"
    ],
    "decide": [
      "ol",
      "li"
    ],
    "should": [
      "ol",
      "li",
      "p",
      "p"
    ],
    "allowed": [
      "ol",
      "li",
      "p"
    ],
    "=": [
      "ol",
      "li",
      "pre",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "em",
      "pre"
    ],
    "signatures": [
      "ol",
      "li"
    ],
    "match": [
      "ol",
      "li",
      "p"
    ],
    "they": [
      "ol",
      "li"
    ],
    "problem": [
      "h2"
    ],
    "example": [
      "h2",
      "h2"
    ],
    "myapp": [
      "p",
      "p",
      "p"
    ],
    "developer": [
      "p"
    ],
    "using": [
      "p",
      "p"
    ],
    "google": [
      "p"
    ],
    "programming": [
      "p"
    ],
    "interfaces": [
      "p"
    ],
    "apis).": [
      "p"
    ],
    "configure": [
      "p"
    ],
    "automatically": [
      "p"
    ],
    "bind": [
      "p",
      "p"
    ],
    "generate": [
      "p"
    ],
    "log": [
      "p"
    ],
    "api": [
      "p"
    ],
    "all": [
      "p"
    ],
    "works": [
      "p"
    ],
    "flawlessly": [
      "p"
    ],
    "but": [
      "p"
    ],
    "discover": [
      "p"
    ],
    "other": [
      "p",
      "p",
      "p"
    ],
    "piggyback": [
      "p"
    ],
    "on": [
      "p"
    ],
    "few": [
      "p"
    ],
    "lines": [
      "p"
    ],
    "code": [
      "p"
    ],
    "serviceconnection": [
      "pre",
      "pre"
    ],
    "connection": [
      "pre",
      "pre"
    ],
    "new": [
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "monitoringserviceconnection);\n\nintent.setaction(\"com.example.myapp.register": [
      "pre"
    ],
    "\";\n\tcontext.bindservice(intent,": [
      "pre"
    ],
    "contextbind_auto_create);\n\nclass": [
      "pre"
    ],
    "monitoringserviceconnection": [
      "pre"
    ],
    "implements": [
      "pre"
    ],
    "{\tpublic": [
      "pre"
    ],
    "void": [
      "pre",
      "pre",
      "pre"
    ],
    "onserviceconnected": [
      "pre"
    ],
    "componentname": [
      "pre"
    ],
    "classname": [
      "pre",
      "pre"
    ],
    "ibinder": [
      "pre"
    ],
    "binder\n{\n\tmessengertoservice": [
      "pre"
    ],
    "messengerbinder);\n}\n\t\npublic": [
      "pre"
    ],
    "onservicedisconnectedcomponentname": [
      "pre"
    ],
    "{\t\tmessengertoservice": [
      "pre"
    ],
    "null": [
      "pre",
      "pre"
    ],
    "}};": [
      "pre"
    ],
    "getauthtoken),": [
      "p"
    ],
    "starts": [
      "p"
    ],
    "account\"myapp@gmail.com\",": [
      "pre"
    ],
    "\"comgoogle\");\nam.getauthtoken(account,": [
      "pre"
    ],
    "\"manage": [
      "pre"
    ],
    "tasks”": [
      "pre"
    ],
    "ref": [
      "pre"
    ],
    "getauthcallback),": [
      "pre"
    ],
    "handler;": [
      "pre"
    ],
    "want": [
      "p"
    ],
    "limit": [
      "p"
    ],
    "no": [
      "p"
    ],
    "reason": [
      "p"
    ],
    "than": [
      "p"
    ],
    "require": [
      "p"
    ],
    "allowing": [
      "p"
    ],
    "anyone": [
      "p"
    ],
    "freely": [
      "p"
    ],
    "work": [
      "p"
    ],
    "solution": [
      "h2"
    ],
    "first": [
      "p"
    ],
    "sending": [
      "p"
    ],
    "by": [
      "p"
    ],
    "overriding": [
      "p"
    ],
    "sendmessageattime)": [
      "p",
      "em"
    ],
    "int": [
      "p",
      "em"
    ],
    "next": [
      "p",
      "p"
    ],
    "add": [
      "p"
    ],
    "checksignatures)": [
      "p",
      "p",
      "em",
      "em"
    ],
    "authorized": [
      "p",
      "p"
    ],
    "<0),": [
      "p"
    ],
    "set": [
      "p",
      "p"
    ],
    "incoming": [
      "p",
      "pre",
      "p",
      "pre"
    ],
    "message’s": [
      "p",
      "p"
    ],
    "arg1": [
      "p",
      "em",
      "p",
      "p",
      "em",
      "em"
    ],
    "field": [
      "p",
      "p",
      "p"
    ],
    "-1": [
      "p",
      "p"
    ],
    "message": [
      "p",
      "p",
      "p"
    ],
    "accepted": [
      "p",
      "p"
    ],
    "@override": [
      "pre"
    ],
    "public": [
      "pre"
    ],
    "boolean": [
      "pre"
    ],
    "{int": [
      "pre"
    ],
    "bindergetcallinguid();\nif": [
      "pre"
    ],
    "getpackagemanager().checksignatures(uid,": [
      "pre"
    ],
    "10514<=0)": [
      "pre"
    ],
    "{incoming.arg1=-1;\n}\nelse": [
      "pre"
    ],
    "{incoming.arg1=1;\nhandlemessage(incoming);\n}\nreturn": [
      "pre"
    ],
    "true\n}": [
      "pre"
    ],
    "case": [
      "p"
    ],
    "assumes": [
      "p"
    ],
    "was": [
      "p"
    ],
    "recorded": [
      "p"
    ],
    "oncreate": [
      "p",
      "em"
    ],
    "also": [
      "p"
    ],
    "persistent": [
      "p"
    ],
    "course": [
      "p"
    ],
    "checksignatures": [
      "p",
      "em"
    ],
    "these": [
      "p"
    ],
    "well": [
      "p"
    ],
    "tells": [
      "p"
    ],
    "recipient": [
      "p"
    ],
    "update": [
      "p"
    ],
    "handler’s": [
      "p"
    ],
    "handlemessage)": [
      "p",
      "em"
    ],
    "logic": [
      "p"
    ],
    "look": [
      "p"
    ],
    "reject": [
      "p"
    ],
    "simple": [
      "p"
    ],
    "otherwise": [
      "p"
    ],
    "let": [
      "p"
    ],
    "interact": [
      "p"
    ],
    "@overridepublic": [
      "pre"
    ],
    "handlemessagemessage": [
      "pre"
    ],
    "{\tif": [
      "pre"
    ],
    "incoming.arg1==-1){return;}\n}\n\n…": [
      "pre"
    ],
    "//continue": [
      "pre"
    ],
    "processing": [
      "pre"
    ],
    "request": [
      "pre"
    ],
    "checksignature)": [
      "title"
    ],
    "verify": [
      "title"
    ]
  },
  "tags": {
    "h2": [
      "Applies To",
      "What to Do",
      "Why",
      "When",
      "How",
      "Problem Example",
      "Solution Example"
    ],
    "ul": [
      "Android"
    ],
    "li": [
      "Android",
      "Determine the packages for which you are authorizing access. Retrieve their user ID (UID) with a call to Binder.getCallingUid(). Take special care to call this method from within the application itself, and store the UIDs in a location accessible from the service.",
      "When a bound service invokes a method in your application, capture the UID of the calling service. Doing so can be tricky, as many programmers do this in the onBind() method of the application’s service, thinking that the Binder.getCallingUid() method will return the remote process UID. (It does not, because onBind() is not remotely called.) Instead, place this call in an Android Interface Definition Language remotely accessible service, or override the sendMessageAtTime(Message m, long l) method in your bound service’s handler instance to obtain the calling UID.",
      "Validate the UID. Check the UID against those you have used getPackageManager().checkSignatures(UID1, UID2) to authorize. Use the return to decide whether the remote application should be allowed access.  The return is >= 0 if the signatures match or < 0 if they do not."
    ],
    "p": [
      "If you need to restrict access to an instance of AccountManager that uses OAuth 2 to authenticate with a cloud-based service, use the method getPackageManager().checkSignatures(UID1, UID2) to test whether the signature for one package (UID1) is the same as another (UID2).",
      "AccountManager allows a user account to access cloud-based services through the OAuth 2 protocol. Restrict this access to certain applications if the cloud service contains sensitive information or requires a special subscription.",
      "Perform this check for applications that implement a service that uses AccountManager and OAuth2 for cloud-based authentication.",
      "Prior to calling the getAuthToken() method which will retrieve the authentication token for accessing into a cloud service:",
      "As the MyApp developer, you are using a cloud service to access Google application programming interfaces (APIs). You configure your Android applications to automatically bind to the service and use AccountManager to generate a token and log in to the API service.",
      "All works flawlessly, but you discover that other applications can piggyback on your service with a few lines of code:",
      "The onBind() method of the MyApp service contains a call to getAuthToken(), which starts the authentication process to your cloud-based service using AccountManager:",
      "You want to limit access to your service if for no other reason than to require a subscription. Allowing anyone to bind freely and access the service will not work.",
      "To authenticate application access to the MyApp service, you can first capture the sending application’s UID by overriding the sendMessageAtTime() method in the handler instance for the bound service. In this method, call int uid = Binder.getCallingUid(). Next, add a call to checkSignatures() with this UID and the one that is authorized access. If the checkSignatures() method does not return a match (<0), set the incoming message’s arg1 field  = -1, and use this in the next method to determine whether this message should be accepted:",
      "This case assumes that the authorized UID is 10514 and was recorded in the onCreate method of the service with a call to Binder.getCallingUid(). If other UIDs are also allowed access, you will need to call the Binder.getCallingUid() method from those applications and store the UID in a persistent location. Of course, use the checkSignatures method for these, as well.",
      "The arg1 field tells you if the message from the recipient should be accepted. Update the handler’s handleMessage() method with logic to look for the incoming message’s arg1 field. If it is set to -1, reject the message with a simple return. Otherwise, let the application interact with the service and use the AccountManager:"
    ],
    "em": [
      "AccountManager",
      "getPackageManager().checkSignatures(UID1, UID2)",
      "AccountManager",
      "AccountManager",
      "getAuthToken()",
      "Binder.getCallingUid()",
      "onBind()",
      "Binder.getCallingUid()",
      "onBind()",
      "sendMessageAtTime(Message m, long l)",
      "getPackageManager().checkSignatures(UID1, UID2)",
      "AccountManager",
      "onBind()",
      "getAuthToken()",
      "AccountManager",
      "sendMessageAtTime()",
      "int uid = Binder.getCallingUid()",
      "checkSignatures()",
      "checkSignatures()",
      "arg1",
      "onCreate",
      "Binder.getCallingUid()",
      "Binder.getCallingUid()",
      "checkSignatures",
      "arg1",
      "handleMessage()",
      "arg1",
      "AccountManager"
    ],
    "ol": [
      "Determine the packages for which you are authorizing access. Retrieve their user ID (UID) with a call to Binder.getCallingUid(). Take special care to call this method from within the application itself, and store the UIDs in a location accessible from the service.\n When a bound service invokes a method in your application, capture the UID of the calling service. Doing so can be tricky, as many programmers do this in the onBind() method of the application’s service, thinking that the Binder.getCallingUid() method will return the remote process UID. (It does not, because onBind() is not remotely called.) Instead, place this call in an Android Interface Definition Language remotely accessible service, or override the sendMessageAtTime(Message m, long l) method in your bound service’s handler instance to obtain the calling UID.\n Validate the UID. Check the UID against those you have used getPackageManager().checkSignatures(UID1, UID2) to authorize. Use the return to decide whether the remote application should be allowed access.  The return is >= 0 if the signatures match or < 0 if they do not."
    ],
    "strong": [
      "Determine the packages for which you are authorizing access.",
      "When a bound service invokes a method in your application, capture the UID of the calling service.",
      "Validate the UID."
    ],
    "pre": [
      "ServiceConnection connection = new MonitoringServiceConnection();\n\nintent.setAction(\"com.example.myapp.REGISTER \");\n\tcontext.bindService(intent, connection, Context.BIND_AUTO_CREATE);\n\nclass MonitoringServiceConnection implements ServiceConnection {\t\npublic void onServiceConnected (ComponentName className, IBinder binder)\n{\n\tmessengerToService = new Messenger(binder);\n}\n\t\npublic void onServiceDisconnected(ComponentName className) {\n\t\tmessengerToService = null; \n}\n};",
      "Account account = new Account(\"myapp@gmail.com\", \"com.google\");\nam.getAuthToken(account, \"Manage your tasks”, null,  ref, new GetAuthCallback(), handler);",
      "@Override \npublic boolean sendMessageAtTime(Message incoming, long l) {\nint uid = Binder.getCallingUid();\nif (getPackageManager().checkSignatures(uid, 10514)<=0) {\nincoming.arg1=-1;\n}\nelse {\nincoming.arg1=1;\nhandleMessage(incoming);\n}\nreturn true;\n}",
      "@Override\npublic void handleMessage(Message incoming) {\t\nif (incoming.arg1==-1){return;}\n}\n\n… //continue processing AccountManager token request"
    ]
  },
  "links": [],
  "html": "<h2>Applies To</h2><ul><li> Android</li>\n</ul><h2>What to Do</h2><p>If you need to restrict access to an instance of <em>AccountManager</em> that uses OAuth 2 to authenticate with a cloud-based service, use the method <em>getPackageManager().checkSignatures(UID1, UID2)</em> to test whether the signature for one package (UID1) is the same as another (UID2).\n</p><h2>Why</h2><p><em>AccountManager</em> allows a user account to access cloud-based services through the OAuth 2 protocol. Restrict this access to certain applications if the cloud service contains sensitive information or requires a special subscription.\n</p><h2>When</h2><p>Perform this check for applications that implement a service that uses <em>AccountManager</em> and OAuth2 for cloud-based authentication.\n</p><h2>How</h2><p>Prior to calling the <em>getAuthToken()</em> method which will retrieve the authentication token for accessing into a cloud service:\n</p><ol>\n<li> <strong>Determine the packages for which you are authorizing access.</strong> Retrieve their user ID (UID) with a call to <em>Binder.getCallingUid()</em>. Take special care to call this method from within the application itself, and store the UIDs in a location accessible from the service.</li>\n<li> <strong>When a bound service invokes a method in your application, capture the UID of the calling service.</strong> Doing so can be tricky, as many programmers do this in the <em>onBind()</em> method of the application’s service, thinking that the <em>Binder.getCallingUid()</em> method will return the remote process UID. (It does not, because <em>onBind()</em> is not remotely called.) Instead, place this call in an Android Interface Definition Language remotely accessible service, or override the <em>sendMessageAtTime(Message m, long l)</em> method in your bound service’s handler instance to obtain the calling UID.</li>\n<li> <strong>Validate the UID.</strong> Check the UID against those you have used <em>getPackageManager().checkSignatures(UID1, UID2)</em> to authorize. Use the return to decide whether the remote application should be allowed access.  The return is &gt;= 0 if the signatures match or &lt; 0 if they do not.  </li>\n</ol><h2>Problem Example</h2><p>As the MyApp developer, you are using a cloud service to access Google application programming interfaces (APIs). You configure your Android applications to automatically bind to the service and use <em>AccountManager</em> to generate a token and log in to the API service.\n</p><p>\nAll works flawlessly, but you discover that other applications can piggyback on your service with a few lines of code:\n</p><pre>ServiceConnection connection = new MonitoringServiceConnection();\n\nintent.setAction(\"com.example.myapp.REGISTER \");\n\tcontext.bindService(intent, connection, Context.BIND_AUTO_CREATE);\n\nclass MonitoringServiceConnection implements ServiceConnection {\t\npublic void onServiceConnected (ComponentName className, IBinder binder)\n{\n\tmessengerToService = new Messenger(binder);\n}\n\t\npublic void onServiceDisconnected(ComponentName className) {\n\t\tmessengerToService = null; \n}\n};\n</pre><p>\nThe <em>onBind()</em> method of the MyApp service contains a call to <em>getAuthToken()</em>, which starts the authentication process to your cloud-based service using <em>AccountManager</em>:\n</p><pre>Account account = new Account(\"myapp@gmail.com\", \"com.google\");\nam.getAuthToken(account, \"Manage your tasks”, null,  ref, new GetAuthCallback(), handler);    \n</pre><p>\nYou want to limit access to your service if for no other reason than to require a subscription. Allowing anyone to bind freely and access the service will not work.\n</p>\n<h2>Solution Example</h2><p>To authenticate application access to the MyApp service, you can first capture the sending application’s UID by overriding the <em>sendMessageAtTime()</em> method in the handler instance for the bound service. In this method, call <em>int uid = Binder.getCallingUid()</em>. Next, add a call to <em>checkSignatures()</em> with this UID and the one that is authorized access. If the <em>checkSignatures()</em> method does not return a match (&lt;0), set the incoming message’s <em>arg1</em> field  = -1, and use this in the next method to determine whether this message should be accepted:\n</p><pre>@Override \npublic boolean sendMessageAtTime(Message incoming, long l) {\nint uid = Binder.getCallingUid();\nif (getPackageManager().checkSignatures(uid, 10514)&lt;=0) {\nincoming.arg1=-1;\n}\nelse {\nincoming.arg1=1;\nhandleMessage(incoming);\n}\nreturn true;\n}\n</pre><p>\nThis case assumes that the authorized UID is 10514 and was recorded in the <em>onCreate</em> method of the service with a call to <em>Binder.getCallingUid()</em>. If other UIDs are also allowed access, you will need to call the <em>Binder.getCallingUid()</em> method from those applications and store the UID in a persistent location. Of course, use the <em>checkSignatures</em> method for these, as well.\n</p><p>\nThe <em>arg1</em> field tells you if the message from the recipient should be accepted. Update the handler’s <em>handleMessage()</em> method with logic to look for the incoming message’s <em>arg1</em> field. If it is set to -1, reject the message with a simple return. Otherwise, let the application interact with the service and use the <em>AccountManager</em>:\n</p><pre>@Override\npublic void handleMessage(Message incoming) {\t\nif (incoming.arg1==-1){return;}\n}\n\n… //continue processing AccountManager token request\n</pre>"
}