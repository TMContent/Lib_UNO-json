{
  "id": "d490eba4-046e-48fb-a7e6-a3de1ac93c34",
  "checksum": "4a053386a1f0d0d937450f639b83d39b4f69d621",
  "words": {
    "description": [
      "h1"
    ],
    "when": [
      "p"
    ],
    "generating": [
      "p"
    ],
    "an": [
      "p"
    ],
    "encryption": [
      "p"
    ],
    "key": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "title"
    ],
    "or": [
      "p"
    ],
    "pair": [
      "p"
    ],
    "use": [
      "p"
    ],
    "the": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "title"
    ],
    "largest": [
      "p",
      "p"
    ],
    "size": [
      "p",
      "p",
      "title"
    ],
    "that": [
      "p"
    ],
    "algorithm": [
      "p",
      "p",
      "p"
    ],
    "supports": [
      "p"
    ],
    "this": [
      "p"
    ],
    "does": [
      "p"
    ],
    "not": [
      "p"
    ],
    "necessarily": [
      "p"
    ],
    "make": [
      "p"
    ],
    "more": [
      "p"
    ],
    "secure": [
      "p"
    ],
    "but": [
      "p"
    ],
    "it": [
      "p"
    ],
    "dramatically": [
      "p"
    ],
    "increases": [
      "p"
    ],
    "time": [
      "p"
    ],
    "needed": [
      "p"
    ],
    "to": [
      "p",
      "p",
      "title"
    ],
    "successfully": [
      "p"
    ],
    "perform": [
      "p"
    ],
    "a": [
      "p",
      "p"
    ],
    "brute": [
      "p"
    ],
    "force": [
      "p"
    ],
    "attack": [
      "p"
    ],
    "on": [
      "p"
    ],
    "following": [
      "p"
    ],
    "code": [
      "p"
    ],
    "example": [
      "p"
    ],
    "shows": [
      "p"
    ],
    "how": [
      "p",
      "title"
    ],
    "find": [
      "p"
    ],
    "supported": [
      "p"
    ],
    "for": [
      "p"
    ],
    "particular": [
      "p"
    ],
    "private": [
      "pre"
    ],
    "int": [
      "pre",
      "pre"
    ],
    "getlargestsymkeysizesymmetricalgorithm": [
      "pre"
    ],
    "symalg{": [
      "pre"
    ],
    "keysizes]": [
      "pre",
      "pre"
    ],
    "sizes": [
      "pre",
      "pre"
    ],
    "=": [
      "pre",
      "pre"
    ],
    "symalglegalkeysizes;": [
      "pre"
    ],
    "return": [
      "pre",
      "pre"
    ],
    "sizessizes.length": [
      "pre",
      "pre"
    ],
    "-": [
      "pre",
      "pre"
    ],
    "1.maxsize;}private": [
      "pre"
    ],
    "getlargestasymkeysizeasymmetricalgorithm": [
      "pre"
    ],
    "asymalg{": [
      "pre"
    ],
    "asymalglegalkeysizes;": [
      "pre"
    ],
    "1.maxsize;}": [
      "pre"
    ],
    "adapted": [
      "p"
    ],
    "from": [
      "p"
    ],
    "microsoft": [
      "p"
    ],
    "patterns": [
      "p"
    ],
    "&": [
      "p"
    ],
    "practices": [
      "p"
    ],
    "guidance": [
      "p"
    ],
    "choose": [
      "title"
    ],
    "appropriate": [
      "title"
    ]
  },
  "tags": {
    "h1": [
      "Description"
    ],
    "p": [
      "When generating an encryption key or key pair, use the largest key size that the algorithm supports. This does not necessarily make the algorithm more secure, but it dramatically increases the time needed to successfully perform a brute force attack on the key. The following code example shows how to find the largest supported key size for a particular algorithm.",
      "Adapted from Microsoft patterns & practices guidance."
    ],
    "pre": [
      "private int GetLargestSymKeySize(SymmetricAlgorithm symAlg){    KeySizes[] sizes = symAlg.LegalKeySizes;    return sizes[sizes.Length - 1].MaxSize;}private int GetLargestAsymKeySize(AsymmetricAlgorithm asymAlg){    KeySizes[] sizes = asymAlg.LegalKeySizes;    return sizes[sizes.Length - 1].MaxSize;}"
    ],
    "br": [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
    ],
    "hr": [
      ""
    ]
  },
  "links": [],
  "html": "<h1>Description</h1>\r\n  <p>When generating an encryption key or key pair, use the largest key size that the algorithm supports. This does not necessarily make the algorithm more secure, but it dramatically increases the time needed to successfully perform a brute force attack on the key. The following code example shows how to find the largest supported key size for a particular algorithm. </p>\r\n  <pre>private int GetLargestSymKeySize(SymmetricAlgorithm symAlg)<br />&#123;<br />&nbsp;&nbsp;&nbsp; KeySizes&#91;&#93; sizes = symAlg.LegalKeySizes;<br />&nbsp;&nbsp;&nbsp; return sizes&#91;sizes.Length - 1&#93;.MaxSize;<br />&#125;<br />private int GetLargestAsymKeySize(AsymmetricAlgorithm asymAlg)<br />&#123;<br />&nbsp;&nbsp;&nbsp; KeySizes&#91;&#93; sizes = asymAlg.LegalKeySizes;<br />&nbsp;&nbsp;&nbsp; return sizes&#91;sizes.Length - 1&#93;.MaxSize;<br />&#125;</pre>\r\n  <hr />\r\n  <p>Adapted from Microsoft patterns & practices guidance.</p>"
}