<h1>Applies to</h1>
  <ul>
    <li>Microsoft&#174; Windows Communication Foundation (WCF) 3.5 <li>Microsoft Visual Studio&#174; 2008</li></li>
  </ul>
  <h1>Description</h1>
  <p>You can use the Win32 <strong>LogonUser()</strong> API (via P/Invoke) to create impersonation tokens, only when your WCF Service is not trusted for delegation, because this option forces you to store user name and passwords on your WCF Service.</p>
  <p>The following code example shows how the LogonUser API is used for impersonation:</p>
  <pre>using System.Runtime.InteropServices;<br />&#8230;<br />// Declare the logon types as constants<br />const long LOGON32_LOGON_NETWORK = 3;</pre>
  <pre>// Declare the logon providers as constants<br />const long LOGON32_PROVIDER_DEFAULT = 0;<br /><br />&#91;DllImport("advapi32.dll",EntryPoint = "LogonUser")&#93;<br />private static extern bool LogonUser(<br />           string lpszUsername,<br />           string lpszDomain,<br />           string lpszPassword,<br />           int dwLogonType,<br />           int dwLogonProvider,<br />           ref IntPtr phToken);<br />&#91;DllImport("kernel32.dll", CharSet=CharSet.Auto)&#93;<br />public extern static bool CloseHandle(IntPtr handle);</pre>
  <pre>private void ImpersonateAndUse(string Username,<br />                                        string Password,<br />                                        string Domain)<br />&#123;<br />  IntPtr token = new IntPtr(0);<br />  token = IntPtr.Zero;<br />  // Call LogonUser to obtain a handle to an access token.<br />  bool returnValue = LogonUser(Username, Domain,Password,<br />                                 (int)LOGON32_LOGON_NETWORK,<br />                                 (int)LOGON32_PROVIDER_DEFAULT,<br />                                 ref token);<br />  if (false == returnValue)<br />  &#123;<br />     int ret = Marshal.GetLastWin32Error();<br />     string strErr = String.Format("LogonUser failed with error code : &#123;0&#125;", ret);<br />     throw new ApplicationException(strErr, null);<br />  &#125;<br />  WindowsIdentity newId = new WindowsIdentity(token);<br />  WindowsImpersonationContext impersonatedUser = newId.Impersonate();<br />  try<br />  &#123;<br />     // do the operations using original user security context<br />  &#125;<br />  finally<br />  &#123;<br />     // stop impersonating<br />     impersonatedUser.Undo();<br />     CloseHandle(token);<br />  &#125;<br />&#125;</pre>
  <h1>Additional Resources</h1>
  <ul>
    <li>For more information on the LogonUser API, see &#8220;How to validate user credentials on Microsoft operating systems&#8221; at <a href="http://support.microsoft.com/kb/q180548/">http://support.microsoft.com/kb/q180548/</a><li>For more information, see &#8220;Delegation and Impersonation with WCF&#8221; at <a href="http://msdn2.microsoft.com/en-us/library/ms730088.aspx">http://msdn2.microsoft.com/en-us/library/ms730088.aspx</a><li>For impersonation and delegation Q&A, see the Impersonation/Delegation section of &#8220;WCF 3.5 Questions and Answers&#8220; at <a href="http://www.codeplex.com/WCFSecurityGuideGuideGuideGuide/Wiki/View.aspx?title=Questions&#37;20and&#37;20Answers&referringTitle=Home">http://www.codeplex.com/WCFSecurityGuideGuideGuideGuide/Wiki/View.aspx?title=Questions&#37;20and&#37;20Answers&referringTitle=Home</a></li></li></li>
  </ul>
  <hr />
  <p>Adapted from Microsoft patterns & practices guidance.</p>