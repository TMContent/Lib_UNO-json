<h1>What to Do</h1>
  <p>If you do need to receive input file names from the caller, make sure that the file names are strictly formed so that you can determine whether they are valid.</p>
  <h1>Why</h1>
  <p>Accepting file names or paths from users can result in attackers coercing your application into accessing arbitrary files and resources.</p>
  <h1>When</h1>
  <p>You should always validate file name, if you need to accept one from user.</p>
  <h1>How</h1>
  <p>There are two aspects to validating input file paths. You need to: </p>
  <ul>
    <li>Check for valid file system names. <li>Check for a valid location as defined by your application's context. For example, are the file names within the directory hierarchy of your application?</li></li>
  </ul>
  <p>To validate a path and file name, use the <b>System.IO.Path.GetFullPath</b> method as shown in the following code example. This method also canonicalizes the supplied file name.</p>
  <pre>using System.IO;<br />public static string ReadFile(string filename)<br />&#123;<br />&nbsp; // Obtain a canonicalized and valid filename<br />&nbsp; string name = Path.GetFullPath(filename);<br />&nbsp; // Now read the file and return the file content.<br />&#125;  </pre>
  <p>As part of the canonicalization process, <b>GetFullPath</b> performs the following checks: </p>
  <ul>
    <li>It checks that the file name does not contain any invalid characters, as defined by <b>Path.InvalidPathChars</b>. <li>It checks that the file name represents a file and not another device type, such as a physical drive, a named pipe, a mail slot, or a DOS device such as LPT1, COM1, AUX, and other devices. <li>It checks that the combined path and file name is not too long. <li>It removes redundant characters such as trailing dots. <li>It rejects file names that use the //?/ format.</li></li></li></li></li>
  </ul>
  <hr />
  <p>Adapted from Microsoft patterns & practices guidance.</p>