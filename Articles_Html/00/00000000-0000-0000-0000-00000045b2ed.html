<h2>Applies To</h2><ul><li> iOS applications that use SQL databases.</li>
</ul><h2>What to Check For</h2><p>Verify that parameterized methods are used for database access.
</p><h2>Why</h2><p>Using parameterized methods for database access helps prevent SQL injection vulnerabilities.
</p><h2>How to Check</h2><p>To verify that parameterized methods are used for database access:
</p><ol>
<li> <strong>Identify all code that executes SQL queries.</strong> Review application code to find all queries that are executed by the application.</li>
<li> <strong>Verify that parameterized APIs are used to execute SQL queries.</strong> Make sure that data is passed to queries as parameters. Make sure that data, especially untrusted data, is never concatenated with the query strings and then executed.</li>
</ol><h2>How to Fix</h2><p>To use parameterized methods for local database access:
</p><ol>
<li> <strong>Identify the APIs used for SQL database access.</strong> The most common library for SQL database access in iOS applications is SQLite.</li>
<li> <strong>Identify available parameterized SQL access APIs.</strong> Research the APIs for executing queries provided by the API used in your application and choose ones that separate SQL commands and data. The dangerous APIs are the ones that accept SQL queries as strings - they should be avoided. For SQLite, the statements and the data must first be converted to UTF-8 or UTF-16 character encodings. In SQLite, the way to use parameterized queries is to use prepared statements and pass data as parameters. The <em>sqlite3_prepare</em>, <em>sqlite3_prepare_v2</em>, <em>sqlite3_prepare16</em>, and <em>sqlite3_prepare16_v2</em> functions allow creating prepared statements. After a statement is prepared, variables are bound to it using <em>sqlite3_bind_*</em> functions. After variables have been bound, the query is executed using the <em>sqlite3_step</em> function as many times as necessary to get the full resultant data set - each call to <em>sqlite3_step</em> produces one row. The query can be reset by using the <em>sqlite3_reset</em> function - this resets the query result pointer to zero, so that <em>sqlite3_step</em> would start from the first resultant row again. After database access is complete, the query and its result should be destroyed using the <em>sqlite3_finalize</em> function.</li>
<li> <strong>Identify code that executes SQL queries.</strong> Examine application code to find code that executes SQL queries.</li>
<li> <strong>Use parameterized APIs to execute SQL queries.</strong> Make sure that parameterized queries are used by code that executes SQL queries. Rewrite existing code if necessary or add code that uses parameterized queries to perform database access. </li>
</ol><p>
There is no practical way to access remote SQL databases using native iOS API calls, so the most common way to access remote SQL databases from iOS applications is by writing a Web Service wrapper for the database server. To use parameterized methods for remote database access:
</p><ol>
<li> <strong>Set up a Web Service back-end server.</strong> Choose a platform for deploying the Web Services back-end and configure the server appropriately. </li>
<li> <strong>Write the Web Service code.</strong> Implement the necessary Web Services on the platform of your choice.</li>
<li> <strong>Use parameterized APIs to execute SQL queries.</strong> When implementing the Web Services, make sure to use parameterized APIs for database access to prevent SQL injection vulnerabilities.</li>
<li> <strong>Connect the application to the back-end.</strong> Add code to the iOS application to interact with the back-end. It might be necessary to add some pages for configuring the connection to the back-end, such as setting the URL of the Web Services and the authentication credentials.</li>
</ol>
