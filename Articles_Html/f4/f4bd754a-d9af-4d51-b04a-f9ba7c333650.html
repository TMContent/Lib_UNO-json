<h1>Description</h1>
  <p>You can take sensitive data directly from the user and construct a <b>SecureString</b> object one character at a time by using the <b>AppendChar</b> method. The following code example shows how to do this. </p>
  <pre>
    <pre>using System.Securtiy;<br />SecureString securePassword = new SecureString();<br /> Console.WriteLine("Enter Password....");<br /> while (true)<br /> &#123;<br />    ConsoleKeyInfo conKeyInfo = Console.ReadKey(true);<br />    if (conKeyInfo.Key == ConsoleKey.Enter)<br />        break;<br />    else if (conKeyInfo.Key == ConsoleKey.Escape)<br />        return;<br />    else if (conKeyInfo.Key == ConsoleKey.Backspace)<br />    &#123;<br />        if (securePassword.Length &#33;= 0)<br />            securePassword.RemoveAt(securePassword.Length - 1);<br />    &#125;<br />    else<br />        securePassword.AppendChar(conKeyInfo.KeyChar);<br />&#125;<br />Console.WriteLine(securePassword.Length.ToString());  </pre>
  </pre>
  <blockquote>
    <p>
      <b>Note</b>&nbsp;&nbsp;&nbsp;<b>SecureString</b> does not support inspection, comparison, or conversion functionality. It cannot be manipulated to reveal the data.</p>
  </blockquote>
  <p>To subsequently use the data from <b>SecureString</b>, use the <b>Marshal.SecureStringToBSTR</b> method, as follows.</p>
  <pre>
    <p>
    </p>
    <pre>using System.Runtime.InteropServices;<br />void UseSecretData(SecureString secret)<br />&#123;<br />    IntPtr bstr = Marshal.SecureStringToBSTR(secret);<br />    try<br />    &#123;<br />        // Use the bstr here<br />    &#125;<br />    finally<br />    &#123;<br />        // Make sure that the clear text data is zeroed out.<br />        Marshal.ZeroFreeBSTR(bstr);<br />    &#125;<br />&#125;  </pre>
  </pre>
  <p>As soon as you are finished with the data, make sure that you use the <b>Marshal.ZeroFreeBSTR</b> method to clear the text data. </p>
  <blockquote>
    <b>Note</b>&nbsp;&nbsp;&nbsp;Avoid converting back and forth between regular strings and secure strings because regular strings are immutable and you cannot clear them. As a result, you could have multiple copies of unencrypted strings in memory.</blockquote>Use of the <b>SecureString</b> class is less appropriate in ASP.NET applications. It is unlikely that you can extract data from a Web page that contains sensitive data (such as a credit card number) and place it inside a <b>SecureString</b> without it having already passed through intermediate <b>System</b>.<b> String</b> objects. <hr /><p>Adapted from Microsoft patterns & practices guidance.</p>