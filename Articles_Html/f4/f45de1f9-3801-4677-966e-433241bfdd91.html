<h1>What to Check For</h1>
  <p>Ensure that application keys are stored in a well defined location, such as the encrypted sections of the application's web.config or encrypted in the Windows Registry. Verify that they are not hard coded into the application or stored as plaintext inside configuration files.</p>
  <h1>Why</h1>
  <p>When faced with encryption, intruders attack the most vulnerable aspect: key management. Because keys are used to generate the encryption that protects sensitive data, the keys themselves become sensitive data that need to be protected. </p>
  <h1>How to Check</h1>
  <p>Use the following steps to verify a secure key storage location is used.</p>
  <ol>
    <li>
      <p />
      <strong>Identify the mechanism used for handling encryption keys.</strong> The mechanism used should be either the Windows Registry or the application's web.config file. Ensure that your application is using the most appropriate mechanism. If the storage locations for keys are not properly documented, look for encryption functions in the code and trace the key material back to see where it is stored, both temporarily and permanently. If you do have documentation, check that the code conforms to the documentation. When tracing through code, ensure that you look at the entire lifetime of the key in the system; keys may be written out insecurely after they are used, even if the path from a secure initial source to use is correct.<p>If you store your application's encryption keys into the Windows Registry, ensure that DPAPI is used to protect them. The following code gives an example of how this can be done:</p><pre>encKey = ProtectedData.Protect(encKey, salt, DataProtectionScope.CurrentUser);<br />RegistryKey rk = Registry.LocalMachine.OpenSubKey("SOFTWARE\\MyApp\\KeyStore", true);<br />rk.SetValue("encKey", wBuff, RegistryValueKind.Binary);</pre><p>If you store your application's encryption keys into web.config, ensure that they are stored into the <strong>appSettings</strong> section. Use the <strong>aspnet_regiis</strong> utility to check that the <strong>appSettings</strong> section is encrypted. </p></li>
    <li>
      <p>
        <strong>Ensure the key store is protected.</strong>
      </p>
      <ul>
        <li>
          <p>Ensure that either DPAPI or ASP.NET protected configuration files are being used. </p>
        </li>
        <li>
          <p>Verify that the appropriate permissions are set on the configuration files and registry keys so they can be only accessed by your application and its administrators. </p>
        </li>
        <li>
          <p>Verify that only the application and its administrators can access the IIS metabase.<br />Access to the metabase is controled with ACLs, similar to normal files or registry keys. Verify that only authorized accounts are listed in the &lt;CODE&gt;BUILTIN\Administrators&lt;/CODE&gt; group and that other ACLs are properly set up.</p>
        </li>
      </ul>
    </li>
    <li>
      <p>
        <strong>Verify the application securely handles keys.</strong>
      </p>
      <ul>
        <li>
          <p>Ensure that keys are not hard coded into the source code. When tracing back from an encryption or signing operation, if you see private key material included literally in the body of an application's source code, you have&nbsp;found a hard-coded key&nbsp;that needs to be moved to a protected keystore.</p>
        </li>
        <li>
          <p>Ensure that keys are not placed into unprotected configuration files. If a private key is read from a configuration file and the aspnet_regiis utility (or manual inspection) show that it is not encrypted, the key needs to be moved to a protected key store.</p>
        </li>
        <li>
          <p>Ensure that keys are unloaded from memory after use. If keys are left in memory instead of being cleared out when no longer needed, or if they are written to any form of temporary storage without protection, they are vulnerable to theft from memory or from the insecure store. Checking the entire lifetime of key material is important for finding this class of problem.</p>
        </li>
      </ul>
    </li>
  </ol>
  <h1>Problem Example</h1>
  <p>The following code shows a hard-coded encryption key inside the application. A determined attacker will be able to compromise the key&nbsp;after gaining&nbsp;access to the source code:</p>
  <pre>byte[] salt = MyApp.Crypto.GenerateSalt();<br />string secretString = "application's encryption key";<br />HMACSHA512 md = new HMACSHA512(salt);md.Initialize();<br />byte[] rawKey = md.ComputeHash(Encoding.ASCII.GetBytes(secretString));<br />md.Clear();<br /> Rijndael encMD = Rijndael.Create();<br />encMD.Key = rawKey;encMD.IV = salt;<br />ICryptoTransform encCT = encMD.CreateEncryptor();</pre>
  <h1>Related Guideline</h1>
  <ul>
    <li>
      <a href="/article/00000000-0000-0000-0000-00000060ef71">Guideline: Store Encryption Keys Using Protected Storage APIs</a>
    </li>
  </ul>
  <hr />
  <p>Adapted from Microsoft patterns & practices guidance. </p>