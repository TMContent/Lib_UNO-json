{
  "id": "b6795407-d01e-44ec-8aed-a440d388902b",
  "checksum": "7b083b3c1dafed738fd8fd66cc78efa15c51916d",
  "words": {
    "applies": [
      "h1"
    ],
    "to": [
      "h1",
      "h1",
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "p",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "font",
      "p",
      "p",
      "font",
      "font"
    ],
    "applications": [
      "p"
    ],
    "written": [
      "p"
    ],
    "using": [
      "p",
      "p",
      "ol",
      "li",
      "p",
      "p",
      "ul",
      "li"
    ],
    "scala": [
      "p",
      "td",
      "ul",
      "ul",
      "li",
      "li"
    ],
    "and": [
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "font",
      "title"
    ],
    "play": [
      "p",
      "ol",
      "li",
      "p",
      "p",
      "font"
    ],
    "framework": [
      "p",
      "p",
      "font"
    ],
    "21.0+": [
      "p"
    ],
    "what": [
      "h1"
    ],
    "do": [
      "h1",
      "p"
    ],
    "treat": [
      "p"
    ],
    "all": [
      "p",
      "p",
      "p",
      "font"
    ],
    "input": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "font",
      "title"
    ],
    "as": [
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "pre",
      "font",
      "span",
      "pre",
      "p",
      "pre"
    ],
    "untrusted": [
      "p",
      "p"
    ],
    "data": [
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p"
    ],
    "validate": [
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "title"
    ],
    "whitelist": [
      "p",
      "ol",
      "li",
      "p"
    ],
    "techniques": [
      "p",
      "ol",
      "li",
      "p"
    ],
    "check": [
      "p"
    ],
    "against": [
      "p"
    ],
    "known": [
      "p"
    ],
    "good": [
      "p",
      "p"
    ],
    "why": [
      "h1"
    ],
    "unchecked": [
      "p"
    ],
    "malicious": [
      "p",
      "ol",
      "li",
      "p",
      "p",
      "font"
    ],
    "may": [
      "p"
    ],
    "lead": [
      "p"
    ],
    "integer": [
      "p",
      "ol",
      "li",
      "p"
    ],
    "overflows": [
      "p",
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p"
    ],
    "injection": [
      "p"
    ],
    "based": [
      "p",
      "p",
      "ol",
      "li",
      "p"
    ],
    "attacks": [
      "p"
    ],
    "denial": [
      "p"
    ],
    "of": [
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "font"
    ],
    "service": [
      "p"
    ],
    "or": [
      "p",
      "ol",
      "li",
      "p"
    ],
    "information": [
      "p",
      "ul",
      "li"
    ],
    "disclosure": [
      "p"
    ],
    "when": [
      "h1",
      "ol",
      "li",
      "p",
      "p",
      "font",
      "p",
      "font"
    ],
    "always": [
      "p"
    ],
    "not": [
      "p",
      "ol",
      "li",
      "p",
      "pre",
      "p",
      "font",
      "p",
      "pre",
      "font",
      "span",
      "p",
      "font"
    ],
    "assume": [
      "p"
    ],
    "that": [
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "li",
      "p",
      "pre",
      "li",
      "p",
      "li",
      "p",
      "p",
      "font",
      "p",
      "pre",
      "font",
      "span",
      "p",
      "font"
    ],
    "is": [
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p",
      "pre",
      "li",
      "li",
      "p",
      "p",
      "li",
      "li",
      "p",
      "p",
      "pre",
      "p",
      "p",
      "font",
      "font",
      "p",
      "font",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "font",
      "font",
      "font",
      "span",
      "span",
      "span",
      "p",
      "p",
      "font",
      "font",
      "ul",
      "li"
    ],
    "on": [
      "p",
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p",
      "p",
      "font",
      "p",
      "p",
      "font",
      "font",
      "ul",
      "ul",
      "li",
      "li"
    ],
    "origin": [
      "p"
    ],
    "how": [
      "h1",
      "p",
      "font",
      "p",
      "font"
    ],
    "can": [
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p",
      "li",
      "p",
      "li",
      "li",
      "p",
      "p",
      "pre"
    ],
    "vary": [
      "p"
    ],
    "in": [
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p",
      "li",
      "li",
      "p",
      "p",
      "li",
      "p",
      "p",
      "font",
      "p",
      "pre",
      "p",
      "p",
      "font",
      "font",
      "p",
      "pre",
      "ul",
      "li"
    ],
    "length": [
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "strong",
      "title"
    ],
    "type": [
      "p",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "strong",
      "title"
    ],
    "contents": [
      "p",
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p",
      "strong"
    ],
    "verify": [
      "p"
    ],
    "meets": [
      "p"
    ],
    "your": [
      "p",
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p"
    ],
    "application's": [
      "p"
    ],
    "expectations": [
      "p"
    ],
    "validating": [
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "p",
      "strong",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "strong",
      "li",
      "p",
      "strong"
    ],
    "an": [
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "p",
      "li",
      "li",
      "p",
      "p",
      "li",
      "p",
      "p",
      "font",
      "p",
      "font"
    ],
    "input's": [
      "ol",
      "ol",
      "ol",
      "li",
      "p",
      "li",
      "p",
      "li",
      "p"
    ],
    "by": [
      "ol",
      "li",
      "p"
    ],
    "checking": [
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p"
    ],
    "a": [
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "li",
      "p",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "font",
      "p",
      "font",
      "p",
      "font",
      "ul",
      "li"
    ],
    "string's": [
      "ol",
      "li",
      "p"
    ],
    "the": [
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "pre",
      "li",
      "li",
      "p",
      "p",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "pre",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "font",
      "font",
      "font",
      "font",
      "font",
      "font",
      "p",
      "p",
      "font",
      "font",
      "p",
      "pre",
      "font",
      "span",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "font",
      "font",
      "font",
      "span",
      "span",
      "span",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "font",
      "font",
      "font",
      "font",
      "font",
      "font",
      "font",
      "font",
      "font",
      "font",
      "font"
    ],
    "number": [
      "ol",
      "ol",
      "li",
      "p",
      "li",
      "p",
      "pre"
    ],
    "bits": [
      "ol",
      "li",
      "p"
    ],
    "numeric": [
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p"
    ],
    "value": [
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p"
    ],
    "help": [
      "ol",
      "li",
      "p"
    ],
    "prevent": [
      "ol",
      "li",
      "p"
    ],
    "buffer": [
      "ol",
      "li",
      "p"
    ],
    "well": [
      "ol",
      "li",
      "p"
    ],
    "values": [
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p",
      "pre",
      "p",
      "pre"
    ],
    "simple": [
      "ol",
      "li",
      "p"
    ],
    "way": [
      "ol",
      "li",
      "p"
    ],
    "for": [
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "li",
      "p",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "p",
      "font",
      "p",
      "font",
      "p",
      "pre",
      "font",
      "span",
      "p",
      "pre",
      "font",
      "span",
      "p",
      "font",
      "p",
      "font",
      "p",
      "p",
      "pre",
      "pre",
      "p",
      "font",
      "ul",
      "li",
      "title"
    ],
    "forms": [
      "ol",
      "li",
      "p"
    ],
    "through": [
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p",
      "li",
      "p"
    ],
    "use": [
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "td"
    ],
    "of minlengthlength:": [
      "ol",
      "li",
      "p"
    ],
    "int and maxlength(length:": [
      "ol",
      "li",
      "p"
    ],
    "int from": [
      "ol",
      "li",
      "p"
    ],
    "the playapi.data.validationconstraints": [
      "ol",
      "li",
      "p"
    ],
    "object": [
      "ol",
      "li",
      "p",
      "pre",
      "pre",
      "pre",
      "p",
      "font",
      "p",
      "pre"
    ],
    "frameworkobject": [
      "ol",
      "li",
      "p"
    ],
    "signup": [
      "ol",
      "li",
      "p",
      "pre",
      "p",
      "pre",
      "font",
      "span"
    ],
    "extends": [
      "ol",
      "ol",
      "ol",
      "li",
      "p",
      "pre",
      "li",
      "p",
      "pre",
      "li",
      "p",
      "pre",
      "p",
      "pre"
    ],
    "controller": [
      "ol",
      "ol",
      "ol",
      "li",
      "p",
      "pre",
      "li",
      "p",
      "pre",
      "li",
      "p",
      "pre",
      "p",
      "pre",
      "font",
      "span"
    ],
    "{": [
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "li",
      "p",
      "pre",
      "li",
      "p",
      "pre",
      "p",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "/**": [
      "ol",
      "ol",
      "li",
      "p",
      "pre",
      "li",
      "p",
      "pre"
    ],
    "*": [
      "ol",
      "ol",
      "li",
      "p",
      "pre",
      "li",
      "p",
      "pre"
    ],
    "sign": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "up": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "form": [
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p",
      "pre",
      "pre",
      "li",
      "p",
      "pre",
      "p",
      "pre"
    ],
    "definition": [
      "ol",
      "ol",
      "li",
      "p",
      "pre",
      "li",
      "p",
      "pre"
    ],
    "*/": [
      "ol",
      "ol",
      "li",
      "p",
      "pre",
      "li",
      "p",
      "pre"
    ],
    "val": [
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "li",
      "p",
      "pre",
      "li",
      "p",
      "pre",
      "p",
      "pre",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "p",
      "pre",
      "p",
      "pre"
    ],
    "signupform": [
      "ol",
      "li",
      "p",
      "pre",
      "p",
      "pre"
    ],
    "formuser]": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "=": [
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "li",
      "p",
      "pre",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "pre",
      "pre",
      "p",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "pre",
      "pre"
    ],
    "//": [
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre"
    ],
    "define": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "mapping": [
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "p",
      "pre"
    ],
    "will": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "handle": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "user": [
      "ol",
      "li",
      "p",
      "pre",
      "p",
      "p",
      "font",
      "font",
      "p",
      "font",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "p",
      "pre",
      "font",
      "span",
      "p",
      "p",
      "p",
      "font",
      "font",
      "font"
    ],
    "\"firstname\"": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "-": [
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "li",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre"
    ],
    "textmaxlength": [
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p",
      "pre",
      "pre"
    ],
    "20,": [
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p",
      "pre",
      "pre"
    ],
    "\"lastname\"": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "\"username\"": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "textminlength": [
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre"
    ],
    "4,": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "\"password\"": [
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p",
      "pre",
      "pre",
      "p",
      "pre"
    ],
    "6,": [
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p",
      "pre",
      "pre"
    ],
    "create": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "tuple": [
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p",
      "pre",
      "pre",
      "li",
      "li",
      "p",
      "p",
      "pre",
      "pre"
    ],
    "password/confirm": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "\"main\"": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "\"confirm\"": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "text": [
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "p",
      "pre",
      "li",
      "li",
      "p",
      "p",
      "pre",
      "pre",
      "li",
      "p",
      "pre",
      "td",
      "p",
      "pre"
    ],
    ",": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "}also": [
      "ol",
      "li",
      "p"
    ],
    "you": [
      "ol",
      "ol",
      "li",
      "p",
      "li",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "p",
      "p",
      "pre",
      "pre"
    ],
    "any": [
      "ol",
      "li",
      "p"
    ],
    "bigint/bigdecimal": [
      "ol",
      "li",
      "p"
    ],
    "follows def": [
      "ol",
      "li",
      "p"
    ],
    "productcheck": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "action": [
      "ol",
      "li",
      "p",
      "pre",
      "pre"
    ],
    "implicit": [
      "ol",
      "li",
      "p",
      "pre",
      "p",
      "pre"
    ],
    "request": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "prodformbindfromrequest.fold(": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "errors": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "badrequestviews.html.index(errors,": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "\"there": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "some": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "error\"),": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "prodform": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "proname": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "prodformpname": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "prodprice": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "prodformprice": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "ifprodprice.compare(bigint(0))": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "-1": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "&&": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "prodpricecompare(bigint(integer.max_value))": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "println\"true\")": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "...........": [
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p",
      "pre",
      "pre"
    ],
    "//code": [
      "ol",
      "ol",
      "ol",
      "li",
      "p",
      "pre",
      "li",
      "li",
      "p",
      "p",
      "pre",
      "pre",
      "p",
      "p",
      "pre",
      "pre"
    ],
    "true": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "}": [
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "pre",
      "pre",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre"
    ],
    "else": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "println\"false\")": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "code": [
      "ol",
      "li",
      "p",
      "pre",
      "p",
      "font",
      "p",
      "font",
      "p",
      "pre",
      "font",
      "span",
      "p",
      "pre",
      "font",
      "span",
      "p",
      "font",
      "p",
      "font"
    ],
    "exception": [
      "ol",
      "li",
      "p",
      "pre",
      "pre"
    ],
    "important": [
      "ol",
      "li",
      "p"
    ],
    "application": [
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p",
      "p",
      "font",
      "p",
      "p",
      "font",
      "font"
    ],
    "expects": [
      "ol",
      "li",
      "p"
    ],
    "specific": [
      "ol",
      "li",
      "p"
    ],
    "non-string": [
      "ol",
      "li",
      "p"
    ],
    "parameter": [
      "ol",
      "li",
      "p"
    ],
    "difference": [
      "ol",
      "li",
      "p"
    ],
    "trigger": [
      "ol",
      "li",
      "p"
    ],
    "unhandled": [
      "ol",
      "li",
      "p"
    ],
    "exceptions": [
      "ol",
      "li",
      "p"
    ],
    "would": [
      "ol",
      "ol",
      "li",
      "p",
      "li",
      "p"
    ],
    "throw": [
      "ol",
      "li",
      "p"
    ],
    "into": [
      "ol",
      "li",
      "p",
      "p",
      "pre",
      "p",
      "font"
    ],
    "unknown": [
      "ol",
      "li",
      "p"
    ],
    "state": [
      "ol",
      "li",
      "p"
    ],
    "following": [
      "ol",
      "ol",
      "li",
      "p",
      "li",
      "p",
      "p",
      "font",
      "p",
      "font"
    ],
    "example": [
      "ol",
      "ol",
      "li",
      "p",
      "li",
      "p",
      "h1",
      "h1"
    ],
    "formsobject": [
      "ol",
      "ol",
      "li",
      "p",
      "li",
      "p"
    ],
    "contactform": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "contact": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "appointmentmapping": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "\"location\"": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "\"start\"": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "\"date\"": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "date": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "\"time\"": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "text,": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "\"attendees\"": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "listmapping(": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "\"name\"": [
      "ol",
      "ol",
      "li",
      "p",
      "pre",
      "li",
      "p",
      "pre"
    ],
    "\"email\"": [
      "ol",
      "li",
      "p",
      "pre",
      "p",
      "pre"
    ],
    "email\r\n)}": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "blacklist": [
      "ol",
      "li",
      "p"
    ],
    "choose": [
      "ol",
      "li",
      "p"
    ],
    "technique": [
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p"
    ],
    "constraints": [
      "ol",
      "li",
      "p"
    ],
    "are": [
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "p",
      "p",
      "pre",
      "pre"
    ],
    "imposed": [
      "ol",
      "li",
      "p"
    ],
    "if": [
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "pre",
      "pre"
    ],
    "follows": [
      "ol",
      "li",
      "p"
    ],
    "tight": [
      "ol",
      "li",
      "p"
    ],
    "structure": [
      "ol",
      "li",
      "p"
    ],
    "format": [
      "ol",
      "li",
      "p",
      "title"
    ],
    "whitelisting": [
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p"
    ],
    "alone": [
      "ol",
      "li",
      "p"
    ],
    "weed": [
      "ol",
      "li",
      "p"
    ],
    "out": [
      "ol",
      "li",
      "p"
    ],
    "there": [
      "ol",
      "li",
      "p",
      "p",
      "font"
    ],
    "unknowns": [
      "ol",
      "li",
      "p"
    ],
    "about": [
      "ol",
      "li",
      "p"
    ],
    "you'll": [
      "ol",
      "li",
      "p"
    ],
    "need": [
      "ol",
      "li",
      "p"
    ],
    "combination": [
      "ol",
      "li",
      "p"
    ],
    "black": [
      "ol",
      "li",
      "p"
    ],
    "white": [
      "ol",
      "li",
      "p"
    ],
    "listing": [
      "ol",
      "li",
      "p"
    ],
    "general": [
      "ol",
      "li",
      "p"
    ],
    "blacklisting": [
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p"
    ],
    "backup": [
      "ol",
      "li",
      "p"
    ],
    "spiral-out": [
      "ol",
      "li",
      "p"
    ],
    "approach": [
      "ol",
      "li",
      "p"
    ],
    "initial": [
      "ol",
      "li",
      "p"
    ],
    "validation": [
      "ol",
      "li",
      "p",
      "p",
      "font",
      "p",
      "font"
    ],
    "cannot": [
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p"
    ],
    "then": [
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p"
    ],
    "fall": [
      "ol",
      "li",
      "p"
    ],
    "back": [
      "ol",
      "li",
      "p",
      "p",
      "font",
      "p",
      "pre",
      "font",
      "span",
      "p",
      "font"
    ],
    "discard": [
      "ol",
      "li",
      "p"
    ],
    "implementing": [
      "ol",
      "li",
      "p"
    ],
    "this": [
      "ol",
      "li",
      "p",
      "p",
      "p",
      "font",
      "font"
    ],
    "validateproduct": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "productform": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "formmapping(": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "\"ean\"": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "longnumberverifying(\"this": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "product": [
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p",
      "pre",
      "pre"
    ],
    "already": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "exists!\"": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "productfindbyean(_).isempty),": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "nonemptytext": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "\"description\"": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "\"pieces\"": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "\"active\"": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "boolean(product.apply)(product.unapply).verifying(": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "\"product": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "be": [
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "pre",
      "p",
      "p",
      "font"
    ],
    "active": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "description": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "empty\"": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "!productactive": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "||": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "productdescription.nonempty))\r\n}using": [
      "ol",
      "li"
    ],
    "regular": [
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p",
      "td",
      "ul",
      "ul",
      "li",
      "li"
    ],
    "expressions": [
      "ol",
      "li",
      "p",
      "p",
      "ul",
      "li"
    ],
    "fix": [
      "ol",
      "li",
      "p"
    ],
    "belowval": [
      "ol",
      "li"
    ],
    "pid": [
      "ol",
      "li",
      "p",
      "pre",
      "p",
      "pre"
    ],
    "productformproductid\r\nval": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "pname": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "productformproductname\r\nval": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "products": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "productfindproduct(pid,": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "pname\r\nval": [
      "ol",
      "li",
      "p",
      "pre"
    ],
    "whitelistpattern": [
      "ol",
      "li",
      "p",
      "pre",
      "p",
      "pre"
    ],
    "\"\\\\w|\\\\d)+\".r\r\nval": [
      "ol",
      "li",
      "p",
      "pre",
      "p",
      "pre"
    ],
    "issafe": [
      "ol",
      "li",
      "p",
      "pre",
      "p",
      "pre"
    ],
    "=whitelistpatternpattern.matcher(pname).matchesif": [
      "ol",
      "li",
      "p"
    ],
    "issafe){......": [
      "ol",
      "li",
      "p"
    ],
    "action}else{.....": [
      "ol",
      "li",
      "p"
    ],
    "exception}examples": [
      "ol",
      "li",
      "p"
    ],
    "useful": [
      "ol",
      "li",
      "p"
    ],
    "expressionsuseregular": [
      "ol",
      "li"
    ],
    "expressionscala": [
      "ol",
      "li",
      "p",
      "table",
      "tbody",
      "tr"
    ],
    "stringvalid": [
      "ol",
      "li",
      "p",
      "table",
      "tbody"
    ],
    "e-mail": [
      "ol",
      "li",
      "p",
      "table",
      "tbody",
      "tr",
      "td"
    ],
    "address^\\w+\\.|_|-){0,1}\\w+@(\\w+\\.)*\\w{3,1024}\\.([a-za-z]{2}\\.){0,1}[a-za-z]{2,4}$^\\\\w+(\\\\.|_|-){0,1}\\\\w+@(\\\\w+\\\\.)*\\\\w{3,}\\\\.([a-za-z]{2}\\\\.){0,1}[a-za-z]{2,4}$alpha-numeric": [
      "ol",
      "li",
      "p",
      "table",
      "tbody"
    ],
    "free": [
      "ol",
      "li",
      "p",
      "table",
      "tbody",
      "tr",
      "td"
    ],
    "text\\w|\\d|\\s|;|\\?|!|,|\\.|-|:)+(\\\\w|\\\\d|\\\\s|;|\\\\?|!|,|\\\\.|-|:)+word": [
      "ol",
      "li",
      "p",
      "table",
      "tbody"
    ],
    "characters\\w+\\\\w+numbers\\d+\\\\d+": [
      "ol",
      "li",
      "p",
      "table",
      "tbody"
    ],
    "minlengthlength:": [
      "i"
    ],
    "int": [
      "i",
      "i"
    ],
    "maxlengthlength:": [
      "i"
    ],
    "playapi.data.validation": [
      "i"
    ],
    "def": [
      "pre",
      "p",
      "pre"
    ],
    "productdescription.nonempty))\r\n}": [
      "p",
      "pre"
    ],
    "below": [
      "p"
    ],
    "=whitelistpatternpattern.matcher(pname).matches": [
      "pre"
    ],
    "issafe){": [
      "pre"
    ],
    ".....": [
      "pre",
      "pre"
    ],
    "}else{": [
      "pre"
    ],
    "useregular": [
      "p",
      "table",
      "tbody",
      "tr"
    ],
    "string": [
      "tr",
      "td",
      "p",
      "font",
      "p",
      "p",
      "pre",
      "pre",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre"
    ],
    "expression": [
      "td",
      "ul",
      "li"
    ],
    "valid": [
      "tr",
      "td"
    ],
    "address^\\w+\\.|_|-){0,1}\\w+@(\\w+\\.)*\\w{3,1024}\\.([a-za-z]{2}\\.){0,1}[a-za-z]{2,4}$^\\\\w+(\\\\.|_|-){0,1}\\\\w+@(\\\\w+\\\\.)*\\\\w{3,}\\\\.([a-za-z]{2}\\\\.){0,1}[a-za-z]{2,4}$": [
      "tr"
    ],
    "address": [
      "td"
    ],
    "^\\w+\\.|_|-){0,1}\\w+@(\\w+\\.)*\\w{3,1024}\\.([a-za-z]{2}\\.){0,1}[a-za-z]{2,4}$": [
      "td"
    ],
    "^\\\\w+\\\\.|_|-){0,1}\\\\w+@(\\\\w+\\\\.)*\\\\w{3,}\\\\.([a-za-z]{2}\\\\.){0,1}[a-za-z]{2,4}$": [
      "td"
    ],
    "alpha-numeric": [
      "tr",
      "td"
    ],
    "text\\w|\\d|\\s|;|\\?|!|,|\\.|-|:)+(\\\\w|\\\\d|\\\\s|;|\\\\?|!|,|\\\\.|-|:)+": [
      "tr"
    ],
    "\\w|\\d|\\s|;|\\?|!|,|\\.|-|:)+": [
      "td"
    ],
    "\\\\w|\\\\d|\\\\s|;|\\\\?|!|,|\\\\.|-|:)+": [
      "td"
    ],
    "word": [
      "tr",
      "td"
    ],
    "characters\\w+\\\\w+": [
      "tr"
    ],
    "characters": [
      "td",
      "p",
      "font"
    ],
    "\\w+": [
      "td"
    ],
    "\\\\w+": [
      "td"
    ],
    "numbers\\d+\\\\d+": [
      "tr"
    ],
    "numbers": [
      "td"
    ],
    "\\d+": [
      "td"
    ],
    "\\\\d+": [
      "td"
    ],
    "problem": [
      "h1"
    ],
    "shows": [
      "p",
      "font",
      "p",
      "font"
    ],
    "registers": [
      "p",
      "font",
      "p",
      "font"
    ],
    "account": [
      "p",
      "font",
      "p",
      "font"
    ],
    "post-registration": [
      "p",
      "font",
      "p",
      "font"
    ],
    "logs": [
      "p",
      "font",
      "p",
      "font"
    ],
    "registered": [
      "p",
      "font",
      "p",
      "font"
    ],
    "name": [
      "p",
      "font",
      "p",
      "font",
      "p",
      "pre",
      "p",
      "pre",
      "font",
      "span",
      "p",
      "font",
      "p",
      "font",
      "p",
      "pre"
    ],
    "reflected": [
      "p",
      "font",
      "p",
      "pre",
      "font",
      "span",
      "p",
      "font"
    ],
    "screen": [
      "p",
      "font",
      "p",
      "font"
    ],
    "because": [
      "p",
      "font"
    ],
    "it": [
      "p",
      "font"
    ],
    "does": [
      "p",
      "font"
    ],
    "html": [
      "p",
      "font",
      "p",
      "p",
      "pre",
      "pre",
      "font",
      "font",
      "span",
      "span",
      "p",
      "p",
      "font",
      "font",
      "p",
      "font"
    ],
    "encode": [
      "p",
      "font"
    ],
    "echoed": [
      "p",
      "font"
    ],
    "vulnerable": [
      "p",
      "font"
    ],
    "persistent": [
      "p",
      "font"
    ],
    "cross-site": [
      "p",
      "font"
    ],
    "scripting": [
      "p",
      "font"
    ],
    "creation": [
      "p",
      "font"
    ],
    "model": [
      "p",
      "font"
    ],
    "--": [
      "p",
      "font"
    ],
    "notice": [
      "p",
      "font"
    ],
    "with": [
      "p",
      "font"
    ],
    "no": [
      "p",
      "font"
    ],
    "validations": [
      "p",
      "font"
    ],
    "allows": [
      "p",
      "font"
    ],
    "special": [
      "p",
      "font"
    ],
    "userinfoservicestring,": [
      "p",
      "pre"
    ],
    "passwordservice": [
      "p",
      "pre"
    ],
    "mypasswordservice": [
      "p",
      "pre"
    ],
    "registeremail:": [
      "p",
      "pre"
    ],
    "namestring,": [
      "p",
      "pre"
    ],
    "password": [
      "p",
      "pre",
      "p",
      "pre"
    ],
    "encryptedpassword": [
      "p",
      "p",
      "pre",
      "pre"
    ],
    "passwordserviceencryptpassword(password)": [
      "p",
      "pre"
    ],
    "useremail,": [
      "p",
      "p",
      "pre",
      "pre"
    ],
    "createuser)": [
      "p",
      "pre"
    ],
    "}\r\r\ndef": [
      "p",
      "pre"
    ],
    "createuser:": [
      "p",
      "pre"
    ],
    "user:": [
      "p",
      "pre"
    ],
    "dbwithconnection": [
      "p",
      "pre"
    ],
    "connection": [
      "p",
      "pre"
    ],
    "sql": [
      "p",
      "pre"
    ],
    "\"\"\"": [
      "p",
      "p",
      "pre",
      "pre"
    ],
    "insert": [
      "p",
      "pre"
    ],
    "{email}": [
      "p",
      "pre"
    ],
    "{name}": [
      "p",
      "pre"
    ],
    "{password}": [
      "p",
      "pre"
    ],
    ".on(": [
      "p",
      "pre"
    ],
    "'email": [
      "p",
      "pre"
    ],
    "'name": [
      "p",
      "pre"
    ],
    "username,": [
      "p",
      "pre"
    ],
    "'password": [
      "p",
      "pre"
    ],
    "userpassword.underlying": [
      "p",
      "pre"
    ],
    ".executeupdate()": [
      "p",
      "pre"
    ],
    "email": [
      "p",
      "pre"
    ],
    "\"fullname\"": [
      "p",
      "pre"
    ],
    "weakpassword": [
      "p",
      "pre"
    ],
    "(signupdata.apply)(_": [
      "p",
      "pre"
    ],
    "none": [
      "p",
      "p",
      "pre",
      "pre",
      "p",
      "pre"
    ],
    "case": [
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "pre",
      "pre"
    ],
    "class": [
      "p",
      "pre"
    ],
    "signupdataemail:": [
      "p",
      "pre"
    ],
    "fullname": [
      "p",
      "pre"
    ],
    "template": [
      "p",
      "pre",
      "font",
      "span",
      "p",
      "font",
      "p",
      "font"
    ],
    "where": [
      "p",
      "pre",
      "font",
      "span"
    ],
    "redirected": [
      "p",
      "pre",
      "font",
      "span"
    ],
    "after": [
      "p",
      "pre",
      "font",
      "span"
    ],
    "successful": [
      "p",
      "pre",
      "font",
      "span"
    ],
    "login--notice": [
      "p",
      "pre",
      "font",
      "span"
    ],
    "which": [
      "p",
      "pre",
      "font",
      "span"
    ],
    "sanitized": [
      "p",
      "pre",
      "font",
      "span"
    ],
    "raw": [
      "p",
      "pre",
      "font",
      "span"
    ],
    "@)(implicit": [
      "p",
      "pre",
      "p",
      "pre"
    ],
    "ctx": [
      "p",
      "pre",
      "p",
      "pre"
    ],
    "mycontext_])\r\n\r\n@base.layout()": [
      "p",
      "pre",
      "p",
      "pre"
    ],
    "div": [
      "p",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "class=\"container\"": [
      "p",
      "pre",
      "p",
      "pre"
    ],
    "class=\"row\"": [
      "p",
      "pre",
      "p",
      "pre"
    ],
    "class=\"span12\"": [
      "p",
      "pre",
      "p",
      "pre"
    ],
    "class=\"well\"": [
      "p",
      "pre",
      "p",
      "pre"
    ],
    "style=\"height": [
      "p",
      "pre",
      "p",
      "pre"
    ],
    "600px\"": [
      "p",
      "pre",
      "p",
      "pre"
    ],
    "h1": [
      "p",
      "pre",
      "p",
      "pre"
    ],
    "style=\"text-align": [
      "p",
      "pre",
      "p",
      "pre"
    ],
    "center\"main": [
      "p",
      "pre",
      "p",
      "pre"
    ],
    "page/h1>": [
      "p",
      "pre",
      "p",
      "pre"
    ],
    "p": [
      "p",
      "pre",
      "p",
      "pre"
    ],
    "style=\"font-size": [
      "p",
      "pre",
      "p",
      "pre"
    ],
    "20px": [
      "p",
      "pre",
      "p",
      "pre"
    ],
    "text-align": [
      "p",
      "pre",
      "p",
      "pre"
    ],
    "center": [
      "p",
      "pre",
      "p",
      "pre"
    ],
    "margin-top": [
      "p",
      "pre",
      "p",
      "pre"
    ],
    "15px\"": [
      "p",
      "pre",
      "p",
      "pre"
    ],
    "@ctxme": [
      "p",
      "pre",
      "p",
      "pre"
    ],
    "match": [
      "p",
      "pre",
      "p",
      "pre"
    ],
    "anonymous": [
      "p",
      "pre",
      "p",
      "pre"
    ],
    "someuser)": [
      "p",
      "pre",
      "p",
      "pre"
    ],
    "currently": [
      "p",
      "pre",
      "p",
      "pre"
    ],
    "logged": [
      "p",
      "pre",
      "p",
      "pre"
    ],
    "@htmluser.name).": [
      "p",
      "pre"
    ],
    "/p>": [
      "p",
      "pre",
      "p",
      "pre"
    ],
    "/div>": [
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre"
    ],
    "/div>\r\n}": [
      "p",
      "pre",
      "p",
      "pre"
    ],
    "solution": [
      "h1"
    ],
    "again": [
      "p",
      "font"
    ],
    "but": [
      "p",
      "font"
    ],
    "time": [
      "p",
      "font"
    ],
    "automatically": [
      "p",
      "font"
    ],
    "performs": [
      "p",
      "font"
    ],
    "encoding": [
      "p",
      "font"
    ],
    "entries": [
      "p",
      "font"
    ],
    "protects": [
      "p",
      "font"
    ],
    "from": [
      "p",
      "font"
    ],
    "xss": [
      "p",
      "font"
    ],
    "additionally": [
      "p",
      "font"
    ],
    "should": [
      "p",
      "font"
    ],
    "regex": [
      "p",
      "font",
      "p",
      "font",
      "a"
    ],
    "name parameter": [
      "p",
      "font"
    ],
    "make": [
      "p",
      "font"
    ],
    "sure": [
      "p",
      "font"
    ],
    "able": [
      "p",
      "font"
    ],
    "enter": [
      "p",
      "font"
    ],
    "names": [
      "p",
      "font"
    ],
    "signupformempid\r\nval": [
      "p",
      "pre"
    ],
    "signupformproductname\r\nval": [
      "p",
      "pre"
    ],
    "emp": [
      "p",
      "pre"
    ],
    "empfindemp(pid,": [
      "p",
      "pre"
    ],
    "name\r\nval": [
      "p",
      "pre"
    ],
    "=whitelistpatternpattern.matcher(name).matches\r\nif": [
      "p",
      "pre"
    ],
    "issafe){\r\n......": [
      "p",
      "pre"
    ],
    "action\r}else{\r\n......": [
      "p",
      "pre"
    ],
    "exception\r}": [
      "p",
      "pre"
    ],
    "@username.": [
      "p",
      "pre"
    ],
    "additional": [
      "h1"
    ],
    "resources": [
      "h1"
    ],
    "tutorial": [
      "ul",
      "li"
    ],
    "available": [
      "ul",
      "li"
    ],
    "at regular-expressionsinfo.": [
      "ul",
      "li"
    ],
    "more": [
      "ul",
      "li"
    ],
    "see": [
      "ul",
      "li"
    ],
    "documentation": [
      "ul",
      "ul",
      "li",
      "li"
    ],
    "for regex": [
      "ul",
      "li"
    ],
    "pattern in": [
      "ul",
      "li"
    ],
    "regular-expressionsinfo": [
      "a"
    ],
    "pattern": [
      "a"
    ],
    "range": [
      "title"
    ]
  },
  "tags": {
    "h1": [
      "Applies to",
      "What to Do",
      "Why",
      "When",
      "How",
      "Problem Example",
      "Solution Example",
      "Additional Resources"
    ],
    "p": [
      "Applications written using Scala and Play Framework 2.1.0+",
      "Treat all input as untrusted data. Validate untrusted data using whitelist techniques to check against known good input.",
      "Unchecked malicious input may lead to integer overflows, injection based attacks, denial of service or information disclosure.",
      "Always validate input. Do not assume that input is good based on origin.",
      "Input can vary in length, data type, and contents. Verify that all input meets your application's expectations.",
      "Validating length: Validate an input's length by checking a string's length or the number of bits in a numeric value. Checking the length can help prevent buffer overflows as well as integer overflows in numeric values. A simple way to validate the numeric value for forms is through the use of minLength(length: Int) and maxLength(length: Int) from the play.api.data.validationconstraints object of Play Framework:object SignUp extends Controller {\r\n  \r\n  /**\r\n   * Sign Up Form definition.\r\n   */\r\n  val signupForm: Form[User] = Form(\r\n    \r\n    // Define a mapping that will handle User values\r\n    mapping(\r\n      \"firstname\" -> text(maxLength = 20),\r\n      \"lastname\" -> text(maxLength = 20),\r\n      \"username\" -> text(minLength = 4),\r\n      \"password\" -> text(minLength = 6),   \r\n      // Create a tuple mapping for the password/confirm\r\n      \"password\" -> tuple(\r\n        \"main\" -> text(minLength = 6),\r\n        \"confirm\" -> text\r\n      ),\r\n\r\n    )\r\n  )\r\n  }Also, you can validate any numeric value through the use of BigInt/BigDecimal as follows: def productcheck = Action { implicit request =>\r\n    prodForm.bindFromRequest.fold(\r\n      errors => BadRequest(views.html.index(errors, \"There is some error\")),\r\n      prodForm => {\r\n\r\n        val proname = prodForm.pname\r\n        val prodprice = prodForm.price\r\n        if(prodprice.compare(BigInt(0)) > -1\r\n          && prodprice.compare(BigInt(Integer.MAX_VALUE)) \r\n        {\r\n          println(\"true\")\r\n          ............ //code for true\r\n        }\r\n        else\r\n        {\r\n          println(\"false\")\r\n          ............ // code for exception\r\n        }",
      "Validating type: Validating the input's data type is important when your application expects a specific non-string parameter. Difference in data type can trigger unhandled exceptions that would throw your application into an unknown state. The following is an example for validating in forms:object ContactForm extends Controller {\r\n  \r\n  /**\r\n   * Contact Form definition.\r\n  */\r\n  val appointmentMapping = tuple(\r\n  \"location\" -> text,\r\n  \"start\" -> tuple(\r\n    \"date\" -> date,\r\n    \"time\" -> text),\r\n  \"attendees\" -> list(mapping(\r\n    \"name\" -> text,\r\n    \"email\" -> email)\r\n)}",
      "Validating contents: Use whitelist and blacklist techniques to validate the input's contents. Choose the technique based on the constraints that are imposed on the input: If the input follows a tight structure and format, you can use whitelisting alone to weed out malicious input. If there are unknowns about the input, you'll need a combination of black and white listing. In general, use blacklisting as a backup to whitelisting, through a spiral-out approach: Use whitelisting for the initial validation. If whitelisting cannot validate the input, then fall back to blacklisting. If blacklisting cannot validate, then discard the input. The following is an example of implementing this technique using forms:object ValidateProduct extends Controller {\r\n\r\n  val productForm = Form(mapping(\r\n    \"ean\" -> longNumber.verifying(\"This product already exists!\", Product.findByEan(_).isEmpty),\r\n    \"name\" -> nonEmptyText,\r\n    \"description\" -> text,\r\n    \"pieces\" -> number,\r\n    \"active\" -> boolean)(Product.apply)(Product.unapply).verifying(\r\n      \"Product can not be active if the description is empty\", product =>\r\n        !product.active || product.description.nonEmpty))\r\n}",
      "Using regular expressions, the fix would be as below:",
      "val pid = ProductForm.productid\r\nval pname = ProductForm.productname\r\nval products = Product.findProduct(pid, pname)\r\nval whitelistPattern = \"(\\\\w|\\\\d)+\".r\r\nval issafe =whitelistPattern.pattern.matcher(pname).matchesif (issafe){...... //Code for Action}else{...... //Code for Exception}Examples of useful regular expressions:",
      "",
      "UseRegular ExpressionScala StringValid E-Mail Address^\\w+(\\.|_|-){0,1}\\w+@(\\w+\\.)*\\w{3,1024}\\.([a-zA-Z]{2}\\.){0,1}[a-zA-Z]{2,4}$^\\\\w+(\\\\.|_|-){0,1}\\\\w+@(\\\\w+\\\\.)*\\\\w{3,}\\\\.([a-zA-Z]{2}\\\\.){0,1}[a-zA-Z]{2,4}$Alpha-numeric free text(\\w|\\d|\\s|;|\\?|!|,|\\.|-|:)+(\\\\w|\\\\d|\\\\s|;|\\\\?|!|,|\\\\.|-|:)+Word characters\\w+\\\\w+Numbers\\d+\\\\d+",
      "",
      "",
      "The following code shows how a user registers for an account. Post-registration, when the user logs in, the registered name is reflected back on the screen. Because it does not HTML encode the echoed input, the application is vulnerable to persistent cross-site scripting.",
      "Code for the User creation model -- notice that the name is a String object with no validations and allows special characters:",
      "object User extends UserInfoService[String, User] {\r\n\r\n  val passwordService = MyPasswordService\r\n\r\n  def register(email: String, name:String, password: String) : User = {\r\n    val encryptedPassword = passwordService.encryptPassword(password)\r\n    val user = User(email, name, encryptedPassword)\r\n    create(user)\r\n  }\r\n\r\ndef create(user: User): User = {\r\n    DB.withConnection {\r\n      implicit connection =>\r\n        SQL(\r\n          \"\"\"\r\n          insert into user values (\r\n            {email}, {name}, {password}\r\n          )\r\n          \"\"\"\r\n        ).on(\r\n          'email -> user.email,\r\n          'name -> user.name,\r\n          'password -> user.password.underlying\r\n        ).executeUpdate()\r\n\r\n        user\r\n    }\r\n  }\r\n  \r\n    \r\n  \r\n  \r\n    \r\n      Code for the Signup Controller:",
      "",
      "val signupForm = Form(\r\n    mapping(\r\n      \"email\" -> email,\r\n      \"fullName\" -> text,\r\n      \"password\" -> weakPassword\r\n    )(SignupData.apply)(_ => None)\r\n  )\r\n\r\n  case class SignupData(email: String, fullName: String, password: String)\r\n  \r\n    \r\n  \r\n  \r\n    \r\n      Code for the HTML template where the user is redirected after successful login--notice that the name, which is not sanitized, is reflected back as raw HTML:\r\n    \r\n  \r\n  @()(implicit ctx: MyContext[_])\r\n\r\n@base.layout() {\r\n  <div class=\"container\">\r\n    <div class=\"row\">\r\n      <div class=\"span12\">\r\n        <div class=\"well\" style=\"height: 600px\">\r\n          <h1 style=\"text-align: center\">Main Page</h1>\r\n\r\n          <p style=\"font-size: 20px; text-align: center; margin-top: 15px\">\r\n            @ctx.me match {\r\n              case None => {\r\n                You are anonymous.\r\n              }\r\n              case Some(user) => {\r\n                You are currently logged in as @Html(user.name).\r\n              }\r\n            }\r\n          </p>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n}",
      "",
      "",
      "The following code shows how a user registers for an account, Again, post-registration, when the user logs in, the registered name is reflected back on the screen. But this time the play framework automatically performs HTML encoding of all the entries in the HTML template. This protects the application from XSS. Additionally, there should be regex validation on the Name parameter to make sure that the user is not able to enter malicious names into the application.",
      "Regex validation for Name:",
      "val pid = SignupForm.empid\r\nval name = SignupForm.productname\r\nval emp = Emp.findEmp(pid, name)\r\nval whitelistPattern = \"(\\\\w|\\\\d)+\".r\r\nval issafe =whitelistPattern.pattern.matcher(name).matches\r\nif (issafe){\r\n...... //Code for Action\r\n}else{\r\n...... //Code for Exception\r\n}",
      "",
      "Code for HTML template:",
      "@()(implicit ctx: MyContext[_])\r\n\r\n@base.layout() {\r\n  <div class=\"container\">\r\n    <div class=\"row\">\r\n      <div class=\"span12\">\r\n        <div class=\"well\" style=\"height: 600px\">\r\n          <h1 style=\"text-align: center\">Main Page</h1>\r\n\r\n          <p style=\"font-size: 20px; text-align: center; margin-top: 15px\">\r\n            @ctx.me match {\r\n              case None => {\r\n                You are anonymous.\r\n              }\r\n              case Some(user) => {\r\n                You are currently logged in as @user.name.\r\n              }\r\n            }\r\n          </p>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n}",
      ""
    ],
    "ol": [
      "Validating length: Validate an input's length by checking a string's length or the number of bits in a numeric value. Checking the length can help prevent buffer overflows as well as integer overflows in numeric values. A simple way to validate the numeric value for forms is through the use of minLength(length: Int) and maxLength(length: Int) from the play.api.data.validationconstraints object of Play Framework:object SignUp extends Controller {\r\n  \r\n  /**\r\n   * Sign Up Form definition.\r\n   */\r\n  val signupForm: Form[User] = Form(\r\n    \r\n    // Define a mapping that will handle User values\r\n    mapping(\r\n      \"firstname\" -> text(maxLength = 20),\r\n      \"lastname\" -> text(maxLength = 20),\r\n      \"username\" -> text(minLength = 4),\r\n      \"password\" -> text(minLength = 6),   \r\n      // Create a tuple mapping for the password/confirm\r\n      \"password\" -> tuple(\r\n        \"main\" -> text(minLength = 6),\r\n        \"confirm\" -> text\r\n      ),\r\n\r\n    )\r\n  )\r\n  }Also, you can validate any numeric value through the use of BigInt/BigDecimal as follows: def productcheck = Action { implicit request =>\r\n    prodForm.bindFromRequest.fold(\r\n      errors => BadRequest(views.html.index(errors, \"There is some error\")),\r\n      prodForm => {\r\n\r\n        val proname = prodForm.pname\r\n        val prodprice = prodForm.price\r\n        if(prodprice.compare(BigInt(0)) > -1\r\n          && prodprice.compare(BigInt(Integer.MAX_VALUE)) \r\n        {\r\n          println(\"true\")\r\n          ............ //code for true\r\n        }\r\n        else\r\n        {\r\n          println(\"false\")\r\n          ............ // code for exception\r\n        }\r\n    \r\n      \r\n      Validating type: Validating the input's data type is important when your application expects a specific non-string parameter. Difference in data type can trigger unhandled exceptions that would throw your application into an unknown state. The following is an example for validating in forms:object ContactForm extends Controller {\r\n  \r\n  /**\r\n   * Contact Form definition.\r\n  */\r\n  val appointmentMapping = tuple(\r\n  \"location\" -> text,\r\n  \"start\" -> tuple(\r\n    \"date\" -> date,\r\n    \"time\" -> text),\r\n  \"attendees\" -> list(mapping(\r\n    \"name\" -> text,\r\n    \"email\" -> email)\r\n)}\r\n\r\n    \r\n      \r\n      Validating contents: Use whitelist and blacklist techniques to validate the input's contents. Choose the technique based on the constraints that are imposed on the input: If the input follows a tight structure and format, you can use whitelisting alone to weed out malicious input. If there are unknowns about the input, you'll need a combination of black and white listing. In general, use blacklisting as a backup to whitelisting, through a spiral-out approach: Use whitelisting for the initial validation. If whitelisting cannot validate the input, then fall back to blacklisting. If blacklisting cannot validate, then discard the input. The following is an example of implementing this technique using forms:object ValidateProduct extends Controller {\r\n\r\n  val productForm = Form(mapping(\r\n    \"ean\" -> longNumber.verifying(\"This product already exists!\", Product.findByEan(_).isEmpty),\r\n    \"name\" -> nonEmptyText,\r\n    \"description\" -> text,\r\n    \"pieces\" -> number,\r\n    \"active\" -> boolean)(Product.apply)(Product.unapply).verifying(\r\n      \"Product can not be active if the description is empty\", product =>\r\n        !product.active || product.description.nonEmpty))\r\n}Using regular expressions, the fix would be as below:val pid = ProductForm.productid\r\nval pname = ProductForm.productname\r\nval products = Product.findProduct(pid, pname)\r\nval whitelistPattern = \"(\\\\w|\\\\d)+\".r\r\nval issafe =whitelistPattern.pattern.matcher(pname).matchesif (issafe){...... //Code for Action}else{...... //Code for Exception}Examples of useful regular expressions:UseRegular ExpressionScala StringValid E-Mail Address^\\w+(\\.|_|-){0,1}\\w+@(\\w+\\.)*\\w{3,1024}\\.([a-zA-Z]{2}\\.){0,1}[a-zA-Z]{2,4}$^\\\\w+(\\\\.|_|-){0,1}\\\\w+@(\\\\w+\\\\.)*\\\\w{3,}\\\\.([a-zA-Z]{2}\\\\.){0,1}[a-zA-Z]{2,4}$Alpha-numeric free text(\\w|\\d|\\s|;|\\?|!|,|\\.|-|:)+(\\\\w|\\\\d|\\\\s|;|\\\\?|!|,|\\\\.|-|:)+Word characters\\w+\\\\w+Numbers\\d+\\\\d+"
    ],
    "li": [
      "Validating length: Validate an input's length by checking a string's length or the number of bits in a numeric value. Checking the length can help prevent buffer overflows as well as integer overflows in numeric values. A simple way to validate the numeric value for forms is through the use of minLength(length: Int) and maxLength(length: Int) from the play.api.data.validationconstraints object of Play Framework:object SignUp extends Controller {\r\n  \r\n  /**\r\n   * Sign Up Form definition.\r\n   */\r\n  val signupForm: Form[User] = Form(\r\n    \r\n    // Define a mapping that will handle User values\r\n    mapping(\r\n      \"firstname\" -> text(maxLength = 20),\r\n      \"lastname\" -> text(maxLength = 20),\r\n      \"username\" -> text(minLength = 4),\r\n      \"password\" -> text(minLength = 6),   \r\n      // Create a tuple mapping for the password/confirm\r\n      \"password\" -> tuple(\r\n        \"main\" -> text(minLength = 6),\r\n        \"confirm\" -> text\r\n      ),\r\n\r\n    )\r\n  )\r\n  }Also, you can validate any numeric value through the use of BigInt/BigDecimal as follows: def productcheck = Action { implicit request =>\r\n    prodForm.bindFromRequest.fold(\r\n      errors => BadRequest(views.html.index(errors, \"There is some error\")),\r\n      prodForm => {\r\n\r\n        val proname = prodForm.pname\r\n        val prodprice = prodForm.price\r\n        if(prodprice.compare(BigInt(0)) > -1\r\n          && prodprice.compare(BigInt(Integer.MAX_VALUE)) \r\n        {\r\n          println(\"true\")\r\n          ............ //code for true\r\n        }\r\n        else\r\n        {\r\n          println(\"false\")\r\n          ............ // code for exception\r\n        }",
      "Validating type: Validating the input's data type is important when your application expects a specific non-string parameter. Difference in data type can trigger unhandled exceptions that would throw your application into an unknown state. The following is an example for validating in forms:object ContactForm extends Controller {\r\n  \r\n  /**\r\n   * Contact Form definition.\r\n  */\r\n  val appointmentMapping = tuple(\r\n  \"location\" -> text,\r\n  \"start\" -> tuple(\r\n    \"date\" -> date,\r\n    \"time\" -> text),\r\n  \"attendees\" -> list(mapping(\r\n    \"name\" -> text,\r\n    \"email\" -> email)\r\n)}",
      "Validating contents: Use whitelist and blacklist techniques to validate the input's contents. Choose the technique based on the constraints that are imposed on the input: If the input follows a tight structure and format, you can use whitelisting alone to weed out malicious input. If there are unknowns about the input, you'll need a combination of black and white listing. In general, use blacklisting as a backup to whitelisting, through a spiral-out approach: Use whitelisting for the initial validation. If whitelisting cannot validate the input, then fall back to blacklisting. If blacklisting cannot validate, then discard the input. The following is an example of implementing this technique using forms:object ValidateProduct extends Controller {\r\n\r\n  val productForm = Form(mapping(\r\n    \"ean\" -> longNumber.verifying(\"This product already exists!\", Product.findByEan(_).isEmpty),\r\n    \"name\" -> nonEmptyText,\r\n    \"description\" -> text,\r\n    \"pieces\" -> number,\r\n    \"active\" -> boolean)(Product.apply)(Product.unapply).verifying(\r\n      \"Product can not be active if the description is empty\", product =>\r\n        !product.active || product.description.nonEmpty))\r\n}Using regular expressions, the fix would be as below:val pid = ProductForm.productid\r\nval pname = ProductForm.productname\r\nval products = Product.findProduct(pid, pname)\r\nval whitelistPattern = \"(\\\\w|\\\\d)+\".r\r\nval issafe =whitelistPattern.pattern.matcher(pname).matchesif (issafe){...... //Code for Action}else{...... //Code for Exception}Examples of useful regular expressions:UseRegular ExpressionScala StringValid E-Mail Address^\\w+(\\.|_|-){0,1}\\w+@(\\w+\\.)*\\w{3,1024}\\.([a-zA-Z]{2}\\.){0,1}[a-zA-Z]{2,4}$^\\\\w+(\\\\.|_|-){0,1}\\\\w+@(\\\\w+\\\\.)*\\\\w{3,}\\\\.([a-zA-Z]{2}\\\\.){0,1}[a-zA-Z]{2,4}$Alpha-numeric free text(\\w|\\d|\\s|;|\\?|!|,|\\.|-|:)+(\\\\w|\\\\d|\\\\s|;|\\\\?|!|,|\\\\.|-|:)+Word characters\\w+\\\\w+Numbers\\d+\\\\d+",
      "A tutorial on regular expressions is available at Regular-Expressions.info.",
      "For more information on using regular expression in Scala, see: Documentation for Regex Pattern in Scala documentation."
    ],
    "strong": [
      "Validating length",
      "Validating type",
      "Validating contents"
    ],
    "i": [
      "minLength(length: Int)",
      "maxLength(length: Int)",
      "play.api.data.validation"
    ],
    "pre": [
      "object SignUp extends Controller {\r\n  \r\n  /**\r\n   * Sign Up Form definition.\r\n   */\r\n  val signupForm: Form[User] = Form(\r\n    \r\n    // Define a mapping that will handle User values\r\n    mapping(\r\n      \"firstname\" -> text(maxLength = 20),\r\n      \"lastname\" -> text(maxLength = 20),\r\n      \"username\" -> text(minLength = 4),\r\n      \"password\" -> text(minLength = 6),   \r\n      // Create a tuple mapping for the password/confirm\r\n      \"password\" -> tuple(\r\n        \"main\" -> text(minLength = 6),\r\n        \"confirm\" -> text\r\n      ),\r\n\r\n    )\r\n  )\r\n  }",
      "def productcheck = Action { implicit request =>\r\n    prodForm.bindFromRequest.fold(\r\n      errors => BadRequest(views.html.index(errors, \"There is some error\")),\r\n      prodForm => {\r\n\r\n        val proname = prodForm.pname\r\n        val prodprice = prodForm.price\r\n        if(prodprice.compare(BigInt(0)) > -1\r\n          && prodprice.compare(BigInt(Integer.MAX_VALUE)) \r\n        {\r\n          println(\"true\")\r\n          ............ //code for true\r\n        }\r\n        else\r\n        {\r\n          println(\"false\")\r\n          ............ // code for exception\r\n        }",
      "object ContactForm extends Controller {\r\n  \r\n  /**\r\n   * Contact Form definition.\r\n  */\r\n  val appointmentMapping = tuple(\r\n  \"location\" -> text,\r\n  \"start\" -> tuple(\r\n    \"date\" -> date,\r\n    \"time\" -> text),\r\n  \"attendees\" -> list(mapping(\r\n    \"name\" -> text,\r\n    \"email\" -> email)\r\n)}",
      "object ValidateProduct extends Controller {\r\n\r\n  val productForm = Form(mapping(\r\n    \"ean\" -> longNumber.verifying(\"This product already exists!\", Product.findByEan(_).isEmpty),\r\n    \"name\" -> nonEmptyText,\r\n    \"description\" -> text,\r\n    \"pieces\" -> number,\r\n    \"active\" -> boolean)(Product.apply)(Product.unapply).verifying(\r\n      \"Product can not be active if the description is empty\", product =>\r\n        !product.active || product.description.nonEmpty))\r\n}",
      "val pid = ProductForm.productid\r\nval pname = ProductForm.productname\r\nval products = Product.findProduct(pid, pname)\r\nval whitelistPattern = \"(\\\\w|\\\\d)+\".r\r\nval issafe =whitelistPattern.pattern.matcher(pname).matches",
      "if (issafe){",
      "...... //Code for Action",
      "}else{",
      "...... //Code for Exception",
      "}",
      "",
      "object User extends UserInfoService[String, User] {\r\n\r\n  val passwordService = MyPasswordService\r\n\r\n  def register(email: String, name:String, password: String) : User = {\r\n    val encryptedPassword = passwordService.encryptPassword(password)\r\n    val user = User(email, name, encryptedPassword)\r\n    create(user)\r\n  }\r\n\r\ndef create(user: User): User = {\r\n    DB.withConnection {\r\n      implicit connection =>\r\n        SQL(\r\n          \"\"\"\r\n          insert into user values (\r\n            {email}, {name}, {password}\r\n          )\r\n          \"\"\"\r\n        ).on(\r\n          'email -> user.email,\r\n          'name -> user.name,\r\n          'password -> user.password.underlying\r\n        ).executeUpdate()\r\n\r\n        user\r\n    }\r\n  }",
      "",
      "Code for the Signup Controller:",
      "val signupForm = Form(\r\n    mapping(\r\n      \"email\" -> email,\r\n      \"fullName\" -> text,\r\n      \"password\" -> weakPassword\r\n    )(SignupData.apply)(_ => None)\r\n  )\r\n\r\n  case class SignupData(email: String, fullName: String, password: String)",
      "",
      "Code for the HTML template where the user is redirected after successful login--notice that the name, which is not sanitized, is reflected back as raw HTML:",
      "@()(implicit ctx: MyContext[_])\r\n\r\n@base.layout() {\r\n  <div class=\"container\">\r\n    <div class=\"row\">\r\n      <div class=\"span12\">\r\n        <div class=\"well\" style=\"height: 600px\">\r\n          <h1 style=\"text-align: center\">Main Page</h1>\r\n\r\n          <p style=\"font-size: 20px; text-align: center; margin-top: 15px\">\r\n            @ctx.me match {\r\n              case None => {\r\n                You are anonymous.\r\n              }\r\n              case Some(user) => {\r\n                You are currently logged in as @Html(user.name).\r\n              }\r\n            }\r\n          </p>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n}",
      "val pid = SignupForm.empid\r\nval name = SignupForm.productname\r\nval emp = Emp.findEmp(pid, name)\r\nval whitelistPattern = \"(\\\\w|\\\\d)+\".r\r\nval issafe =whitelistPattern.pattern.matcher(name).matches\r\nif (issafe){\r\n...... //Code for Action\r\n}else{\r\n...... //Code for Exception\r\n}",
      "@()(implicit ctx: MyContext[_])\r\n\r\n@base.layout() {\r\n  <div class=\"container\">\r\n    <div class=\"row\">\r\n      <div class=\"span12\">\r\n        <div class=\"well\" style=\"height: 600px\">\r\n          <h1 style=\"text-align: center\">Main Page</h1>\r\n\r\n          <p style=\"font-size: 20px; text-align: center; margin-top: 15px\">\r\n            @ctx.me match {\r\n              case None => {\r\n                You are anonymous.\r\n              }\r\n              case Some(user) => {\r\n                You are currently logged in as @user.name.\r\n              }\r\n            }\r\n          </p>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n}",
      ""
    ],
    "div": [
      "",
      "",
      ""
    ],
    "br": [
      "",
      "",
      "",
      "",
      "",
      "",
      ""
    ],
    "table": [
      "UseRegular ExpressionScala StringValid E-Mail Address^\\w+(\\.|_|-){0,1}\\w+@(\\w+\\.)*\\w{3,1024}\\.([a-zA-Z]{2}\\.){0,1}[a-zA-Z]{2,4}$^\\\\w+(\\\\.|_|-){0,1}\\\\w+@(\\\\w+\\\\.)*\\\\w{3,}\\\\.([a-zA-Z]{2}\\\\.){0,1}[a-zA-Z]{2,4}$Alpha-numeric free text(\\w|\\d|\\s|;|\\?|!|,|\\.|-|:)+(\\\\w|\\\\d|\\\\s|;|\\\\?|!|,|\\\\.|-|:)+Word characters\\w+\\\\w+Numbers\\d+\\\\d+"
    ],
    "tbody": [
      "UseRegular ExpressionScala StringValid E-Mail Address^\\w+(\\.|_|-){0,1}\\w+@(\\w+\\.)*\\w{3,1024}\\.([a-zA-Z]{2}\\.){0,1}[a-zA-Z]{2,4}$^\\\\w+(\\\\.|_|-){0,1}\\\\w+@(\\\\w+\\\\.)*\\\\w{3,}\\\\.([a-zA-Z]{2}\\\\.){0,1}[a-zA-Z]{2,4}$Alpha-numeric free text(\\w|\\d|\\s|;|\\?|!|,|\\.|-|:)+(\\\\w|\\\\d|\\\\s|;|\\\\?|!|,|\\\\.|-|:)+Word characters\\w+\\\\w+Numbers\\d+\\\\d+"
    ],
    "tr": [
      "UseRegular ExpressionScala String",
      "Valid E-Mail Address^\\w+(\\.|_|-){0,1}\\w+@(\\w+\\.)*\\w{3,1024}\\.([a-zA-Z]{2}\\.){0,1}[a-zA-Z]{2,4}$^\\\\w+(\\\\.|_|-){0,1}\\\\w+@(\\\\w+\\\\.)*\\\\w{3,}\\\\.([a-zA-Z]{2}\\\\.){0,1}[a-zA-Z]{2,4}$",
      "Alpha-numeric free text(\\w|\\d|\\s|;|\\?|!|,|\\.|-|:)+(\\\\w|\\\\d|\\\\s|;|\\\\?|!|,|\\\\.|-|:)+",
      "Word characters\\w+\\\\w+",
      "Numbers\\d+\\\\d+"
    ],
    "td": [
      "Use",
      "Regular Expression",
      "Scala String",
      "Valid E-Mail Address",
      "^\\w+(\\.|_|-){0,1}\\w+@(\\w+\\.)*\\w{3,1024}\\.([a-zA-Z]{2}\\.){0,1}[a-zA-Z]{2,4}$",
      "^\\\\w+(\\\\.|_|-){0,1}\\\\w+@(\\\\w+\\\\.)*\\\\w{3,}\\\\.([a-zA-Z]{2}\\\\.){0,1}[a-zA-Z]{2,4}$",
      "Alpha-numeric free text",
      "(\\w|\\d|\\s|;|\\?|!|,|\\.|-|:)+",
      "(\\\\w|\\\\d|\\\\s|;|\\\\?|!|,|\\\\.|-|:)+",
      "Word characters",
      "\\w+",
      "\\\\w+",
      "Numbers",
      "\\d+",
      "\\\\d+"
    ],
    "ul": [
      "",
      "A tutorial on regular expressions is available at Regular-Expressions.info.\r\n    For more information on using regular expression in Scala, see: Documentation for Regex Pattern in Scala documentation."
    ],
    "font": [
      "The following code shows how a user registers for an account. Post-registration, when the user logs in, the registered name is reflected back on the screen. Because it does not HTML encode the echoed input, the application is vulnerable to persistent cross-site scripting.",
      "",
      "Code for the User creation model -- notice that the name is a String object with no validations and allows special characters:",
      "Code for the Signup Controller:",
      "Code for the HTML template where the user is redirected after successful login--notice that the name, which is not sanitized, is reflected back as raw HTML:",
      "",
      "The following code shows how a user registers for an account, Again, post-registration, when the user logs in, the registered name is reflected back on the screen. But this time the play framework automatically performs HTML encoding of all the entries in the HTML template. This protects the application from XSS. Additionally, there should be regex validation on the Name parameter to make sure that the user is not able to enter malicious names into the application.",
      "",
      "",
      "Regex validation for Name:",
      "Code for HTML template:"
    ],
    "span": [
      "Code for the Signup Controller",
      "Code for the HTML template where the user is redirected after successful login--notice that the name, which is not sanitized, is reflected back as raw HTML:"
    ],
    "a": [
      "Regular-Expressions.info",
      "Regex Pattern"
    ]
  },
  "links": [
    {
      "href": "http://www.regular-expressions.info/",
      "text": "Regular-Expressions.info"
    },
    {
      "href": "http://www.scala-lang.org/api/current/index.html#scala.util.matching.Regex",
      "text": "Regex Pattern"
    }
  ],
  "html": "<h1>Applies to</h1>\r\n  <p>Applications written using Scala and Play Framework 2.1.0+</p>\r\n  <h1>What to Do</h1>\r\n  <p>Treat all input as untrusted data. Validate untrusted data using whitelist techniques to check against known good input.</p>\r\n  <h1>Why</h1>\r\n  <p>Unchecked malicious input may lead to integer overflows, injection based attacks, denial of service or information disclosure.</p>\r\n  <h1>When</h1>\r\n  <p>Always validate input. Do not assume that input is good based on origin.</p>\r\n  <h1>How</h1>\r\n  <p>Input can vary in length, data type, and contents. Verify that all input meets your application's expectations.</p>\r\n  <ol>\r\n    <li>\r\n      <p />\r\n      <strong>Validating length</strong>: Validate an input's length by checking a string's length or the number of bits in a numeric value. Checking the length can help prevent buffer overflows as well as integer overflows in numeric values. A simple way to validate the numeric value for forms is through the use of&nbsp;<i>minLength(length: Int)</i>&nbsp;and<i>&nbsp;maxLength(length: Int)</i>&nbsp;from the&nbsp;<i>play.api.data.validation</i>constraints object of Play Framework:<pre>object SignUp extends Controller {\r\n  \r\n  /**\r\n   * Sign Up Form definition.\r\n   */\r\n  val signupForm: Form[User] = Form(\r\n    \r\n    // Define a mapping that will handle User values\r\n    mapping(\r\n      \"firstname\" -&gt; text(maxLength = 20),\r\n      \"lastname\" -&gt; text(maxLength = 20),\r\n      \"username\" -&gt; text(minLength = 4),\r\n      \"password\" -&gt; text(minLength = 6),   \r\n      // Create a tuple mapping for the password/confirm\r\n      \"password\" -&gt; tuple(\r\n        \"main\" -&gt; text(minLength = 6),\r\n        \"confirm\" -&gt; text\r\n      ),\r\n\r\n    )\r\n  )\r\n  }</pre>Also, you can validate any numeric value through the use of BigInt/BigDecimal as follows:&nbsp;<pre>def productcheck = Action { implicit request =&gt;\r\n    prodForm.bindFromRequest.fold(\r\n      errors =&gt; BadRequest(views.html.index(errors, \"There is some error\")),\r\n      prodForm =&gt; {\r\n\r\n        val proname = prodForm.pname\r\n        val prodprice = prodForm.price\r\n        if(prodprice.compare(BigInt(0)) &gt; -1\r\n          && prodprice.compare(BigInt(Integer.MAX_VALUE)) \r\n        {\r\n          println(\"true\")\r\n          ............ //code for true\r\n        }\r\n        else\r\n        {\r\n          println(\"false\")\r\n          ............ // code for exception\r\n        }</pre></li>\r\n    <li>\r\n      <p />\r\n      <strong>Validating type</strong>: Validating the input's data type is important when your application expects a specific non-string parameter. Difference in data type can trigger unhandled exceptions that would throw your application into an unknown state. The following is an example for validating in forms:<pre>object ContactForm extends Controller {\r\n  \r\n  /**\r\n   * Contact Form definition.\r\n  */\r\n  val appointmentMapping = tuple(\r\n  \"location\" -&gt; text,\r\n  \"start\" -&gt; tuple(\r\n    \"date\" -&gt; date,\r\n    \"time\" -&gt; text),\r\n  \"attendees\" -&gt; list(mapping(\r\n    \"name\" -&gt; text,\r\n    \"email\" -&gt; email)\r\n)}\r\n</pre><div><br /></div></li>\r\n    <li>\r\n      <p />\r\n      <strong>Validating contents</strong>: Use whitelist and blacklist techniques to validate the input's contents. Choose the technique based on the constraints that are imposed on the input: If the input follows a tight structure and format, you can use whitelisting alone to weed out malicious input. If there are unknowns about the input, you'll need a combination of black and white listing. In general, use blacklisting as a backup to whitelisting, through a spiral-out approach: Use whitelisting for the initial validation. If whitelisting cannot validate the input, then fall back to blacklisting. If blacklisting cannot validate, then discard the input. The following is an example of implementing this technique using forms:<pre>object ValidateProduct extends Controller {\r\n\r\n  val productForm = Form(mapping(\r\n    \"ean\" -&gt; longNumber.verifying(\"This product already exists!\", Product.findByEan(_).isEmpty),\r\n    \"name\" -&gt; nonEmptyText,\r\n    \"description\" -&gt; text,\r\n    \"pieces\" -&gt; number,\r\n    \"active\" -&gt; boolean)(Product.apply)(Product.unapply).verifying(\r\n      \"Product can not be active if the description is empty\", product =&gt;\r\n        !product.active || product.description.nonEmpty))\r\n}</pre><p>Using regular expressions, the fix would be as below:</p><p /><pre>val pid = ProductForm.productid\r\nval pname = ProductForm.productname\r\nval products = Product.findProduct(pid, pname)\r\nval whitelistPattern = \"(\\\\w|\\\\d)+\".r\r\nval issafe =whitelistPattern.pattern.matcher(pname).matches</pre><pre>if (issafe){</pre><pre>...... //Code for Action</pre><pre>}else{</pre><pre>...... //Code for Exception</pre><pre>}</pre><pre></pre><br />Examples of useful regular expressions:<p /><p /><table><tbody><tr><td>Use</td><td>Regular Expression</td><td>Scala String</td></tr><tr><td>Valid E-Mail Address</td><td>^\\w+(\\.|_|-){0,1}\\w+@(\\w+\\.)*\\w{3,1024}\\.([a-zA-Z]{2}\\.){0,1}[a-zA-Z]{2,4}$</td><td>^\\\\w+(\\\\.|_|-){0,1}\\\\w+@(\\\\w+\\\\.)*\\\\w{3,}\\\\.([a-zA-Z]{2}\\\\.){0,1}[a-zA-Z]{2,4}$</td></tr><tr><td>Alpha-numeric free text</td><td>(\\w|\\d|\\s|;|\\?|!|,|\\.|-|:)+</td><td>(\\\\w|\\\\d|\\\\s|;|\\\\?|!|,|\\\\.|-|:)+</td></tr><tr><td>Word characters</td><td>\\w+</td><td>\\\\w+</td></tr><tr><td>Numbers</td><td>\\d+</td><td>\\\\d+</td></tr></tbody></table><p /><ul></ul></li>\r\n  </ol>\r\n  <h1>Problem Example</h1>\r\n  <p />\r\n  <p>\r\n    <font face=\"Arial\" size=\"2\">The following code shows how a user registers for an account. Post-registration, when the user logs in, the registered name is reflected back on the screen. Because it does not HTML encode the echoed input, the application is vulnerable to persistent cross-site scripting.</font>\r\n  </p>\r\n  <font face=\"Arial\" size=\"2\">\r\n  </font>\r\n  <p>\r\n    <font face=\"Arial\" size=\"2\">Code for the User creation model -- notice that the name is a String object with no validations and allows special characters:</font>\r\n  </p>\r\n  <p style=\"font-size: 10pt;\" />\r\n  <pre>object User extends UserInfoService[String, User] {\r\n\r\n  val passwordService = MyPasswordService\r\n\r\n  def register(email: String, name:String, password: String) : User = {\r\n    val encryptedPassword = passwordService.encryptPassword(password)\r\n    val user = User(email, name, encryptedPassword)\r\n    create(user)\r\n  }\r\n\r\ndef create(user: User): User = {\r\n    DB.withConnection {\r\n      implicit connection =&gt;\r\n        SQL(\r\n          \"\"\"\r\n          insert into user values (\r\n            {email}, {name}, {password}\r\n          )\r\n          \"\"\"\r\n        ).on(\r\n          'email -&gt; user.email,\r\n          'name -&gt; user.name,\r\n          'password -&gt; user.password.underlying\r\n        ).executeUpdate()\r\n\r\n        user\r\n    }\r\n  }</pre>\r\n  <pre>\r\n    <br />\r\n  </pre>\r\n  <pre>\r\n    <font face=\"Arial\">\r\n      <span style=\"white-space: normal;\">Code for the Signup Controller</span>:</font>\r\n  </pre>\r\n  <p />\r\n  <p />\r\n  <pre>  val signupForm = Form(\r\n    mapping(\r\n      \"email\" -&gt; email,\r\n      \"fullName\" -&gt; text,\r\n      \"password\" -&gt; weakPassword\r\n    )(SignupData.apply)(_ =&gt; None)\r\n  )\r\n\r\n  case class SignupData(email: String, fullName: String, password: String)</pre>\r\n  <pre>\r\n    <br />\r\n  </pre>\r\n  <pre>\r\n    <font face=\"Arial\">\r\n      <span style=\"white-space: normal;\">Code for the HTML template where the user is redirected after successful login--notice that the name, which is not sanitized, is reflected back as raw HTML:</span>\r\n    </font>\r\n  </pre>\r\n  <pre>@()(implicit ctx: MyContext[_])\r\n\r\n@base.layout() {\r\n  &lt;div class=\"container\"&gt;\r\n    &lt;div class=\"row\"&gt;\r\n      &lt;div class=\"span12\"&gt;\r\n        &lt;div class=\"well\" style=\"height: 600px\"&gt;\r\n          &lt;h1 style=\"text-align: center\"&gt;Main Page&lt;/h1&gt;\r\n\r\n          &lt;p style=\"font-size: 20px; text-align: center; margin-top: 15px\"&gt;\r\n            @ctx.me match {\r\n              case None =&gt; {\r\n                You are anonymous.\r\n              }\r\n              case Some(user) =&gt; {\r\n                You are currently logged in as @Html(user.name).\r\n              }\r\n            }\r\n          &lt;/p&gt;\r\n        &lt;/div&gt;\r\n      &lt;/div&gt;\r\n    &lt;/div&gt;\r\n  &lt;/div&gt;\r\n}<font face=\"Arial, Verdana\" size=\"3\"></font></pre>\r\n  <div>\r\n    <br />\r\n  </div>\r\n  <p />\r\n  <h1>Solution Example</h1>\r\n  <p />\r\n  <p>\r\n    <font face=\"Arial\" size=\"2\">The following code shows how a user registers for an account, Again, post-registration, when the user logs in, the registered name is reflected back on the screen. But this time the play framework automatically performs HTML encoding of all the entries in the HTML template. This protects the application from XSS. Additionally, there should be regex validation on the Name<font face=\"Courier New\"></font>&nbsp;parameter to make sure that the user is not able to enter malicious names into the application.</font>\r\n  </p>\r\n  <font face=\"Arial\" size=\"2\">\r\n  </font>\r\n  <p>\r\n    <font face=\"Arial\" size=\"2\">Regex validation for Name:</font>\r\n  </p>\r\n  <p />\r\n  <pre>val pid = SignupForm.empid\r\nval name = SignupForm.productname\r\nval emp = Emp.findEmp(pid, name)\r\nval whitelistPattern = \"(\\\\w|\\\\d)+\".r\r\nval issafe =whitelistPattern.pattern.matcher(name).matches\r\nif (issafe){\r\n...... //Code for Action\r\n}else{\r\n...... //Code for Exception\r\n}</pre>\r\n  <p />\r\n  <p>\r\n    <font face=\"Arial\" size=\"2\">Code for HTML template:</font>\r\n  </p>\r\n  <p />\r\n  <pre>@()(implicit ctx: MyContext[_])\r\n\r\n@base.layout() {\r\n  &lt;div class=\"container\"&gt;\r\n    &lt;div class=\"row\"&gt;\r\n      &lt;div class=\"span12\"&gt;\r\n        &lt;div class=\"well\" style=\"height: 600px\"&gt;\r\n          &lt;h1 style=\"text-align: center\"&gt;Main Page&lt;/h1&gt;\r\n\r\n          &lt;p style=\"font-size: 20px; text-align: center; margin-top: 15px\"&gt;\r\n            @ctx.me match {\r\n              case None =&gt; {\r\n                You are anonymous.\r\n              }\r\n              case Some(user) =&gt; {\r\n                You are currently logged in as @user.name.\r\n              }\r\n            }\r\n          &lt;/p&gt;\r\n        &lt;/div&gt;\r\n      &lt;/div&gt;\r\n    &lt;/div&gt;\r\n  &lt;/div&gt;\r\n}</pre>\r\n  <p />\r\n  <pre>\r\n    <br />\r\n  </pre>\r\n  <h1>Additional Resources</h1>\r\n  <ul>\r\n    <li>A tutorial on regular expressions is available at&nbsp;<a href=\"http://www.regular-expressions.info/\">Regular-Expressions.info</a>.</li>\r\n    <li>For more information on using regular expression in Scala, see: Documentation for&nbsp;<a href=\"http://www.scala-lang.org/api/current/index.html#scala.util.matching.Regex\">Regex Pattern</a>&nbsp;in Scala documentation.</li>\r\n  </ul>\r\n  <div>\r\n    <br />\r\n  </div>"
}