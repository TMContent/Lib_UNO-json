{
  "id": "a90e66f1-18e6-48e0-a456-59c2cf227a63",
  "checksum": "153f0f7d536c6ba3c17bf7e90a8fc3eb143b0c3f",
  "words": {
    "1": [
      "ul",
      "li",
      "h1",
      "ol",
      "li"
    ],
    "2": [
      "ul",
      "li",
      "h1"
    ],
    "3": [
      "ul",
      "li",
      "ol",
      "li",
      "h1"
    ],
    "4": [
      "ul",
      "li",
      "h1"
    ],
    "8": [
      "ol",
      "li"
    ],
    "2007": [
      "p"
    ],
    "summary": [
      "h1"
    ],
    "a": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "double": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "strong",
      "p",
      "strong",
      "title"
    ],
    "free": [
      "p",
      "p",
      "p",
      "p",
      "i",
      "i",
      "i",
      "p",
      "p",
      "p",
      "i",
      "p",
      "p",
      "p",
      "i",
      "i",
      "p",
      "p",
      "p",
      "i",
      "ol",
      "li",
      "i",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "i",
      "p",
      "p",
      "p",
      "i",
      "i",
      "p",
      "p",
      "strong",
      "p",
      "strong",
      "title"
    ],
    "bug": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "is": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "coding": [
      "p"
    ],
    "error": [
      "p"
    ],
    "where": [
      "p"
    ],
    "an": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p"
    ],
    "application": [
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "uses": [
      "p",
      "p"
    ],
    "malloc": [
      "p",
      "p",
      "i",
      "i",
      "p",
      "i",
      "p",
      "i",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "i",
      "i",
      "li",
      "i",
      "li",
      "i",
      "li",
      "i",
      "p",
      "i"
    ],
    "to": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "title"
    ],
    "allocate": [
      "p",
      "p"
    ],
    "memory": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "strong"
    ],
    "block": [
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "li",
      "li",
      "p"
    ],
    "and": [
      "p",
      "p",
      "ul",
      "ul",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "h1",
      "p",
      "h1",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "then": [
      "p"
    ],
    "release": [
      "p",
      "p"
    ],
    "the": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "twice": [
      "p",
      "p",
      "p"
    ],
    "without": [
      "p"
    ],
    "reinitializing": [
      "p"
    ],
    "pointer": [
      "p",
      "p"
    ],
    "or": [
      "p",
      "p",
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p"
    ],
    "setting": [
      "p"
    ],
    "it": [
      "p",
      "p",
      "p",
      "p",
      "ol",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "null": [
      "p",
      "pre",
      "pre"
    ],
    "between": [
      "p",
      "p"
    ],
    "two": [
      "p",
      "p",
      "p"
    ],
    "calls": [
      "p",
      "p",
      "ol",
      "li",
      "p",
      "p"
    ],
    "freeas": [
      "p"
    ],
    "result": [
      "p"
    ],
    "of": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "executing": [
      "p",
      "ol",
      "li"
    ],
    "second": [
      "p",
      "p",
      "p"
    ],
    "internal": [
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "li",
      "li"
    ],
    "heap": [
      "p",
      "p",
      "p",
      "p",
      "ol",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "structures": [
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "li",
      "li"
    ],
    "used": [
      "p",
      "p"
    ],
    "by": [
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "li",
      "li",
      "p"
    ],
    "heapalloc": [
      "p",
      "i",
      "p",
      "i"
    ],
    "in": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "windows": [
      "p",
      "ol",
      "li",
      "p",
      "p",
      "p",
      "strong"
    ],
    "become": [
      "p"
    ],
    "corruptedan": [
      "p"
    ],
    "attacker": [
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "p"
    ],
    "takes": [
      "p"
    ],
    "advantage": [
      "p",
      "p"
    ],
    "order": [
      "p",
      "p"
    ],
    "overwrite": [
      "p",
      "p",
      "p"
    ],
    "application’s": [
      "p"
    ],
    "get": [
      "p"
    ],
    "execution": [
      "p"
    ],
    "control": [
      "p",
      "ol",
      "li"
    ],
    "recommended": [
      "p",
      "p",
      "p",
      "p"
    ],
    "follow": [
      "p"
    ],
    "these": [
      "p",
      "p",
      "p"
    ],
    "steps": [
      "p",
      "p"
    ],
    "test": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "title"
    ],
    "for": [
      "p",
      "p",
      "ol",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "title"
    ],
    "bugs": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "title"
    ],
    "step": [
      "ul",
      "ul",
      "ul",
      "ul",
      "li",
      "li",
      "li",
      "li",
      "h1",
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "h1",
      "p",
      "h1",
      "h1"
    ],
    "understand": [
      "ul",
      "li",
      "h1",
      "p",
      "p",
      "p",
      "p"
    ],
    "attack": [
      "ul",
      "li",
      "h1",
      "p",
      "p",
      "p",
      "ol",
      "li",
      "p",
      "p",
      "p"
    ],
    "scenarios": [
      "ul",
      "li",
      "h1",
      "p",
      "p",
      "p",
      "p"
    ],
    "analyze": [
      "ul",
      "li",
      "h1"
    ],
    "causes": [
      "ul",
      "li",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "h1",
      "p",
      "p",
      "p",
      "p"
    ],
    "countermeasures": [
      "ul",
      "li",
      "h1",
      "p"
    ],
    "start": [
      "ul",
      "li",
      "ol",
      "li",
      "h1"
    ],
    "testing": [
      "ul",
      "ul",
      "li",
      "li",
      "p",
      "p",
      "h1",
      "h1",
      "p"
    ],
    "exploring": [
      "ul",
      "li",
      "h1"
    ],
    "execute": [
      "ul",
      "li",
      "p",
      "ol",
      "li",
      "p",
      "p",
      "h1",
      "p"
    ],
    "additional": [
      "ul",
      "li",
      "h1"
    ],
    "first": [
      "p",
      "ol",
      "li"
    ],
    "their": [
      "p",
      "p"
    ],
    "c/c++": [
      "p"
    ],
    "applications": [
      "p"
    ],
    "use": [
      "p",
      "p",
      "p"
    ],
    "malloc)": [
      "p",
      "i"
    ],
    "free)": [
      "p",
      "i"
    ],
    "family": [
      "p"
    ],
    "functions": [
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "deallocate": [
      "p"
    ],
    "respectivelythese": [
      "p"
    ],
    "chunks": [
      "p",
      "p"
    ],
    "which": [
      "p",
      "ol",
      "ol",
      "li",
      "li"
    ],
    "are": [
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "stored": [
      "p"
    ],
    "as": [
      "p",
      "p",
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "form": [
      "p"
    ],
    "doubly": [
      "p"
    ],
    "linked": [
      "p",
      "p"
    ],
    "listwhen": [
      "p"
    ],
    "called": [
      "p",
      "p"
    ],
    "routines": [
      "p"
    ],
    "that": [
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "maintain": [
      "p"
    ],
    "link": [
      "p"
    ],
    "list": [
      "p"
    ],
    "splitting": [
      "p"
    ],
    "coalescing": [
      "p"
    ],
    "rearrangingchunks": [
      "p"
    ],
    "during": [
      "p",
      "ol",
      "li"
    ],
    "exploits": [
      "p"
    ],
    "fact": [
      "p"
    ],
    "releasing": [
      "p"
    ],
    "function": [
      "p",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "p"
    ],
    "on": [
      "p",
      "p",
      "p",
      "p",
      "strong"
    ],
    "chunkifthe": [
      "p"
    ],
    "vulnerable": [
      "p",
      "p"
    ],
    "may": [
      "p",
      "p"
    ],
    "crash": [
      "p"
    ],
    "even": [
      "p"
    ],
    "allow": [
      "p",
      "p"
    ],
    "overwriting": [
      "p"
    ],
    "arbitrary": [
      "p"
    ],
    "chucks": [
      "p"
    ],
    "heapthis": [
      "p"
    ],
    "possible": [
      "p",
      "ol",
      "li"
    ],
    "because": [
      "p",
      "p"
    ],
    "calling": [
      "p",
      "ol",
      "li"
    ],
    "leads": [
      "p"
    ],
    "corruption": [
      "p",
      "ol",
      "li",
      "p",
      "p",
      "p"
    ],
    "structure": [
      "p"
    ],
    "this": [
      "p",
      "ol",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "api": [
      "p"
    ],
    "kept": [
      "p"
    ],
    "thus": [
      "p"
    ],
    "allowing": [
      "p",
      "ol",
      "li"
    ],
    "attackers": [
      "p"
    ],
    "parts": [
      "p"
    ],
    "fully": [
      "p"
    ],
    "familiarize": [
      "p"
    ],
    "with": [
      "p",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "p",
      "p"
    ],
    "different": [
      "p",
      "ol",
      "li"
    ],
    "implementation": [
      "p"
    ],
    "such": [
      "p",
      "ol",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "data": [
      "p",
      "p"
    ],
    "commonly": [
      "p"
    ],
    "involves": [
      "p"
    ],
    "finds": [
      "ol",
      "ol",
      "li",
      "li"
    ],
    "functionality": [
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li"
    ],
    "under": [
      "ol",
      "ol",
      "li",
      "li"
    ],
    "frees": [
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p"
    ],
    "accessible": [
      "ol",
      "li"
    ],
    "forces": [
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li"
    ],
    "load": [
      "ol",
      "li"
    ],
    "shell": [
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li"
    ],
    "code": [
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "into": [
      "ol",
      "ol",
      "li",
      "li"
    ],
    "using": [
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li"
    ],
    "the applicationthis": [
      "ol",
      "li"
    ],
    "might": [
      "ol",
      "li"
    ],
    "be": [
      "ol",
      "li",
      "p"
    ],
    "through": [
      "ol",
      "li"
    ],
    "graphical": [
      "ol",
      "li"
    ],
    "user": [
      "ol",
      "ol",
      "li",
      "li"
    ],
    "interfacegui)": [
      "ol",
      "li"
    ],
    "other": [
      "ol",
      "li",
      "p"
    ],
    "interfaces": [
      "ol",
      "li"
    ],
    "copying": [
      "ol",
      "li"
    ],
    "specific": [
      "ol",
      "li"
    ],
    "input": [
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p"
    ],
    "box": [
      "ol",
      "li"
    ],
    "guis": [
      "ol",
      "li"
    ],
    "sending": [
      "ol",
      "li"
    ],
    "parameter": [
      "ol",
      "ol",
      "li",
      "li"
    ],
    "innon-guis).": [
      "ol",
      "li"
    ],
    "call": [
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li"
    ],
    "arrange": [
      "ol",
      "li"
    ],
    "attackhere": [
      "ol",
      "li"
    ],
    "must": [
      "ol",
      "li"
    ],
    "find": [
      "ol",
      "li"
    ],
    "prepare": [
      "ol",
      "li"
    ],
    "executes": [
      "ol",
      "ol",
      "li",
      "li"
    ],
    "found": [
      "ol",
      "li",
      "p"
    ],
    "same": [
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p"
    ],
    "chunk": [
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li"
    ],
    "corrupt": [
      "ol",
      "li"
    ],
    "again": [
      "ol",
      "ol",
      "li",
      "li"
    ],
    "size": [
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li"
    ],
    "freed": [
      "ol",
      "ol",
      "li",
      "li"
    ],
    "chunkthe": [
      "ol",
      "li"
    ],
    "can": [
      "ol",
      "li",
      "p",
      "p"
    ],
    "do": [
      "ol",
      "li"
    ],
    "thisby": [
      "ol",
      "li"
    ],
    "but": [
      "ol",
      "li"
    ],
    "copies": [
      "ol",
      "li"
    ],
    "address": [
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li"
    ],
    "target": [
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "p"
    ],
    "strcpy": [
      "ol",
      "li",
      "i",
      "i",
      "i"
    ],
    "at": [
      "ol",
      "li"
    ],
    "allocated": [
      "ol",
      "ol",
      "li",
      "li"
    ],
    "previous": [
      "ol",
      "li",
      "p"
    ],
    "chunkthis": [
      "ol",
      "li"
    ],
    "overwrites": [
      "ol",
      "li"
    ],
    "strcpy)": [
      "ol",
      "li"
    ],
    "global": [
      "ol",
      "li"
    ],
    "offset": [
      "ol",
      "li"
    ],
    "table": [
      "ol",
      "li"
    ],
    "copied": [
      "ol",
      "li"
    ],
    "bytes": [
      "ol",
      "li"
    ],
    "7.": [
      "ol",
      "li"
    ],
    "ends": [
      "ol",
      "li"
    ],
    "up": [
      "ol",
      "li"
    ],
    "strcpy).this": [
      "ol",
      "li"
    ],
    "detailed": [
      "p"
    ],
    "scenario": [
      "p"
    ],
    "example": [
      "p",
      "p"
    ],
    "read": [
      "p"
    ],
    "report": [
      "p"
    ],
    "about": [
      "p"
    ],
    "remote": [
      "p",
      "p",
      "strong"
    ],
    "vulnerability": [
      "p",
      "p",
      "p",
      "p",
      "strong"
    ],
    "discovered": [
      "p"
    ],
    "concurrent": [
      "p"
    ],
    "versioning": [
      "p"
    ],
    "system": [
      "p",
      "p"
    ],
    "cvs)": [
      "p"
    ],
    "linux": [
      "p"
    ],
    "i]": [
      "p",
      "p"
    ],
    "one": [
      "p"
    ],
    "internet": [
      "p",
      "p",
      "strong"
    ],
    "explorer’s": [
      "p"
    ],
    "adodbrecordset": [
      "p",
      "p",
      "strong"
    ],
    "ii].": [
      "p"
    ],
    "platformsattackers": [
      "p"
    ],
    "exploit": [
      "p",
      "p",
      "p",
      "p",
      "strong"
    ],
    "usage": [
      "p"
    ],
    "rtlheap": [
      "p",
      "i"
    ],
    "heapfree": [
      "p",
      "i"
    ],
    "attacks": [
      "p"
    ],
    "next": [
      "p"
    ],
    "what": [
      "p",
      "p"
    ],
    "them": [
      "p",
      "p"
    ],
    "how": [
      "p",
      "p",
      "title"
    ],
    "protect": [
      "p"
    ],
    "against": [
      "p"
    ],
    "vulnerabilities": [
      "p",
      "p",
      "p",
      "strong"
    ],
    "exist": [
      "p"
    ],
    "timefor": [
      "p"
    ],
    "following": [
      "p"
    ],
    "shows": [
      "p"
    ],
    "simple": [
      "p"
    ],
    "char*": [
      "pre",
      "pre"
    ],
    "str": [
      "pre"
    ],
    "=": [
      "pre",
      "pre",
      "pre"
    ],
    "char*)malloc": [
      "pre",
      "pre"
    ],
    "str_sz);...if": [
      "pre",
      "pre"
    ],
    "cond)": [
      "pre",
      "pre"
    ],
    "{freestr);}...free(str);": [
      "pre"
    ],
    "str=": [
      "pre"
    ],
    "{freestr);str": [
      "pre"
    ],
    "}..free(str);str": [
      "pre"
    ],
    "now": [
      "p"
    ],
    "you’ve": [
      "p"
    ],
    "understood": [
      "p"
    ],
    "reviewed": [
      "p"
    ],
    "countermeasure": [
      "p"
    ],
    "necessary": [
      "p",
      "p",
      "p"
    ],
    "cases": [
      "p"
    ],
    "check": [
      "p",
      "p"
    ],
    "if": [
      "p",
      "p",
      "p",
      "p"
    ],
    "your": [
      "p",
      "p",
      "p"
    ],
    "you": [
      "p",
      "p",
      "p",
      "p"
    ],
    "have": [
      "p"
    ],
    "source": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "access": [
      "p",
      "p",
      "p"
    ],
    "strongly": [
      "p"
    ],
    "perform": [
      "p",
      "p"
    ],
    "reviews": [
      "p",
      "p"
    ],
    "run": [
      "p"
    ],
    "static": [
      "p"
    ],
    "analysis": [
      "p",
      "p",
      "p"
    ],
    "tools": [
      "p",
      "p"
    ],
    "discover": [
      "p"
    ],
    "vulnerabilitiesas": [
      "p"
    ],
    "shown": [
      "p",
      "p"
    ],
    "section": [
      "p"
    ],
    "look": [
      "p"
    ],
    "time": [
      "p"
    ],
    "hasn’t": [
      "p"
    ],
    "been": [
      "p"
    ],
    "set": [
      "p"
    ],
    "nullas": [
      "p"
    ],
    "extend": [
      "p"
    ],
    "across": [
      "p"
    ],
    "numerous": [
      "p"
    ],
    "modules": [
      "p"
    ],
    "lines": [
      "p"
    ],
    "tool": [
      "p"
    ],
    "great": [
      "p"
    ],
    "help": [
      "p"
    ],
    "heresome": [
      "p"
    ],
    "include": [
      "p",
      "p"
    ],
    "checks": [
      "p"
    ],
    "open": [
      "p"
    ],
    "rats": [
      "p"
    ],
    "commercial": [
      "p"
    ],
    "ones": [
      "p"
    ],
    "checkmarx": [
      "p"
    ],
    "not": [
      "p"
    ],
    "option": [
      "p"
    ],
    "way": [
      "p"
    ],
    "errors": [
      "p"
    ],
    "overflowsattach": [
      "p"
    ],
    "debugger": [
      "p",
      "p"
    ],
    "capable": [
      "p"
    ],
    "detecting": [
      "p"
    ],
    "ntsd": [
      "p",
      "i"
    ],
    "gflags.then,": [
      "p"
    ],
    "submit": [
      "p"
    ],
    "malicious": [
      "p",
      "p"
    ],
    "like": [
      "p"
    ],
    "overly": [
      "p"
    ],
    "long": [
      "p",
      "p"
    ],
    "strings": [
      "p",
      "p"
    ],
    "containing": [
      "p"
    ],
    "special": [
      "p"
    ],
    "escape": [
      "p"
    ],
    "charactersif": [
      "p"
    ],
    "situation": [
      "p"
    ],
    "will": [
      "p"
    ],
    "break": [
      "p"
    ],
    "showing": [
      "p"
    ],
    "gflags": [
      "i"
    ],
    "successfully": [
      "p",
      "p"
    ],
    "learn": [
      "p",
      "p"
    ],
    "management": [
      "p",
      "p"
    ],
    "platform-specifics": [
      "p"
    ],
    "freefor": [
      "p"
    ],
    "instance": [
      "p"
    ],
    "since": [
      "p"
    ],
    "microsoft": [
      "p",
      "p",
      "strong"
    ],
    "xp": [
      "p",
      "p"
    ],
    "sp2windows": [
      "p"
    ],
    "platforms": [
      "p"
    ],
    "security": [
      "p"
    ],
    "cookie": [
      "p"
    ],
    "tampered": [
      "p"
    ],
    "freeeven": [
      "p"
    ],
    "though": [
      "p"
    ],
    "similar": [
      "p"
    ],
    "measures": [
      "p",
      "p"
    ],
    "make": [
      "p"
    ],
    "exploitation": [
      "p"
    ],
    "more": [
      "p"
    ],
    "difficult": [
      "p"
    ],
    "there": [
      "p"
    ],
    "ways": [
      "p"
    ],
    "bypass": [
      "p"
    ],
    "affected": [
      "p"
    ],
    "csrss": [
      "p",
      "i"
    ],
    "sp2": [
      "p"
    ],
    "iii].": [
      "p"
    ],
    "conclusions": [
      "h1"
    ],
    "dangerous": [
      "p"
    ],
    "they": [
      "p"
    ],
    "remotely": [
      "p"
    ],
    "privileges": [
      "p"
    ],
    "applicationto": [
      "p"
    ],
    "its": [
      "p",
      "p"
    ],
    "well": [
      "p"
    ],
    "take": [
      "p"
    ],
    "detect": [
      "p"
    ],
    "codeif": [
      "p"
    ],
    "lack": [
      "p"
    ],
    "submitting": [
      "p"
    ],
    "very": [
      "p"
    ],
    "malformed": [
      "p"
    ],
    "overflowsfinally,": [
      "p"
    ],
    "remember": [
      "p"
    ],
    "specifics": [
      "p"
    ],
    "operating": [
      "p"
    ],
    "runs": [
      "p"
    ],
    "cvs": [
      "p",
      "strong"
    ],
    "http//www.securiteam.com/unixfocus/5vp0p0a8uq.html": [
      "p",
      "a"
    ],
    "ii]": [
      "p"
    ],
    "explorer": [
      "p",
      "strong"
    ],
    "ms07-009).": [
      "p",
      "strong"
    ],
    "milw0rmcom.": [
      "p"
    ],
    "http//www.milw0rm.com/exploits/3577": [
      "p",
      "a"
    ],
    "iii]": [
      "p"
    ],
    "matt": [
      "p"
    ],
    "conover": [
      "p"
    ],
    "badcoded": [
      "p"
    ],
    "http//badcoded.blogspot.com/2007/12/double-free-vulnerabilities-on-windows.html": [
      "p",
      "a"
    ]
  },
  "tags": {
    "h1": [
      "Summary",
      "Step 1: Understand attack scenarios",
      "Step 2: Analyze Causes and Countermeasures",
      "Step 3: Start Testing and Exploring",
      "Step 4: Execute Additional Testing",
      "Conclusions"
    ],
    "p": [
      "A double free bug is a coding error where an application uses malloc to allocate a memory block and then uses free to release the block twice, without reinitializing the pointer to the block or setting it to null between the two calls to free.As a result of executing the second free, the internal heap structures used by malloc (HeapAlloc in Windows) become corrupted.An attacker takes advantage of a double free bug to in order to overwrite an application’s memory and get execution control of the application.",
      "It is recommended to follow these steps to test for double free bugs:",
      "The first step in testing for double free bugs is to understand their attack scenarios.",
      "C/C++ applications use malloc() and free() family of functions to allocate and deallocate memory respectively.These two functions use memory chunks which are stored as internal heap structures in the form of a doubly linked list.When malloc and free are called, routines execute that maintain the linked link list by splitting, coalescing, and rearrangingchunks.",
      "During a double free attack, an attacker exploits the fact that an application calls the memory releasing function free twice on a memory chunk.Ifthe application is vulnerable it may crash or even allow overwriting arbitrary chucks of the heap.This overwrite is possible because calling free twice on a memory block leads to corruption of an internal structure used by this API that is kept in the heap, thus allowing attackers to overwrite parts of the heap.",
      "To fully understand double free bugs it is recommended to familiarize with the different implementation of functions such as malloc and free and their internal data structures. A double free attack commonly involves these steps:",
      "For a detailed attack scenario example read the bug report about a remote double free vulnerability discovered in Concurrent Versioning System (CVS) application in Linux [i] or the one found in Internet Explorer’s ADODB.Recordset function [ii].",
      "In Windows platformsattackers exploit the usage of RtlHeap, HeapAlloc, and HeapFree to execute double free attacks.",
      "The next step in testing for double free bugs is to understand what causes them and how to protect against them.",
      "Double free vulnerabilities exist because an application frees a block of memory for a second time.For example, the following code shows a simple double free vulnerability:",
      "",
      "Now that you’ve understood double free attack scenarios and reviewed what causes and how to countermeasure double free bugs, it is necessary to execute test cases to check if your application is vulnerable.",
      "If you have source code access, it is strongly recommended to perform code reviews and run static analysis tools in order to discover double free vulnerabilities.As shown in the previous section, look for a free that is called a second time on a pointer that hasn’t been set to null.As these two calls can extend across numerous modules and lines of code, a source analysis tool can be of great help here.Some tools that include double free checks include open source RATS and commercial ones such as Checkmarx.",
      "If access to source code is not an option, it is recommended that you test for double frees in the same way you test for heap corruption errors such as heap overflows.Attach a debugger that is capable of detecting heap corruption scenarios (such as ntsd with gflags).Then, submit malicious input to the application like overly long strings or input containing special and escape characters.If the malicious input causes a double free situation, the debugger will break showing a heap corruption.",
      "To successfully exploit double free bugs it is necessary to learn the heap management platform-specifics for functions such as malloc and free.For instance, since the release of Microsoft Windows XP SP2,Windows platforms use a security cookie to check if heap chunks are tampered in between calls to functions such as free.Even though, this and other similar measures make exploitation of this bug more difficult, there are ways to bypass such measures, as shown in a double free bug that affected CSRSS in XP SP2 [iii].",
      "Double free vulnerabilities are dangerous as they may allow an attacker to remotely execute code with the same privileges of the target application.To test for this vulnerability, it is necessary to understand its attack scenarios as well as its causes and countermeasures.  Perform code reviews and take advantage of source analysis to detect this bug in your source code.If you lack source code access, test for this bug by submitting very long strings and malformed data such as testing for heap overflows.Finally, to successfully exploit this bug, remember to learn the heap management specifics for the operating system your application runs in.",
      "[i] CVS Remote Vulnerability. http://www.securiteam.com/unixfocus/5VP0P0A8UQ.html",
      "[ii] Microsoft Internet Explorer ADODB.Recordset Double Free Memory Exploit (ms07-009).  milw0rm.com. http://www.milw0rm.com/exploits/3577",
      "[iii] Double Free Vulnerabilities on Windows.  Matt Conover.  Badcoded, 2007. http://badcoded.blogspot.com/2007/12/double-free-vulnerabilities-on-windows.html",
      ""
    ],
    "i": [
      "malloc",
      "free",
      "free",
      "free,",
      "malloc",
      "HeapAlloc",
      "malloc()",
      "free()",
      "malloc",
      "free",
      "free",
      "free",
      "malloc",
      "free",
      ".",
      "malloc",
      "malloc,",
      "free.",
      "malloc",
      "malloc",
      "strcpy",
      "malloc",
      "strcpy)",
      "strcpy",
      "RtlHeap",
      "HeapAlloc",
      "HeapFree",
      "free",
      "ntsd",
      "gflags",
      "malloc",
      "free.",
      "free.",
      "CSRSS"
    ],
    "ul": [
      "Step 1: Understand attack scenarios \n    Step 2: Analyze causes and countermeasures \n    Step 3: Start testing and exploring \n    Step 4: Execute additional testing"
    ],
    "li": [
      "Step 1: Understand attack scenarios",
      "Step 2: Analyze causes and countermeasures",
      "Step 3: Start testing and exploring",
      "Step 4: Execute additional testing",
      "The attacker finds an application functionality under which the application double frees a memory block accessible to attacker.",
      "The attacker forces the application to load shell code into memory by using the application.This might be possible through the graphical user interface(GUI) or other user interfaces by copying the shell code to a specific input box (in GUIs) or sending it to the application as an input parameter (innon-GUIs).",
      "The attacker forces the application to call malloc to arrange internal structures for the attack.Here the attacker must find an application functionality that calls malloc, allowing the attacker to prepare the attack.",
      "The attacker executes the application functionality found in step 1 under which the application double frees the same memory chunk using free. This causes the application to corrupt malloc internal structures (heap control block in Windows)",
      "The attacker forces the application to call malloc again with size of double freed chunk.The attacker can do thisby executing the same functionality in step 3 but using a different input parameter size.",
      "The attacker copies the address of shell code and target function such as strcpy at the start of the chunk allocated in the previous step.",
      "The attacker forces the application to call malloc again with size of double freed chunk.This causes the memory corruption; the application overwrites the address of the target function (strcpy) in the global offset table with the address of the shell code (copied into the first 8 bytes of the allocated chunk during step 7).",
      "The attacker finds and executes an application functionality that ends up calling the target function (strcpy).This causes the application to execute shell code."
    ],
    "ol": [
      "The attacker finds an application functionality under which the application double frees a memory block accessible to attacker. \n    The attacker forces the application to load shell code into memory by using the application.This might be possible through the graphical user interface(GUI) or other user interfaces by copying the shell code to a specific input box (in GUIs) or sending it to the application as an input parameter (innon-GUIs). \n    The attacker forces the application to call malloc to arrange internal structures for the attack.Here the attacker must find an application functionality that calls malloc, allowing the attacker to prepare the attack. \n    The attacker executes the application functionality found in step 1 under which the application double frees the same memory chunk using free. This causes the application to corrupt malloc internal structures (heap control block in Windows) \n    The attacker forces the application to call malloc again with size of double freed chunk.The attacker can do thisby executing the same functionality in step 3 but using a different input parameter size. \n    The attacker copies the address of shell code and target function such as strcpy at the start of the chunk allocated in the previous step. \n    The attacker forces the application to call malloc again with size of double freed chunk.This causes the memory corruption; the application overwrites the address of the target function (strcpy) in the global offset table with the address of the shell code (copied into the first 8 bytes of the allocated chunk during step 7). \n    The attacker finds and executes an application functionality that ends up calling the target function (strcpy).This causes the application to execute shell code."
    ],
    "pre": [
      "char* str = (char*)malloc (STR_SZ);...if (cond) {free(str);}...free(str);",
      "char* str= (char*)malloc (STR_SZ);...if (cond) {free(str);str = NULL;  }...free(str);str = NULL;"
    ],
    "br": [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
    ],
    "b": [
      "",
      ""
    ],
    "div": [
      ""
    ],
    "hr": [
      ""
    ],
    "strong": [
      "CVS Remote Vulnerability",
      "Microsoft Internet Explorer ADODB.Recordset Double Free Memory Exploit (ms07-009).",
      "Double Free Vulnerabilities on Windows",
      "."
    ],
    "a": [
      "http://www.securiteam.com/unixfocus/5VP0P0A8UQ.html",
      "http://www.milw0rm.com/exploits/3577",
      "http://badcoded.blogspot.com/2007/12/double-free-vulnerabilities-on-windows.html"
    ]
  },
  "links": [
    {
      "href": "http://www.securiteam.com/unixfocus/5VP0P0A8UQ.html",
      "text": "http://www.securiteam.com/unixfocus/5VP0P0A8UQ.html"
    },
    {
      "href": "http://www.milw0rm.com/exploits/3577",
      "text": "http://www.milw0rm.com/exploits/3577"
    },
    {
      "href": "http://badcoded.blogspot.com/2007/12/double-free-vulnerabilities-on-windows.html",
      "text": "http://badcoded.blogspot.com/2007/12/double-free-vulnerabilities-on-windows.html"
    }
  ],
  "html": "<h1>Summary  </h1>\n  <p>A double free bug is a coding error where an application uses <i>malloc</i> to allocate a memory block and then uses <i>free</i> to release the block twice, without reinitializing the pointer to the block or setting it to null between the two calls to <i>free</i>.As a result of executing the second <i>free,</i> the internal heap structures used by <i>malloc</i> (<i>HeapAlloc</i> in Windows) become corrupted.An attacker takes advantage of a double free bug to in order to overwrite an application’s memory and get execution control of the application.&nbsp;&nbsp; </p>\n  <p>It is recommended to follow these steps to test for double free bugs:</p>\n  <ul>\n    <li>Step 1: Understand attack scenarios </li>\n    <li>Step 2: Analyze causes and countermeasures </li>\n    <li>Step 3: Start testing and exploring </li>\n    <li>Step 4: Execute additional testing</li>\n  </ul>\n  <h1>\nStep 1: Understand attack scenarios\n</h1>\n  <p>The first step in testing for double free bugs is to understand their attack scenarios.</p>\n  <p>C/C++ applications use <i>malloc()</i> and <i>free() </i>family of functions to allocate and deallocate memory respectively.These two functions use memory chunks which are stored as internal heap structures in the form of a doubly linked list.When <i>malloc </i>and <i>free</i> are called, routines execute that maintain the linked link list by splitting, coalescing, and rearrangingchunks. &nbsp;</p>\n  <p>During a double free attack, an attacker exploits the fact that an application calls the memory releasing function <i>free</i> twice on a memory chunk.Ifthe application is vulnerable it may crash or even allow overwriting arbitrary chucks of the heap.This overwrite is possible because calling <i>free</i> twice on a memory block leads to corruption of an internal structure used by this API that is kept in the heap, thus allowing attackers to overwrite parts of the heap.</p>\n  <p>To fully understand double free bugs it is recommended to familiarize with the different implementation of functions such as <i>malloc</i> and <i>free</i> and their internal data structures<i>. </i>A double free attack commonly involves these steps:</p>\n  <ol>\n    <li>The attacker finds an application functionality under which the application double frees a memory block accessible to attacker. </li>\n    <li>The attacker forces the application to load shell code into memory by using the&nbsp;application.This might be possible through the graphical user interface(GUI) or other user interfaces by copying the shell code to a specific input box (in GUIs) or sending it to the application as an input parameter (innon-GUIs). </li>\n    <li>The attacker forces the application to call <i>malloc</i> to arrange internal structures for the attack.Here the attacker must find an application functionality that calls <i>malloc,</i> allowing the attacker to prepare the attack. </li>\n    <li>The attacker executes the application functionality found in step 1 under which the application double frees the same memory chunk using <i>free. </i>This causes the application to corrupt <i>malloc</i> internal structures (heap control block in Windows) </li>\n    <li>The attacker forces the application to call <i>malloc</i> again with size of double freed chunk.The attacker can do thisby executing the same functionality in step 3 but using a different input parameter size. </li>\n    <li>The attacker copies the address of shell code and target function such as <i>strcpy</i> at the start of the chunk allocated in the previous step. </li>\n    <li>The attacker forces the application to call <i>malloc</i> again with size of double freed chunk.This causes the memory corruption; the application overwrites the address of the target function (<i>strcpy)</i> in the global offset table with the address of the shell code (copied into the first 8 bytes of the allocated chunk during step 7). </li>\n    <li>The attacker finds and executes an application functionality that ends up calling the target function (<i>strcpy</i>).This causes the application to execute shell code.&nbsp;</li>\n  </ol>\n  <p>For a detailed attack scenario example read the bug report about a remote double free vulnerability discovered in Concurrent Versioning System (CVS) application in Linux [i] or the one found in Internet Explorer’s ADODB.Recordset function [ii].</p>\n  <p>In Windows platformsattackers exploit the usage of <i>RtlHeap</i>, <i>HeapAlloc</i>, and <i>HeapFree</i> to execute double free attacks.</p>\n  <h1>\nStep 2: Analyze Causes and Countermeasures\n</h1>\n  <p>The next step in testing for double free bugs is to understand what causes them and how to protect against them.</p>\n  <p>Double free vulnerabilities exist because an application frees a block of memory for a second time.For example, the following code shows a simple double free vulnerability:</p>\n  <pre>char* str = (char*)malloc (STR_SZ);<br />...<br />if (cond) {<br />free(str);<br />}<br />...<br />free(str);\n</pre>To protect against double free vulnerabilities it is necessary to set any freed memory pointer to null right after freeing it:<br /><pre>char* str= (char*)malloc (STR_SZ);<br />...<br />if (cond) {<br />free(str);<br />str = NULL;&nbsp; <br />}<br />...<br />free(str);<br />str = NULL;</pre><p><b></b></p><h1>Step 3: Start Testing and Exploring</h1><p>Now that you’ve understood double free attack scenarios and reviewed what causes and how to countermeasure double free bugs, it is necessary to execute test cases to check if your application is vulnerable.</p><p>If you have source code access, it is strongly recommended to perform code reviews and run static analysis tools in order to discover double free vulnerabilities.As shown in the previous section, look for a <i>free</i> that is called a second time on a pointer that hasn’t been set to null.As these two calls can extend across numerous modules and lines of code, a source analysis tool can be of great help here.Some tools that include double free checks include open source RATS and commercial ones such as Checkmarx.</p><p>If access to source code is not an option, it is recommended that you test for double frees in the same way you test for heap corruption errors such as heap overflows.Attach a debugger that is capable of detecting heap corruption scenarios (such as <i>ntsd</i> with <i>gflags</i>).Then, submit malicious input to the application like overly long strings or input containing special and escape characters.If the malicious input causes a double free situation, the debugger will break showing a heap corruption.<br />&nbsp;</p><h1>Step 4: Execute Additional Testing</h1><p>To successfully exploit double free bugs it is necessary to learn the heap management platform-specifics for functions such as <i>malloc</i> and<i> free.</i>For instance, since the release of Microsoft Windows XP SP2,Windows platforms use a security cookie to check if heap chunks are tampered in between calls to functions such as <i>free.</i>Even though, this and other similar measures make exploitation of this bug more difficult, there are ways to bypass such measures, as shown in a double free bug that affected <i>CSRSS</i> in XP SP2 [iii].&nbsp;&nbsp;&nbsp; </p><h1>Conclusions</h1><p>Double free vulnerabilities are dangerous as they may allow an attacker to remotely execute code with the same privileges of the target application.To test for this vulnerability, it is necessary to understand its attack scenarios as well as its causes and countermeasures.&nbsp; Perform code reviews and take advantage of source analysis to detect this bug in your source code.If you lack source code access, test for this bug by submitting very long strings and malformed data such as testing for heap overflows.Finally, to successfully exploit this bug, remember to learn the heap management specifics for the operating system your application runs in.<b></b></p><div><hr /></div><p>[i] <strong>CVS Remote Vulnerability</strong>. <a href=\"http://www.securiteam.com/unixfocus/5VP0P0A8UQ.html\">http://www.securiteam.com/unixfocus/5VP0P0A8UQ.html</a></p><p>[ii] <strong>Microsoft Internet Explorer ADODB.Recordset Double Free Memory Exploit (ms07-009).</strong>&nbsp; milw0rm.com. <a href=\"http://www.milw0rm.com/exploits/3577\">http://www.milw0rm.com/exploits/3577</a></p><p>[iii] <strong>Double Free Vulnerabilities on Windows</strong><strong>. </strong>&nbsp;Matt Conover.&nbsp; Badcoded, 2007. <a href=\"http://badcoded.blogspot.com/2007/12/double-free-vulnerabilities-on-windows.html\">http://badcoded.blogspot.com/2007/12/double-free-vulnerabilities-on-windows.html</a></p><p>&nbsp;</p>"
}