<h1>Summary</h1>
  <p>The purpose of this code snippet is to illustrate how to decrypt and validate an encrypted application cookie set by a trusted application. This code example demonstrates how to verify the integrity and freshenss (e.g. timestamp) of the message contained within the encrypted blob. This code sample may be used when there exists no common server-side session state.</p>
  <h1>Objectives</h1>
  <ul>
    <li>Provide controls to mitigate potential session replay vulnerabilities.</li>
    <li>Protect against users' ability to tamper with cookie parameters which may impact the business logic, authentication or authorization context or overall data integrity through HMAC message signing.</li>
    <li>Provide controls which validate message integrity and detect message tampering.</li>
    <li>Ensure the secure storage of a shared secret encryption key and HMAC signing key through use of the Data Protection API (DPAPI).</li>
  </ul>
  <h1>Scenarios</h1>
  <ul>
    <li>Web application needs to distribute some details within the session state to another application (e.g. Single sign-on, distributed web server architecture). </li>
    <li>Web applications are deployed within an infrastructure where it isn't feasible to share session state through a common server-side data store. </li>
    <li>A shared symmetric key and HMAC signing key are pre-established either out of band or via some other secure communication channel. </li>
    <li>Developers wish to avoid users from tampering with cookie parameters which may impact the business logic, authentication or authorization context or overall data integrity.</li>
    <li>Securely distributing session state to an external application.</li>
    <li>Providing confidentiality through cookie encryption.</li>
    <li>Providing message integrity through HMAC code embedded in crypto blob.</li>
    <li>Mitigate session replay through use of a session timeout mechanism.</li>
    <li>A user must retrieve data distributed across multiple web servers, each which serve a different purpose, e.g. customer portal, reporting server, etc.</li>
  </ul>
  <h1>Solution Example</h1>
  <p>
    <strong>DPAPI Utility Class for retrieval and storage of keys:</strong>
  </p>
  <pre>public class DPAPIUtil<br />{<br />    private string registryKeyName = "ACMEWebApplication";<br />    private string registryEncValueName = "symmetrickey";<br />    private string registryHMACValueName = "hmackey";<br />    string fullRegistryKeyPath = "";<br /><br />    public DPAPIUtil()<br />    {<br />           fullRegistryKeyPath = @"HKEY_CURRENT_USER\" + registryKeyName;<br />    }<br /><br />    public void StoreHMACKey(byte[] val)<br />    {<br />        // Encrypt the HMAC signing key using the DPAPI ProtectedData class.<br />        //<br />        // We're using the CurrentUser scope instead of the MachineKey scope<br />        // so that other, potentially malicious applications cannot access<br />        // this key in the registry and decrypt.<br />        byte[] encryptedValBytes = ProtectedData.Protect(val, null,<br />            DataProtectionScope.CurrentUser);<br /><br />        // Create a security context for a new key that we will use to store our encrypted connection string.<br />        // The security context will restrict access to only our user.<br />        string user = Environment.UserDomainName + "\\" + Environment.UserName;<br />        RegistrySecurity security = new RegistrySecurity();<br />        RegistryAccessRule rule = new RegistryAccessRule(user,<br />                        RegistryRights.FullControl,<br />                        InheritanceFlags.ContainerInherit,<br />                        PropagationFlags.None,<br />                        AccessControlType.Allow);<br />        security.AddAccessRule(rule);<br /><br />        // Actually create the new registry key and apply the security context we just came up with.<br />        Registry.CurrentUser.CreateSubKey(registryKeyName,<br />                        RegistryKeyPermissionCheck.ReadWriteSubTree,<br />                        security);<br /><br />        // Write the encrypted string into the registry<br />        Registry.SetValue(fullRegistryKeyPath, registryHMACValueName, encryptedValBytes);<br />    }<br /><br />    public void StoreSymmKey(byte[] val)<br />    {<br />        // Encrypt the shared secret key using the DPAPI ProtectedData class.<br />        // <br />        // We're using the CurrentUser scope instead of the MachineKey scope<br />        // so that other, potentially malicious applications cannot access<br />        // this key in the registry and decrypt.<br />        byte[] encryptedValBytes = ProtectedData.Protect(val, null,<br />            DataProtectionScope.CurrentUser);<br /><br />        // Create a security context for a new key that we will use to store our shared secret key.<br />        // The security context will restrict access to only our user.<br />        string user = Environment.UserDomainName + "\\" + Environment.UserName;<br />        RegistrySecurity security = new RegistrySecurity();<br />        RegistryAccessRule rule = new RegistryAccessRule(user,<br />                        RegistryRights.FullControl,<br />                        InheritanceFlags.ContainerInherit,<br />                        PropagationFlags.None,<br />                        AccessControlType.Allow);<br />        security.AddAccessRule(rule);<br /><br />        // Actually create the new registry key and apply the security context we just came up with.<br />        Registry.CurrentUser.CreateSubKey(registryKeyName,<br />                        RegistryKeyPermissionCheck.ReadWriteSubTree,<br />                        security);<br /><br />        // Write the encrypted string into the registry<br />        Registry.SetValue(fullRegistryKeyPath, registryEncValueName, encryptedValBytes);<br />    }<br /><br />    public byte[] RetrieveHMACKey()<br />    {<br />         // Read the encrypted hmac signing key value from the registry<br />         byte[] encryptedValBytes = Registry.GetValue(fullRegistryKeyPath, registryHMACValueName, null) as byte[];<br /><br />         // Decrypt the encrypted bytes using DPAPI and return<br />         byte[] decryptedValBytes = ProtectedData.Unprotect(encryptedValBytes,<br />                null,<br />                DataProtectionScope.CurrentUser);<br />         return decryptedValBytes;<br />    }<br /><br />    public byte[] RetrieveSymmKey()<br />    {<br />        // Read the encrypted symmetric key value from the registry<br />        byte[] encryptedValBytes = Registry.GetValue(fullRegistryKeyPath, registryEncValueName, null) as byte[];<br /><br />        // Decrypt the encrypted bytes using DPAPI and return<br />        byte[] decryptedValBytes = ProtectedData.Unprotect(encryptedValBytes,<br />            null,<br />            DataProtectionScope.CurrentUser);<br /><br />        return decryptedValBytes;<br />    }<br />}</pre>
  <p>
    <strong>Decrypting and validating the encrypted & signed key in our cookie</strong>
  </p>
  <p>Retrieve the cookie values:</p>
  <pre>        bool isValidHMAC = false;<br />        bool isValidTS = false;<br /><br />        // Read our encrypted cookie value<br />        byte[] encvalWithIV = Convert.FromBase64String(Request.Cookies["CookieJar"].Value);<br />        byte[] iv = new byte[16];<br /><br />        // We're expecting a 16 byte IV<br />        byte[] encval = new byte[encvalWithIV.Length - 16];<br /><br />        // Byte array for our message without IV<br />        // Parse the IV from the first 16 bytes of the cookie<br />        Array.Copy(encvalWithIV, iv, iv.Length);<br /><br />        Array.Copy(encvalWithIV, 16, encval, 0, encval.Length);<br /><br />        // We'll retrieve our symmetric encryption key from the registry<br />        DPAPIUtil dputil = new DPAPIUtil();<br />        byte[] enckey = dputil.RetrieveSymmKey();<br /><br />        // Preparation to decrypt our cookie value:<br />        // <br />        // Create the Crypto provider<br />        Rijndael rij = Rijndael.Create();<br /><br />        // Load the DPAPI protected key<br />        rij.Key = enckey;<br />        rij.IV = iv;<br />        MemoryStream ms = new MemoryStream();<br /><br />        // Instantiate our decryptor stream to which we write our encrypted value, our<br />        // memory stream will contain the decrypted value to be used by our application<br />        CryptoStream dcs = new CryptoStream(ms, rij.CreateDecryptor(), CryptoStreamMode.Write);<br /><br />        // Write the decrypted value to the cryptostream<br />        dcs.Write(encval, 0, encval.Length);<br />        dcs.Close();<br />        string decryptedCookie = UnicodeEncoding.ASCII.GetString(ms.ToArray());<br /><br />        // Now we need to validate the HMAC to ensure the message wasn't altered<br />        // We use a distinctly seperate HMAC key to ensure that if the encryption key<br />        // is compromised message integrity may still be guaranteed and protects us against<br />        // parameter tampering.<br />        HMACSHA256 hmac = new HMACSHA256();<br /><br />        // Retrieve the HMAC key from the encrypted registry value using our DPAPI helper<br />        hmac.Key = dputil.RetrieveHMACKey();<br /><br />        // We store the HMAC in the last 32 bytes of the message<br />        byte[] hmacValue = new byte[32];<br />        Array.Copy(ms.ToArray(), ms.ToArray().Length - 32, hmacValue, 0, hmacValue.Length);<br /><br />        // To validate the HMAC we'll recompute an HMAC using the HMAC key and compare this with<br />        // the HMAC sent to us by the remote application<br />        string msg = decryptedCookie.Substring(0, decryptedCookie.Length - 32);<br />        byte[] hmacValueNew = hmac.ComputeHash(UnicodeEncoding.ASCII.GetBytes(msg));<br />        if (Convert.ToBase64String(hmacValue) == Convert.ToBase64String(hmacValueNew))<br />        {<br />            isValidHMAC = true;<br />        }<br />        else<br />        {<br />            // Invalidate our session and throw an error<br />            Session.Abandon();<br />            throw new Exception("Invalid HMAC Detected");<br />        }<br />        lblHMACBool.Text = isValidHMAC.ToString();<br /><br />        // Lastly validate the timestamp to ensure it is no more than 5 minutes old<br />        //<br />        // The timestamp is the last value stored in our message<br />        string ts = msg.Substring(msg.LastIndexOf("|") + 1);<br />        DateTime cookieTs = DateTime.FromBinary(long.Parse(ts));<br />        DateTime curTs = DateTime.Now;<br /><br />        // Determine how old the cookie is that we're trying to validate.<br />        // In our example below we simply check to make sure the cookie isn't older than<br />        // 5 minutes; This technique doesn't elliminate session replay but does help to minimize<br />        // the window of opportunity in which an attacker may replay a session.<br />        //<br />        // In an ideal scenario it may be advantageous to use a sequence number which we<br />        // store in the database each time a cookie is used, so that it may not be used twice.<br />        TimeSpan tspan = new TimeSpan(curTs.Ticks - cookieTs.Ticks);<br /><br />        // If the cookie is older the 5 minutes we'll require the user to obtain a new cookie<br />        if (tspan.Minutes &gt; 5)<br />        {<br />            // Redirect to our source site<br />            Response.Redirect("/CookieExample/SetCookie.aspx");<br />        }<br />        else <br />        {<br />            isValidTS = true;<br />            //Parse the cookie and consume its values after performing data validation<br />        }<br />        lblTSBool.Text = isValidTS.ToString();<br /></pre>
  <h1>Problem Example</h1>
  <p>The following example demonstrates a poorly designed cookie sharing mechanism between two web applications where encryption and key signing are not used:</p>
  <p>Set the cookie value:</p>
  <pre>        cookieval = user + "|" + uid + "|" + adminRole.ToString();<br />        HttpCookie chocolateChip = new HttpCookie("CookieJar", cookieval);<br /><br />        // Ensure that proper secure cookie modes are set:<br />        //<br />        // Make cookies unavailable to client side scripts<br />        chocolateChip.HttpOnly = true;<br /><br />        // Set the cookie transport mechanism to TLS only<br />        chocolateChip.Secure = true;<br /><br />        // Ideally choose a more restrictive domain under which cookies are set<br />        chocolateChip.Domain = ".ourapp.microsoft.com";<br /><br />        // Place some restrictions on which web paths can access our cookies<br />        chocolateChip.Path = "/CookieExample/";<br /><br />        // Finally set the cookie<br />        Response.Cookies.Add(chocolateChip);</pre>
  <p>Retrieve and use the cookie value:</p>
  <pre>        cookieval = Request.Cookies["CookieJar"].Value;<br />        // Parse and consume the cookie value attributes<br />        ...</pre>
  <p>Issues found in this example:</p>
  <ul>
    <li>Sensitive information is exposed within the cookie, potentially containing data which should never be exposed to a user. </li>
    <li>Cookies are vulnerable to tampering by the user (and intermediaries in the event of a man-in-the-middle scenario).</li>
    <li>Cookies are vulnerable to replay.</li>
    <li>If cookies are altered in transit there is no way to detect such a situation.</li>
    <li>Any web application in the .ourapp.microsoft.com domain can access the cookie.</li>
  </ul>
  <p>Careful consideration should be given to other common coding mistakes not shown in the code above:</p>
  <ul>
    <li>Encryption using weak encryption keys (typically &lt;128, but dependent on encryption algorithms).</li>
    <li>Use of unproven or homegrown encryption algorithms.</li>
    <li>Use of improper encryption types (e.g. stream cipher instead of block cipher).</li>
    <li>Use of improper encryption modes (lack of chaining blocks).<ul><li>Leads to easier cookie tampering even with encryption (replace or reorder blocks).</li><li>Leads to information disclosure of common values transmitted.</li></ul></li>
    <li>Failure to choose random initialization vector (IV).<ul><li>Leads to information disclosure of common values transmitted.</li></ul></li>
    <li>Failure to include HMAC.<ul><li>Encrypted values may still be altered and go undetected.</li></ul></li>
    <li>HMAC keys and encryption keys are equal.<ul><li>Compromise of one key leads to total system compromise.</li></ul></li>
    <li>Failure to include timestamp or session id.<ul><li>Encrypted value may be replayed.</li></ul></li>
  </ul>
  <h1>Test Case</h1>
  <p>The following classes must be included in any project making use of the sample code provided above:</p>
  <pre>        using System;<br />        using System.Collections.Generic;<br />        using System.Security.Cryptography;<br />        using System.Security.AccessControl;<br />        using System.Text;<br />        using Microsoft.Win32;</pre>
  <p>Browsing to the web application containing the solution code will establish an encrypted and signed cookie value. The following cookie value is set by the server with secure cookie options:</p>
  <pre>Set-Cookie:<br />CookieJar=g2rzx1QZ94lAOyUxLGscUbQg1/yyG8Gy4NTCjaK5<br />aupWwSXoAdyuNBer0sFZQiK9dx4kZnY0h8hd9xqEe6d8hMvGoJiGhlOh88cx35<br />Jt9sQIQmjAgCmecj6VhHwKfbrZ;<br />domain=.ourapp.microsoft.com;<br />path=/CookieExample/; secure; HttpOnly</pre>
  <p>The cookie values change with each encryption operation (due to random IV, and appended timestamp value). Base64 decoding the "CookieJar" value yields an encrypted array of bytes.</p>
  <h1>Expected Result</h1>
  <p>HTTP Response header:</p>
  <pre>Set-Cookie: CookieJar=g2rzx1QZ94lAOyUxLGscUbQg1/yyG8Gy4NTCja<br />K5aupWwSXoAdyuNBer0sFZQiK9dx4kZnY0h8hd9xqEe6d8hMvGoJiGhlOh88<br />cx35Jt9sQIQmjAgCmecj6VhHwKfbrZ; domain=.ourapp.microsoft.com;<br />path=/CookieExample/; secure; HttpOnly</pre>
  <h1>More Information</h1>
  <p>This implementation makes use of the DPAPI user key as opposed to the machine key. This means that the AES shared secret and HMAC signing key will only be accessible from programs that run within the same user context and will not be accessible by other applications running under different service accounts. This adds additional protection against a rogue application (such as a virus or trojan) compromising connection string data but could pose problems where sharing between mutliple applications running under different accounts is required. We recommend this approach whenever other programs will not need to access the same key material for encryption operations. Encryption of the message alone is not sufficient to protect against message tampering, as such we've included the use of an HMAC (or message integrity check, which relies on a shared secret key). The HMAC is generated by using a seperate shared secret and relies on a strong one-way hashing algorithm to generate a unique hash for the given message. Even with cookie encryption and signing, a user who intercepts these cookies may replay them to the server unless there is a value contained within the message designating the sequence number of the message. The symmetric shared key and HMAC signing key must be securely stored in order to maintain the confidentiality of data encrypted using these keys. In this example, we make use of the DPAPI in order to transparently stored the shared key pair encrypted with in the registry. The details of AES and HMAC message signing are beyond the scope of this article. </p>
  <h1>Additional Resources</h1>
  <ul>
    <li>HMAC definition: <a href="http://en.wikipedia.org/wiki/HMAC">http://en.wikipedia.org/wiki/HMAC</a></li>
    <li>HMAC class: <a href="http://msdn2.microsoft.com/en-US/library/system.security.cryptography.hmac.aspx">http://msdn2.microsoft.com/en-US/library/system.security.cryptography.hmac.aspx</a></li>
  </ul>
  <hr />
  <p>Adapted from Microsoft patterns & practices guidance.</p>