<h1>What to Do</h1>
  <p>Consider using the <b>System.Security.SecureString</b> type to help protect secrets in memory. <b>SecureString</b> objects use DPAPI encryption to store data in an encrypted format in memory. They are only decrypted when they are accessed.</p>
  <h1>Why</h1>
  <p>Although you have to decrypt the data to use it, by using <b>SecureString</b> instead of <b>System.String</b> you gain a number of benefits: </p>
  <ul>
    <li>You help to minimize the number of copies of the secret held in memory, which reduces the attack surface. <li>You reduce the amount of time that the secret is visible to an attacker who has access either to your process memory address space or to the page file. <li>You increase the likelihood that an encrypted version of the secret rather than a clear text version will end up in a dump file if your process crashes.</li></li></li>
  </ul>
  <blockquote>
    <p>
      <b>Note</b>&nbsp;&nbsp;&nbsp;Unfortunately, in many scenarios you are forced to convert the <b>SecureString</b> to a <b>System.String</b> before you can use it. For example, few .NET Framework API methods currently provide overloads that support <b>SecureString</b>. Use of <b>SecureString</b> is less appropriate in ASP.NET applications. For example, It is unlikely you can take a credit card number from a Web page without the number at some point passing through a <b>System.String</b> because most of the form-related APIs do not have function overloads that permit use of <b>SecureString</b> instead of <b>System.String</b>.</p>
  </blockquote>
  <p>Using System.String for storing sensitive information is not recommended for the following reasons: </p>
  <ul>
    <li>It is not pinned, which means that the garbage collector can move it around and leave the data in memory for indeterminate amounts of time. <li>It is not encrypted; therefore, the data can be read from process memory or from the swap file. <li>It is immutable; therefore, there is no effective way of clearing the data after use. Modification leaves both the old copy and a new copy in memory. </li></li></li>
  </ul>
  <h1>When</h1>
  <p>When working with sensitive data in memory.</p>
  <h1>How</h1>
  <h2>Creating a SecureString</h2>
  <p>You can create a <b>SecureString</b> by supplying a pointer to a character array and supplying the length of that array. When constructed this way, the <b>SecureString</b> type takes a copy of your array. You should replace your source array with zeros as soon as the <b>SecureString</b> is constructed. A <b>SecureString</b> can also be constructed without an existing character array, and data can be copied one character at a time. The following code sample shows how to use the <b>AppendChar</b> method to create a secure string one character at a time.</p>
  <pre>using System.Security;<br />...<br />SecureString securePassword = new SecureString(); <br />Console.WriteLine("Enter Password...."); <br />while (true) <br />&#123;<br />&nbsp; ConsoleKeyInfo conKeyInfo = Console.ReadKey(true);<br />&nbsp; if (conKeyInfo.Key == ConsoleKey.Enter)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br />&nbsp; else if (conKeyInfo.Key == ConsoleKey.Escape)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br />&nbsp; else if (conKeyInfo.Key == ConsoleKey.Backspace)<br />&nbsp; &#123;<br />&nbsp;&nbsp;&nbsp;&nbsp; if (securePassword.Length &#33;= 0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; securePassword.RemoveAt(securePassword.Length - 1);<br />&nbsp; &#125;<br />&nbsp; else<br />&nbsp;&nbsp;&nbsp;&nbsp; securePassword.AppendChar(conKeyInfo.KeyChar);<br />&#125;<br />Console.WriteLine(securePassword.Length.ToString());  </pre>
  <h2>Retrieving Data from a SecureString</h2>
  <p>You retrieve data from a <b>SecureString</b> by using the marshaller. The <b>Marshal</b> class has been extended to provide methods that convert a <b>SecureString</b> into a <b>BSTR</b> data type or a raw block of ANSI or Unicode memory. When you have finished using the unprotected string, you should erase that copy by calling <b>Marshal.ZeroFreeBSTR</b>, as shown in the following example.<b></b></p>
  <pre>using System.Security;<br />using System.Runtime.InteropServices;<br />...<br />void UseSecretData(SecureString secret)<br />&#123;<br />&nbsp; IntPtr bstr = Marshal.SecureStringToBSTR(secret);<br />&nbsp; try<br />&nbsp; &#123;<br />&nbsp;&nbsp;&nbsp; // Use the bstr here<br />&nbsp; &#125;<br />&nbsp; finally<br />&nbsp; &#123;<br />&nbsp;&nbsp;&nbsp; // Make sure that the clear text data is zeroed out<br />&nbsp;&nbsp;&nbsp; Marshal.ZeroFreeBSTR(bstr);<br />&nbsp; &#125;<br />&#125;</pre>
  <h1>Additional Resources</h1>
  <ul>
    <li>For more information see "Making Strings more Secure" at <a href="http://blogs.msdn.com/shawnfa/archive/2004/05/27/143254.aspx">http://blogs.msdn.com/shawnfa/archive/2004/05/27/143254.aspx</a></li>
  </ul>
  <hr />
  <p>Adapted from Microsoft patterns & practices guidance.</p>