{
  "id": "55679e3e-7be2-40fe-84fb-e152ebaf03f0",
  "checksum": "7dc548d32f9514a65231ebcb6b0821a948a3220a",
  "words": {
    "0": [
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "2": [
      "p",
      "p"
    ],
    "4": [
      "p"
    ],
    "43": [
      "p"
    ],
    "applies": [
      "h1"
    ],
    "to": [
      "h1",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "ul",
      "ul",
      "li",
      "li",
      "ul",
      "li",
      "pre",
      "pre",
      "pre",
      "ul",
      "ul",
      "li",
      "li",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "p",
      "p"
    ],
    "c#": [
      "ul",
      "li",
      "pre"
    ],
    "summary": [
      "h1"
    ],
    "the": [
      "p",
      "ul",
      "ul",
      "ul",
      "li",
      "li",
      "li",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "purpose": [
      "p"
    ],
    "of": [
      "p",
      "ul",
      "li",
      "ul",
      "ul",
      "li",
      "li",
      "pre",
      "pre",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "this": [
      "p",
      "p"
    ],
    "code": [
      "p",
      "p",
      "p"
    ],
    "snippet": [
      "p",
      "p"
    ],
    "is": [
      "p",
      "pre"
    ],
    "demonstrate": [
      "p"
    ],
    "how": [
      "p"
    ],
    "implement": [
      "p"
    ],
    "secure": [
      "p",
      "pre"
    ],
    "password": [
      "p",
      "ul",
      "li",
      "ul",
      "li",
      "pre",
      "pre",
      "pre",
      "p",
      "pre",
      "pre",
      "pre",
      "ul",
      "ul",
      "li",
      "li",
      "p",
      "pre",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "title"
    ],
    "persistence": [
      "p"
    ],
    "using": [
      "p",
      "pre",
      "pre",
      "p",
      "pre",
      "p",
      "p",
      "title"
    ],
    "a": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "ul",
      "ul",
      "ul",
      "li",
      "li",
      "li",
      "ul",
      "ul",
      "li",
      "li",
      "pre",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "ul",
      "li",
      "p",
      "p",
      "pre",
      "pre",
      "p",
      "p",
      "p",
      "p",
      "p",
      "title",
      "title"
    ],
    "cryptographic": [
      "p",
      "p",
      "p"
    ],
    "hashing": [
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "algorithm": [
      "p",
      "p"
    ],
    "with": [
      "p",
      "p",
      "p"
    ],
    "randomly": [
      "p"
    ],
    "generated": [
      "p"
    ],
    "\"salt\"": [
      "p"
    ],
    "or": [
      "p",
      "p"
    ],
    "\"nonce\"": [
      "p"
    ],
    "value": [
      "p",
      "p",
      "ul",
      "ul",
      "li",
      "li",
      "pre",
      "pre",
      "ul",
      "li",
      "p",
      "p"
    ],
    "algorithms": [
      "p",
      "p"
    ],
    "are": [
      "p",
      "ul",
      "li"
    ],
    "one-way": [
      "p"
    ],
    "encryption": [
      "p",
      "ul",
      "li",
      "p"
    ],
    "used": [
      "p",
      "p"
    ],
    "store": [
      "p",
      "p"
    ],
    "sensitive": [
      "p",
      "ul",
      "li"
    ],
    "data": [
      "p",
      "ul",
      "ul",
      "li",
      "li"
    ],
    "in": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "non-readable": [
      "p"
    ],
    "format": [
      "p"
    ],
    "salt": [
      "p",
      "ul",
      "li",
      "pre",
      "pre",
      "pre",
      "p",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "p",
      "p",
      "title"
    ],
    "can": [
      "p"
    ],
    "be": [
      "p",
      "ul",
      "li",
      "ul",
      "li",
      "p",
      "p"
    ],
    "conjunction": [
      "p"
    ],
    "add": [
      "p",
      "ul",
      "li",
      "pre",
      "pre"
    ],
    "additional": [
      "p"
    ],
    "entropy": [
      "p",
      "ul",
      "li"
    ],
    "encrypted": [
      "p"
    ],
    "values": [
      "p",
      "ul",
      "li",
      "p",
      "p"
    ],
    "and": [
      "p",
      "ul",
      "li",
      "pre",
      "p",
      "pre",
      "ul",
      "li",
      "p",
      "pre",
      "pre",
      "pre",
      "p",
      "p"
    ],
    "protect": [
      "p",
      "ul",
      "ul",
      "li",
      "li"
    ],
    "against": [
      "p",
      "ul",
      "li",
      "p"
    ],
    "pre-computed": [
      "p",
      "ul",
      "li"
    ],
    "hash": [
      "p",
      "p",
      "ul",
      "ul",
      "li",
      "li",
      "pre",
      "pre",
      "pre",
      "ul",
      "ul",
      "ul",
      "li",
      "li",
      "li",
      "p",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "p",
      "title"
    ],
    "dictionary": [
      "p",
      "ul",
      "li"
    ],
    "attacks": [
      "p",
      "ul",
      "li",
      "ul",
      "li",
      "p"
    ],
    "on": [
      "p",
      "ul",
      "li",
      "ul",
      "li"
    ],
    "compromised": [
      "p",
      "ul",
      "li",
      "p"
    ],
    "objectives": [
      "h1"
    ],
    "user": [
      "ul",
      "ul",
      "li",
      "li",
      "ul",
      "li",
      "pre"
    ],
    "credentials": [
      "ul",
      "li"
    ],
    "avoid": [
      "ul",
      "li"
    ],
    "storing": [
      "ul",
      "li"
    ],
    "passwords": [
      "ul",
      "li",
      "ul",
      "li",
      "p"
    ],
    "certain": [
      "ul",
      "li"
    ],
    "brute-force": [
      "ul",
      "li",
      "p"
    ],
    "generate": [
      "ul",
      "li"
    ],
    "cryptographically": [
      "ul",
      "li",
      "pre"
    ],
    "random": [
      "ul",
      "li",
      "pre",
      "title"
    ],
    "for": [
      "ul",
      "li",
      "ul",
      "li",
      "pre",
      "pre",
      "pre",
      "pre",
      "p"
    ],
    "that": [
      "ul",
      "li",
      "ul",
      "li"
    ],
    "cannot": [
      "ul",
      "li"
    ],
    "predicted": [
      "ul",
      "li"
    ],
    "enough": [
      "ul",
      "li"
    ],
    "increase": [
      "ul",
      "li"
    ],
    "difficulty": [
      "ul",
      "li"
    ],
    "cracking": [
      "ul",
      "li"
    ],
    "attempt": [
      "ul",
      "li"
    ],
    "exponentially": [
      "ul",
      "li"
    ],
    "scenarios": [
      "h1"
    ],
    "application": [
      "ul",
      "ul",
      "ul",
      "li",
      "li",
      "li"
    ],
    "makes": [
      "ul",
      "li"
    ],
    "use": [
      "ul",
      "li",
      "p",
      "p"
    ],
    "dedicated": [
      "ul",
      "li"
    ],
    "account": [
      "ul",
      "li"
    ],
    "management": [
      "ul",
      "li"
    ],
    "system": [
      "ul",
      "li"
    ],
    "stores": [
      "ul",
      "ul",
      "li",
      "li"
    ],
    "\"secret": [
      "ul",
      "li"
    ],
    "question/answer\"": [
      "ul",
      "li"
    ],
    "credential": [
      "ul",
      "li"
    ],
    "reset": [
      "ul",
      "li"
    ],
    "operations": [
      "ul",
      "li"
    ],
    "requires": [
      "ul",
      "li"
    ],
    "storage": [
      "ul",
      "li",
      "pre",
      "pre",
      "p",
      "p"
    ],
    "highly": [
      "ul",
      "li"
    ],
    "social": [
      "ul",
      "li"
    ],
    "security": [
      "ul",
      "li"
    ],
    "number": [
      "ul",
      "ul",
      "li",
      "li",
      "pre"
    ],
    "credit": [
      "ul",
      "li"
    ],
    "card": [
      "ul",
      "li"
    ],
    "etc": [
      "ul",
      "li"
    ],
    "but": [
      "ul",
      "li"
    ],
    "does": [
      "ul",
      "li"
    ],
    "not": [
      "ul",
      "li"
    ],
    "need": [
      "ul",
      "li"
    ],
    "retrieve": [
      "ul",
      "li"
    ],
    "solution": [
      "h1"
    ],
    "example": [
      "h1",
      "h1",
      "p"
    ],
    "systemsecurity.cryptography;": [
      "pre",
      "pre"
    ],
    "..": [
      "pre"
    ],
    "public": [
      "pre"
    ],
    "static": [
      "pre",
      "pre",
      "pre"
    ],
    "byte&#91&#93;": [
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "createpasswordhashstring": [
      "pre"
    ],
    "password&#123;": [
      "pre"
    ],
    "//": [
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "convert": [
      "pre",
      "pre",
      "pre"
    ],
    "string": [
      "pre",
      "pre"
    ],
    "byte": [
      "pre",
      "pre",
      "p"
    ],
    "array": [
      "pre"
    ],
    "passworddata": [
      "pre",
      "pre",
      "pre"
    ],
    "=": [
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "unicodeencodingascii.getbytes(password);": [
      "pre",
      "pre"
    ],
    "create": [
      "pre",
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "4-byte": [
      "pre"
    ],
    "generator": [
      "pre"
    ],
    "saltdata": [
      "pre",
      "pre",
      "pre"
    ],
    "new": [
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "byte&#914&#93;;": [
      "pre",
      "pre"
    ],
    "rngcryptoserviceprovider": [
      "pre"
    ],
    "rng": [
      "pre"
    ],
    "rngcryptoserviceprovider);": [
      "pre"
    ],
    "rnggetnonzerobytes(saltdata);": [
      "pre"
    ],
    "append": [
      "pre",
      "pre"
    ],
    "end": [
      "pre",
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "saltedpassworddata": [
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "byte&#91passworddata.length": [
      "pre",
      "pre"
    ],
    "&#43": [
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "saltdatalength&#93;;": [
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "arraycopy(passworddata,": [
      "pre",
      "pre"
    ],
    "passworddatalength);": [
      "pre",
      "pre"
    ],
    "arraycopy(saltdata,": [
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "passworddatalength,": [
      "pre",
      "pre"
    ],
    "saltdatalength);": [
      "pre",
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "sha-1": [
      "pre",
      "ul",
      "li",
      "pre"
    ],
    "instance": [
      "pre",
      "pre",
      "pre"
    ],
    "compute": [
      "pre",
      "pre",
      "pre"
    ],
    "sha1managed": [
      "pre",
      "pre"
    ],
    "sha": [
      "pre",
      "pre"
    ],
    "sha1managed);": [
      "pre",
      "pre"
    ],
    "hashdata": [
      "pre",
      "pre",
      "pre"
    ],
    "shacomputehash(saltedpassworddata);": [
      "pre",
      "pre"
    ],
    "optional": [
      "pre"
    ],
    "-": [
      "pre",
      "pre"
    ],
    "bytes": [
      "pre",
      "pre",
      "pre"
    ],
    "onto": [
      "pre",
      "pre"
    ],
    "bool": [
      "pre",
      "pre"
    ],
    "append_salt_to_hash": [
      "pre"
    ],
    "true": [
      "pre"
    ],
    "if": [
      "pre"
    ],
    "append_salt_to_hash)": [
      "pre"
    ],
    "&#123": [
      "pre",
      "pre"
    ],
    "&#9byte&#91;&#93;": [
      "pre"
    ],
    "hashsaltdata": [
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "byte&#91hashdata.length": [
      "pre"
    ],
    "arraycopy(hashdata,": [
      "pre",
      "pre"
    ],
    "hashdatalength);": [
      "pre"
    ],
    "hashdatalength,": [
      "pre"
    ],
    "return": [
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "&#125": [
      "pre"
    ],
    "else": [
      "pre"
    ],
    "&#125&#125;": [
      "pre"
    ],
    "problem": [
      "h1"
    ],
    "following": [
      "p",
      "p",
      "p"
    ],
    "shows": [
      "p"
    ],
    "without": [
      "p"
    ],
    "weaker": [
      "p"
    ],
    "obtained": [
      "pre"
    ],
    "from": [
      "pre",
      "p",
      "p"
    ],
    "as": [
      "pre"
    ],
    "stringstring": [
      "pre"
    ],
    "requestform&#91;\"password\"&#93;;//": [
      "pre"
    ],
    "arraybyte&#91&#93;": [
      "pre"
    ],
    "unicodeencodingascii.getbytes(password);//": [
      "pre"
    ],
    "md5": [
      "pre",
      "pre",
      "ul",
      "li"
    ],
    "md5cryptoserviceprovider": [
      "pre"
    ],
    "md5cryptoserviceprovider);byte&#91;&#93;": [
      "pre"
    ],
    "md5computehash(passworddata);": [
      "pre"
    ],
    "vulnerable": [
      "ul",
      "ul",
      "li",
      "li"
    ],
    "depending": [
      "ul",
      "li"
    ],
    "may": [
      "ul",
      "li",
      "p"
    ],
    "also": [
      "ul",
      "li"
    ],
    "attack": [
      "ul",
      "li"
    ],
    "offers": [
      "ul",
      "li"
    ],
    "less": [
      "ul",
      "li"
    ],
    "strengtgh": [
      "ul",
      "li"
    ],
    "than": [
      "ul",
      "li"
    ],
    "has": [
      "ul",
      "li"
    ],
    "recently": [
      "ul",
      "li"
    ],
    "been": [
      "ul",
      "li"
    ],
    "\"broken\"": [
      "ul",
      "li"
    ],
    "by": [
      "ul",
      "li",
      "p"
    ],
    "cryptography": [
      "ul",
      "li"
    ],
    "researchers": [
      "ul",
      "li"
    ],
    "test": [
      "h1",
      "p",
      "p"
    ],
    "case": [
      "h1",
      "p"
    ],
    "classes": [
      "p"
    ],
    "must": [
      "p"
    ],
    "included": [
      "p"
    ],
    "any": [
      "p"
    ],
    "project": [
      "p"
    ],
    "making": [
      "p"
    ],
    "sample": [
      "p"
    ],
    "provided": [
      "p"
    ],
    "above": [
      "p"
    ],
    "execute": [
      "p"
    ],
    "comparison": [
      "p"
    ],
    "salted": [
      "p",
      "pre",
      "pre"
    ],
    "methods": [
      "p"
    ],
    "void": [
      "pre"
    ],
    "mainstring&#91;&#93;": [
      "pre"
    ],
    "args&#123;": [
      "pre"
    ],
    "compare": [
      "pre",
      "pre"
    ],
    "two": [
      "pre"
    ],
    "subsequent": [
      "pre"
    ],
    "hashes": [
      "pre",
      "p",
      "p"
    ],
    "createpasswordhash\"foobar\");": [
      "pre"
    ],
    "consolewriteline(\"\\ncreated": [
      "pre"
    ],
    "'foobar'\";": [
      "pre"
    ],
    "consolewriteline(\"foobar": [
      "pre"
    ],
    "produces": [
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "same": [
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "hash\\t\"": [
      "pre",
      "pre"
    ],
    "&#9&#9;comparepasswordtohash(\"foobar\",": [
      "pre"
    ],
    "hash.tostring());": [
      "pre"
    ],
    "consolewriteline(\"fo0bar": [
      "pre"
    ],
    "&#9&#9;comparepasswordtohash(\"f0obar\",": [
      "pre"
    ],
    "hash.tostring());&#125;public": [
      "pre"
    ],
    "comparepasswordtohashstring": [
      "pre"
    ],
    "hashdata&#123;": [
      "pre"
    ],
    "first": [
      "pre"
    ],
    "pluck": [
      "pre"
    ],
    "four-byte": [
      "pre",
      "p",
      "p"
    ],
    "off": [
      "pre"
    ],
    "hashdatalength": [
      "pre"
    ],
    "saltdatalength,": [
      "pre"
    ],
    "newhashdata": [
      "pre"
    ],
    "newhashsaltdata": [
      "pre",
      "pre",
      "pre"
    ],
    "byte&#91newhashdata.length": [
      "pre"
    ],
    "arraycopy(newhashdata,": [
      "pre"
    ],
    "newhashdatalength);": [
      "pre"
    ],
    "newhashdatalength,": [
      "pre"
    ],
    "convert.tobase64string(hashdata).equals(convert.tobase64string(newhashsaltdata)));&#125;": [
      "pre"
    ],
    "expected": [
      "h1"
    ],
    "result": [
      "h1"
    ],
    "created": [
      "pre"
    ],
    "'foobar'foobar": [
      "pre"
    ],
    "truefo0bar": [
      "pre"
    ],
    "false": [
      "pre"
    ],
    "more": [
      "h1"
    ],
    "information": [
      "h1"
    ],
    "should": [
      "p"
    ],
    "always": [
      "p"
    ],
    "securely": [
      "p"
    ],
    "protected": [
      "p"
    ],
    "an": [
      "p",
      "p"
    ],
    "attacker": [
      "p",
      "p",
      "p"
    ],
    "able": [
      "p"
    ],
    "compromise": [
      "p"
    ],
    "specific": [
      "p"
    ],
    "database": [
      "p",
      "p"
    ],
    "succeed": [
      "p"
    ],
    "other": [
      "p",
      "p"
    ],
    "types": [
      "p"
    ],
    "given": [
      "p",
      "p"
    ],
    "would": [
      "p",
      "p",
      "p"
    ],
    "require": [
      "p",
      "p",
      "p"
    ],
    "maintain": [
      "p"
    ],
    "trillion": [
      "p"
    ],
    "every": [
      "p"
    ],
    "plaintext": [
      "p"
    ],
    "assuming": [
      "p",
      "p"
    ],
    "victim": [
      "p"
    ],
    "required": [
      "p",
      "p"
    ],
    "only": [
      "p",
      "p"
    ],
    "alphabetical": [
      "p"
    ],
    "characters": [
      "p"
    ],
    "length": [
      "p"
    ],
    "no": [
      "p"
    ],
    "complexity": [
      "p"
    ],
    "requirements": [
      "p"
    ],
    "very": [
      "p"
    ],
    "weak": [
      "p"
    ],
    "policy": [
      "p"
    ],
    "our": [
      "p"
    ],
    "standards,": [
      "p"
    ],
    "defeating": [
      "p"
    ],
    "have": [
      "p"
    ],
    "x": [
      "p"
    ],
    "10&#9415": [
      "p"
    ],
    "precomputed": [
      "p"
    ],
    "handy": [
      "p"
    ],
    "each": [
      "p"
    ],
    "these": [
      "p"
    ],
    "one": [
      "p"
    ],
    "petabytes": [
      "p"
    ],
    "adapted": [
      "p"
    ],
    "microsoft": [
      "p"
    ],
    "patterns": [
      "p"
    ],
    "&": [
      "p"
    ],
    "practices": [
      "p"
    ],
    "guidance": [
      "p"
    ],
    "sink]": [
      "title"
    ]
  },
  "tags": {
    "h1": [
      "Applies to",
      "Summary",
      "Objectives",
      "Scenarios",
      "Solution Example",
      "Problem Example",
      "Test Case",
      "Expected Result",
      "More Information"
    ],
    "ul": [
      "C#",
      "Protect user credentials Avoid storing user passwords Protect against certain brute-force attacks on a compromised hash value Generate a cryptographically random value for the salt that cannot be predicted Add enough entropy to the password hash to increase the difficulty of a cracking attempt exponentially",
      "Application makes use of a dedicated user account management system and stores passwords Application stores a \"Secret Question/Answer\" credential for password reset operations Application requires storage of highly sensitive data (social security number, credit card number, etc) but does not need to retrieve that data.",
      "Hash values are vulnerable to pre-computed hash attacks Depending on password value, password hash may also be vulnerable to a dictionary attack MD5 offers less encryption strengtgh than SHA-1 and has recently been \"broken\" by cryptography researchers"
    ],
    "li": [
      "C#",
      "Protect user credentials",
      "Avoid storing user passwords",
      "Protect against certain brute-force attacks on a compromised hash value",
      "Generate a cryptographically random value for the salt that cannot be predicted",
      "Add enough entropy to the password hash to increase the difficulty of a cracking attempt exponentially",
      "Application makes use of a dedicated user account management system and stores passwords",
      "Application stores a \"Secret Question/Answer\" credential for password reset operations",
      "Application requires storage of highly sensitive data (social security number, credit card number, etc) but does not need to retrieve that data.",
      "Hash values are vulnerable to pre-computed hash attacks",
      "Depending on password value, password hash may also be vulnerable to a dictionary attack",
      "MD5 offers less encryption strengtgh than SHA-1 and has recently been \"broken\" by cryptography researchers"
    ],
    "p": [
      "The purpose of this code snippet is to demonstrate how to implement secure password persistence using a cryptographic hashing algorithm with a randomly generated \"salt\" (or \"nonce\") value. Cryptographic hashing algorithms are one-way encryption algorithms used to store sensitive data in a non-readable format. A salt can be used in conjunction with cryptographic hashing to add additional entropy to encrypted values and to protect against pre-computed hash or dictionary attacks on a compromised hash value.",
      "The following code snippet shows password hashing without the use of a salt and using a weaker hashing algorithm.",
      "The following classes must be included in any project making use of the sample code provided above:",
      "Execute a test encryption and comparison of a salted password hash using the following test case methods:",
      "Password hash and salt values should always be securely protected in storage. An attacker able to compromise a specific hash and salt value from a database may succeed in using other types of brute-force attacks against the compromised hash. In the example given, the four-byte salt would require an attacker to maintain 4.3 trillion values for every given plaintext value. Assuming the victim required passwords of only 4 alphabetical characters in length with no other complexity requirements (a very weak password policy by our standards), defeating a four-byte salt would require the attacker to have a database of 2 x 10&#94;15 precomputed hashes handy. Assuming each of these hashes only required one byte to store, this would require 2 petabytes of storage.",
      "Adapted from Microsoft patterns & practices guidance."
    ],
    "pre": [
      "using System.Security.Cryptography;",
      "...",
      "public static byte&#91;&#93; CreatePasswordHash(string password)&#123;    // Convert the string password value to a byte array    byte&#91;&#93; passwordData = UnicodeEncoding.ASCII.GetBytes(password);    // Create a 4-byte salt using a cryptographically secure random number generator    byte&#91;&#93; saltData = new byte&#91;4&#93;;    RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();    rng.GetNonZeroBytes(saltData);     // Append the salt to the end of the password    byte&#91;&#93; saltedPasswordData = new byte&#91;passwordData.Length &#43; saltData.Length&#93;;    Array.Copy(passwordData, 0, saltedPasswordData, 0, passwordData.Length);    Array.Copy(saltData, 0, saltedPasswordData, passwordData.Length, saltData.Length);    // Create a new SHA-1 instance and compute the hash     SHA1Managed sha = new SHA1Managed();    byte&#91;&#93; hashData = sha.ComputeHash(saltedPasswordData);    // Optional - add salt bytes onto end of the password hash for storage    bool APPEND_SALT_TO_HASH = true;    if (APPEND_SALT_TO_HASH)    &#123;     &#9;byte&#91;&#93; hashSaltData = new byte&#91;hashData.Length &#43; saltData.Length&#93;;        Array.Copy(hashData, 0, hashSaltData, 0, hashData.Length);        Array.Copy(saltData, 0, hashSaltData, hashData.Length, saltData.Length);        return hashSaltData;    &#125;    else    &#123;        return hashData;    &#125;&#125;",
      "// password is obtained from the user as a C# stringstring password = Request.Form&#91;\"password\"&#93;;// Convert the string password value to a byte arraybyte&#91;&#93; passwordData = UnicodeEncoding.ASCII.GetBytes(password);// Create a new MD5 instance and compute the hash MD5CryptoServiceProvider md5 = new MD5CryptoServiceProvider();byte&#91;&#93; hashData = md5.ComputeHash(passwordData);",
      "using System.Security.Cryptography;",
      "static void Main(string&#91;&#93; args)&#123;    // Create a Hash and compare to two subsequent hashes    byte&#91;&#93; hash = CreatePasswordHash(\"foobar\");    Console.WriteLine(\"\\nCreated new salted hash for 'foobar'\");    Console.WriteLine(\"foobar produces same hash:\\t\" &#43; &#9;&#9;ComparePasswordToHash(\"foobar\", hash).ToString());    Console.WriteLine(\"fo0bar produces same hash:\\t\" &#43; &#9;&#9;ComparePasswordToHash(\"f0obar\", hash).ToString());&#125;public static bool ComparePasswordToHash(string password, byte&#91;&#93; hashData)&#123;    // First, pluck the four-byte salt off of the end of the hash    byte&#91;&#93; saltData = new byte&#91;4&#93;;    Array.Copy(hashData, hashData.Length - saltData.Length, saltData, 0, saltData.Length);    // Convert Password to bytes    byte&#91;&#93; passwordData = UnicodeEncoding.ASCII.GetBytes(password);    // Append the salt to the end of the password    byte&#91;&#93; saltedPasswordData = new byte&#91;passwordData.Length &#43; saltData.Length&#93;;    Array.Copy(passwordData, 0, saltedPasswordData, 0, passwordData.Length);    Array.Copy(saltData, 0, saltedPasswordData, passwordData.Length, saltData.Length);    // Create a new SHA-1 instance and compute the hash     SHA1Managed sha = new SHA1Managed();    byte&#91;&#93; newHashData = sha.ComputeHash(saltedPasswordData);    // Add salt bytes onto end of the password hash for storage    byte&#91;&#93; newHashSaltData = new byte&#91;newHashData.Length &#43; saltData.Length&#93;;    Array.Copy(newHashData, 0, newHashSaltData, 0, newHashData.Length);    Array.Copy(saltData, 0, newHashSaltData, newHashData.Length, saltData.Length);    // Compare and return    return (Convert.ToBase64String(hashData).Equals(Convert.ToBase64String(newHashSaltData)));&#125;",
      "Created new salted hash for 'foobar'foobar produces same hash:      Truefo0bar produces same hash:      False"
    ],
    "br": [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
    ],
    "hr": [
      ""
    ]
  },
  "links": [],
  "html": "<h1>Applies to</h1>\n  <ul>\n    <li>C#</li>\n  </ul>\n  <h1>Summary</h1>\n  <p>The purpose of this code snippet is to demonstrate how to implement secure password persistence using a cryptographic hashing algorithm with a randomly generated \"salt\" (or \"nonce\") value. Cryptographic hashing algorithms are one-way encryption algorithms used to store sensitive data in a non-readable format. A salt can be used in conjunction with cryptographic hashing to add additional entropy to encrypted values and to protect against pre-computed hash or dictionary attacks on a compromised hash value.</p>\n  <h1>Objectives</h1>\n  <ul>\n    <li>Protect user credentials <li>Avoid storing user passwords <li>Protect against certain brute-force attacks on a compromised hash value <li>Generate a cryptographically random value for the salt that cannot be predicted <li>Add enough entropy to the password hash to increase the difficulty of a cracking attempt exponentially</li></li></li></li></li>\n  </ul>\n  <h1>Scenarios</h1>\n  <ul>\n    <li>Application makes use of a dedicated user account management system and stores passwords <li>Application stores a \"Secret Question/Answer\" credential for password reset operations <li>Application requires storage of highly sensitive data (social security number, credit card number, etc) but does not need to retrieve that data.</li></li></li>\n  </ul>\n  <h1>Solution Example</h1>\n  <pre>using System.Security.Cryptography;</pre>\n  <pre>...</pre>\n  <pre>public static byte&amp;#91;&amp;#93; CreatePasswordHash(string password)&amp;#123;<br />    // Convert the string password value to a byte array<br />    byte&amp;#91;&amp;#93; passwordData = UnicodeEncoding.ASCII.GetBytes(password);<br />    // Create a 4-byte salt using a cryptographically secure random number generator<br />    byte&amp;#91;&amp;#93; saltData = new byte&amp;#91;4&amp;#93;;<br />    RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();<br />    rng.GetNonZeroBytes(saltData);<br />     // Append the salt to the end of the password<br />    byte&amp;#91;&amp;#93; saltedPasswordData = new byte&amp;#91;passwordData.Length &amp;#43; saltData.Length&amp;#93;;<br />    Array.Copy(passwordData, 0, saltedPasswordData, 0, passwordData.Length);<br />    Array.Copy(saltData, 0, saltedPasswordData, passwordData.Length, saltData.Length);<br />    // Create a new SHA-1 instance and compute the hash <br />    SHA1Managed sha = new SHA1Managed();<br />    byte&amp;#91;&amp;#93; hashData = sha.ComputeHash(saltedPasswordData);<br />    // Optional - add salt bytes onto end of the password hash for storage<br />    bool APPEND_SALT_TO_HASH = true;    if (APPEND_SALT_TO_HASH)<br />    &amp;#123;<br />     &amp;#9;byte&amp;#91;&amp;#93; hashSaltData = new byte&amp;#91;hashData.Length &amp;#43; saltData.Length&amp;#93;;<br />        Array.Copy(hashData, 0, hashSaltData, 0, hashData.Length);<br />        Array.Copy(saltData, 0, hashSaltData, hashData.Length, saltData.Length);<br />        return hashSaltData;<br />    &amp;#125;<br />    else<br />    &amp;#123;<br />        return hashData;<br />    &amp;#125;<br />&amp;#125;</pre>\n  <h1>Problem Example</h1>\n  <p>The following code snippet shows password hashing without the use of a salt and using a weaker hashing algorithm.</p>\n  <pre>// password is obtained from the user as a C# string<br />string password = Request.Form&amp;#91;\"password\"&amp;#93;;<br />// Convert the string password value to a byte<br /> arraybyte&amp;#91;&amp;#93; passwordData = UnicodeEncoding.ASCII.GetBytes(password);<br />// Create a new MD5 instance and compute the hash<br /> MD5CryptoServiceProvider md5 = new MD5CryptoServiceProvider();<br />byte&amp;#91;&amp;#93; hashData = md5.ComputeHash(passwordData);</pre>\n  <ul>\n    <li>Hash values are vulnerable to pre-computed hash attacks <li>Depending on password value, password hash may also be vulnerable to a dictionary attack <li>MD5 offers less encryption strengtgh than SHA-1 and has recently been \"broken\" by cryptography researchers</li></li></li>\n  </ul>\n  <h1>Test Case</h1>\n  <p>The following classes must be included in any project making use of the sample code provided above:</p>\n  <pre>using System.Security.Cryptography;</pre>\n  <p>Execute a test encryption and comparison of a salted password hash using the following test case methods:</p>\n  <pre>static void Main(string&amp;#91;&amp;#93; args)<br />&amp;#123;<br />    // Create a Hash and compare to two subsequent hashes<br />    byte&amp;#91;&amp;#93; hash = CreatePasswordHash(\"foobar\");<br />    Console.WriteLine(\"\\nCreated new salted hash for 'foobar'\");<br />    Console.WriteLine(\"foobar produces same hash:\\t\" &amp;#43; <br />&amp;#9;&amp;#9;ComparePasswordToHash(\"foobar\", hash).ToString());<br />    Console.WriteLine(\"fo0bar produces same hash:\\t\" &amp;#43; <br />&amp;#9;&amp;#9;ComparePasswordToHash(\"f0obar\", hash).ToString());<br />&amp;#125;<br />public static bool ComparePasswordToHash(string password, byte&amp;#91;&amp;#93; hashData)<br />&amp;#123;<br />    // First, pluck the four-byte salt off of the end of the hash<br />    byte&amp;#91;&amp;#93; saltData = new byte&amp;#91;4&amp;#93;;<br />    Array.Copy(hashData, hashData.Length - saltData.Length, saltData, 0, saltData.Length);<br />    // Convert Password to bytes<br />    byte&amp;#91;&amp;#93; passwordData = UnicodeEncoding.ASCII.GetBytes(password);<br />    // Append the salt to the end of the password<br />    byte&amp;#91;&amp;#93; saltedPasswordData = new byte&amp;#91;passwordData.Length &amp;#43; saltData.Length&amp;#93;;<br />    Array.Copy(passwordData, 0, saltedPasswordData, 0, passwordData.Length);<br />    Array.Copy(saltData, 0, saltedPasswordData, passwordData.Length, saltData.Length);<br />    // Create a new SHA-1 instance and compute the hash<br />     SHA1Managed sha = new SHA1Managed();<br />    byte&amp;#91;&amp;#93; newHashData = sha.ComputeHash(saltedPasswordData);<br />    // Add salt bytes onto end of the password hash for storage<br />    byte&amp;#91;&amp;#93; newHashSaltData = new byte&amp;#91;newHashData.Length &amp;#43; saltData.Length&amp;#93;;<br />    Array.Copy(newHashData, 0, newHashSaltData, 0, newHashData.Length);<br />    Array.Copy(saltData, 0, newHashSaltData, newHashData.Length, saltData.Length);<br />    // Compare and return<br />    return (Convert.ToBase64String(hashData).Equals(Convert.ToBase64String(newHashSaltData)));<br />&amp;#125;</pre>\n  <h1>Expected Result</h1>\n  <pre>Created new salted hash for 'foobar'foobar produces same hash:      True<br />fo0bar produces same hash:      False</pre>\n  <h1>More Information</h1>\n  <p>Password hash and salt values should always be securely protected in storage. An attacker able to compromise a specific hash and salt value from a database may succeed in using other types of brute-force attacks against the compromised hash. In the example given, the four-byte salt would require an attacker to maintain 4.3 trillion values for every given plaintext value. Assuming the victim required passwords of only 4 alphabetical characters in length with no other complexity requirements (a very weak password policy by our standards), defeating a four-byte salt would require the attacker to have a database of 2 x 10&amp;#94;15 precomputed hashes handy. Assuming each of these hashes only required one byte to store, this would require 2 petabytes of storage. </p>\n  <hr />\n  <p>Adapted from Microsoft patterns &amp; practices guidance.</p>"
}