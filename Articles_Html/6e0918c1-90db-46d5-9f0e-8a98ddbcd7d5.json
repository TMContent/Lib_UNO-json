{
  "id": "6e0918c1-90db-46d5-9f0e-8a98ddbcd7d5",
  "checksum": "23a47d1b884c6f6f1ad6c7d64b83ca386def529c",
  "words": {
    "applies": [
      "h2",
      "p"
    ],
    "to": [
      "h2",
      "h2",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "p",
      "pre"
    ],
    "java": [
      "ul",
      "li"
    ],
    "what": [
      "h2"
    ],
    "do": [
      "h2",
      "ol",
      "li"
    ],
    "use": [
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li",
      "p"
    ],
    "iterative": [
      "p",
      "p",
      "p",
      "p"
    ],
    "hashing": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "protect": [
      "p"
    ],
    "stored": [
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p"
    ],
    "passwords": [
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "title"
    ],
    "why": [
      "h2"
    ],
    "storing": [
      "p",
      "p",
      "ol",
      "li"
    ],
    "hashes": [
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "li",
      "li",
      "p"
    ],
    "instead": [
      "p"
    ],
    "of": [
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li"
    ],
    "plain-text": [
      "p"
    ],
    "assures": [
      "p"
    ],
    "that": [
      "p",
      "ol",
      "li"
    ],
    "an": [
      "p"
    ],
    "attacker": [
      "p"
    ],
    "cannot": [
      "p",
      "ol",
      "li"
    ],
    "easily": [
      "p"
    ],
    "recover": [
      "p"
    ],
    "the": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "strong",
      "strong",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "strong",
      "strong",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "ul",
      "li"
    ],
    "if": [
      "p",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li"
    ],
    "he": [
      "p"
    ],
    "gains": [
      "p"
    ],
    "access": [
      "p"
    ],
    "password": [
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "strong",
      "li",
      "li",
      "li",
      "li",
      "strong",
      "li",
      "li",
      "li",
      "li",
      "strong",
      "p",
      "p",
      "p"
    ],
    "files": [
      "p",
      "p",
      "ol",
      "li"
    ],
    "adding": [
      "p"
    ],
    "salt": [
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "strong",
      "li",
      "li",
      "strong",
      "li",
      "li",
      "li",
      "strong",
      "li",
      "li",
      "p",
      "pre",
      "pre",
      "pre"
    ],
    "hashed": [
      "p",
      "ol",
      "li",
      "p"
    ],
    "makes": [
      "p"
    ],
    "much": [
      "p"
    ],
    "harder": [
      "p"
    ],
    "break": [
      "p"
    ],
    "with": [
      "p",
      "ol",
      "ol",
      "li",
      "li"
    ],
    "dictionary": [
      "p",
      "p",
      "ol",
      "li"
    ],
    "attacks": [
      "p",
      "p",
      "ol",
      "li"
    ],
    "should": [
      "p",
      "ol",
      "li"
    ],
    "be": [
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li"
    ],
    "applied": [
      "p"
    ],
    "multiple": [
      "p",
      "p",
      "ol",
      "ol",
      "li",
      "li",
      "strong"
    ],
    "times": [
      "p",
      "p"
    ],
    "make": [
      "p"
    ],
    "take": [
      "p"
    ],
    "longer": [
      "p"
    ],
    "and": [
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li",
      "strong",
      "li",
      "li",
      "strong",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "ul",
      "li"
    ],
    "thus": [
      "p"
    ],
    "increase": [
      "p"
    ],
    "computational": [
      "p",
      "ol",
      "li"
    ],
    "resources": [
      "p",
      "h2"
    ],
    "required": [
      "p",
      "p",
      "ol",
      "li"
    ],
    "attack": [
      "p"
    ],
    "a": [
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "strong",
      "li",
      "p",
      "p"
    ],
    "function": [
      "p"
    ],
    "drastically": [
      "p"
    ],
    "increasing": [
      "p"
    ],
    "time": [
      "p"
    ],
    "perform": [
      "p"
    ],
    "when": [
      "h2",
      "p",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "p"
    ],
    "how": [
      "h2",
      "p"
    ],
    "following": [
      "p",
      "p"
    ],
    "steps": [
      "p"
    ],
    "show": [
      "p"
    ],
    "define": [
      "ol",
      "li",
      "strong"
    ],
    "storage": [
      "ol",
      "ol",
      "li",
      "strong",
      "li"
    ],
    "requirements": [
      "ol",
      "ol",
      "li",
      "strong",
      "li"
    ],
    "most": [
      "ol",
      "li"
    ],
    "applications": [
      "ol",
      "li"
    ],
    "database": [
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "p",
      "p"
    ],
    "back-end": [
      "ol",
      "li"
    ],
    "store": [
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "strong",
      "p",
      "p",
      "title"
    ],
    "in": [
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p"
    ],
    "table": [
      "ol",
      "ol",
      "li",
      "li"
    ],
    "another": [
      "ol",
      "li"
    ],
    "option": [
      "ol",
      "li"
    ],
    "is": [
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p"
    ],
    "your": [
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li"
    ],
    "application": [
      "ol",
      "li"
    ],
    "implements": [
      "ol",
      "li"
    ],
    "policy": [
      "ol",
      "li"
    ],
    "preventing": [
      "ol",
      "li"
    ],
    "users": [
      "ol",
      "li"
    ],
    "from": [
      "ol",
      "ol",
      "li",
      "li",
      "pre"
    ],
    "entering": [
      "ol",
      "li"
    ],
    "previously": [
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li"
    ],
    "used": [
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li"
    ],
    "then": [
      "ol",
      "li",
      "p"
    ],
    "salted": [
      "ol",
      "li"
    ],
    "have": [
      "ol",
      "ol",
      "li",
      "li"
    ],
    "also": [
      "ol",
      "li"
    ],
    "amount": [
      "ol",
      "ol",
      "li",
      "li"
    ],
    "configurable": [
      "ol",
      "li"
    ],
    "it": [
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p"
    ],
    "recommended": [
      "ol",
      "ol",
      "li",
      "li"
    ],
    "separate": [
      "ol",
      "li"
    ],
    "or": [
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "p",
      "p"
    ],
    "file": [
      "ol",
      "ol",
      "li",
      "li"
    ],
    "salts": [
      "ol",
      "li"
    ],
    "generate": [
      "ol",
      "ol",
      "li",
      "li",
      "strong"
    ],
    "random": [
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "strong"
    ],
    "value": [
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "strong",
      "li",
      "li",
      "li",
      "li"
    ],
    "each": [
      "ol",
      "li"
    ],
    "bit": [
      "ol",
      "li"
    ],
    "doubles": [
      "ol",
      "li"
    ],
    "memory": [
      "ol",
      "li"
    ],
    "for": [
      "ol",
      "li",
      "ul",
      "li"
    ],
    "lengths": [
      "ol",
      "li"
    ],
    "are": [
      "ol",
      "li"
    ],
    "64-bit": [
      "ol",
      "li"
    ],
    "more": [
      "ol",
      "li",
      "ul",
      "li"
    ],
    "number": [
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li"
    ],
    "generator": [
      "ol",
      "li"
    ],
    "choice": [
      "ol",
      "li"
    ],
    "size": [
      "ol",
      "li"
    ],
    "this": [
      "ol",
      "ol",
      "li",
      "li"
    ],
    "as": [
      "ol",
      "ol",
      "li",
      "li"
    ],
    "hash": [
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "strong",
      "li",
      "li",
      "li",
      "strong",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p"
    ],
    "using": [
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "strong",
      "li",
      "p"
    ],
    "iterations": [
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "strong",
      "pre",
      "pre"
    ],
    "secretkeyfactory": [
      "ol",
      "li",
      "tt",
      "ul",
      "li"
    ],
    "api": [
      "ol",
      "li",
      "tt",
      "ul",
      "li"
    ],
    "pbkdf2withhmacsha256": [
      "ol",
      "li",
      "tt"
    ],
    "algorithm": [
      "ol",
      "li",
      "pre"
    ],
    "has": [
      "ol",
      "ol",
      "li",
      "li"
    ],
    "same": [
      "ol",
      "ol",
      "li",
      "li"
    ],
    "checking": [
      "ol",
      "li"
    ],
    "during": [
      "ol",
      "ol",
      "li",
      "li"
    ],
    "authentication": [
      "ol",
      "ol",
      "li",
      "li"
    ],
    "choosing": [
      "ol",
      "li"
    ],
    "important": [
      "ol",
      "li"
    ],
    "both": [
      "ol",
      "li"
    ],
    "because": [
      "ol",
      "li"
    ],
    "will": [
      "ol",
      "li"
    ],
    "comparing": [
      "ol",
      "li"
    ],
    "user": [
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "pre"
    ],
    "entered": [
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li"
    ],
    "implement": [
      "ol",
      "li",
      "strong"
    ],
    "verification": [
      "ol",
      "li",
      "strong"
    ],
    "by": [
      "ol",
      "li"
    ],
    "checked": [
      "ol",
      "li"
    ],
    "against": [
      "ol",
      "ol",
      "li",
      "li",
      "p"
    ],
    "calculated": [
      "ol",
      "li",
      "p"
    ],
    "pbkdf2": [
      "ol",
      "ol",
      "li",
      "li",
      "p"
    ],
    "retrieve": [
      "ol",
      "li"
    ],
    "calculate": [
      "ol",
      "li"
    ],
    "based": [
      "ol",
      "li",
      "p"
    ],
    "on": [
      "ol",
      "li",
      "p",
      "p"
    ],
    "input": [
      "ol",
      "li"
    ],
    "compare": [
      "ol",
      "li"
    ],
    "resulting": [
      "ol",
      "ol",
      "li",
      "li"
    ],
    "string": [
      "ol",
      "li",
      "pre"
    ],
    "correct": [
      "ol",
      "li"
    ],
    "note": [
      "p",
      "strong"
    ],
    "never": [
      "p"
    ],
    "credentials": [
      "p",
      "p"
    ],
    "their": [
      "p",
      "p"
    ],
    "client": [
      "p"
    ],
    "side": [
      "p"
    ],
    "e.g.": [
      "p"
    ],
    "cookies": [
      "p"
    ],
    "hidden": [
      "p"
    ],
    "fields": [
      "p"
    ],
    "etc).": [
      "p"
    ],
    "sessions": [
      "p"
    ],
    "there": [
      "p"
    ],
    "need": [
      "p"
    ],
    "track": [
      "p"
    ],
    "solution": [
      "h2"
    ],
    "example": [
      "h2"
    ],
    "code": [
      "p"
    ],
    "validates": [
      "p"
    ],
    "given": [
      "p"
    ],
    "username": [
      "p",
      "p"
    ],
    "compares": [
      "p"
    ],
    "produced": [
      "p"
    ],
    "backend": [
      "p"
    ],
    "therefore": [
      "p"
    ],
    "not": [
      "p"
    ],
    "public": [
      "pre"
    ],
    "boolean": [
      "pre"
    ],
    "validateuserstring": [
      "pre"
    ],
    "char]": [
      "pre"
    ],
    "pass\n\t\n{\n\ttry": [
      "pre"
    ],
    "{\t\t...\n\t\tbyte[]": [
      "pre"
    ],
    "storedpasshash\n\t\tbyte[]": [
      "pre"
    ],
    "salt\n\t\t//": [
      "pre"
    ],
    "set": [
      "pre"
    ],
    "storedpasshash": [
      "pre"
    ],
    "values": [
      "pre"
    ],
    "database\t\tbyte[]": [
      "pre"
    ],
    "passhash": [
      "pre"
    ],
    "=": [
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "hashcredentialspass,": [
      "pre"
    ],
    "salt;\n\t\treturn": [
      "pre"
    ],
    "arraysequals(passhash,": [
      "pre"
    ],
    "storedpasshash;\n\t}": [
      "pre"
    ],
    "catch": [
      "pre",
      "pre"
    ],
    "nosuchalgorithmexception": [
      "pre",
      "pre"
    ],
    "nsae": [
      "pre"
    ],
    "{\t\t//": [
      "pre",
      "pre"
    ],
    "add": [
      "pre",
      "pre"
    ],
    "appropriate": [
      "pre",
      "pre"
    ],
    "logging": [
      "pre",
      "pre"
    ],
    "exception": [
      "pre",
      "pre"
    ],
    "handling": [
      "pre",
      "pre"
    ],
    "mechanisms\t\treturn": [
      "pre",
      "pre"
    ],
    "false\n\t}": [
      "pre"
    ],
    "invalidkeyspecexception": [
      "pre"
    ],
    "ikse": [
      "pre"
    ],
    "false\n\t}\n}\n\npublic": [
      "pre"
    ],
    "hashcredentialschar[]": [
      "pre"
    ],
    "pass": [
      "pre"
    ],
    "byte]": [
      "pre"
    ],
    "throws": [
      "pre"
    ],
    "invalidkeyspecexception{\n\tstring": [
      "pre"
    ],
    "“pbkdf2withhmacsha1”\n\tint": [
      "pre"
    ],
    "derivedkeylength": [
      "pre"
    ],
    "160\n\tint": [
      "pre"
    ],
    "10000\n\n\tkeyspec": [
      "pre"
    ],
    "spec": [
      "pre"
    ],
    "newpbekeyspecpass,": [
      "pre"
    ],
    "derivedkeylength;\n\tsecreykeyfactory": [
      "pre"
    ],
    "skf": [
      "pre"
    ],
    "secreykeyfactorygetinstance(algorithm);\n\n\treturn": [
      "pre"
    ],
    "skfgeneratesecret(spec).getencoded();\n}": [
      "pre"
    ],
    "additional": [
      "h2"
    ],
    "information": [
      "ul",
      "li"
    ],
    "about": [
      "ul",
      "li"
    ],
    "pbkdf2withhmacsha1": [
      "ul",
      "li"
    ],
    "see": [
      "ul",
      "li"
    ],
    "http//docs.oracle.com/javase/7/docs/technotes/guides/security/standardnames.html#secreykeyfactory": [
      "ul",
      "li",
      "a"
    ],
    "securely": [
      "title"
    ]
  },
  "tags": {
    "h2": [
      "Applies To",
      "What to Do",
      "Why",
      "When",
      "How",
      "Solution Example",
      "Additional Resources"
    ],
    "ul": [
      "Java",
      "For more information about the SecretKeyFactory API and PBKDF2WithHmacSHA1, see http://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#SecreyKeyFactory"
    ],
    "li": [
      "Java",
      "Define password storage requirements. Most applications with a database back-end store the passwords in a database table. Another option is to store the passwords in files. If your application implements the policy of preventing users from entering previously used passwords, then the salted hashes of the previously used passwords have to be stored also. If the amount of the previously used passwords that cannot be used is configurable, it is recommended to use a separate table or file to store the hashes and salts of the previously used passwords.",
      "Generate a random salt value. Each bit of salt doubles the memory and computational requirements for dictionary attacks. Recommended salt lengths are 64-bit or more. Use a random number generator of your choice to generate a random number of required size. Use this number as the salt.",
      "Hash the password and the salt using multiple iterations. Use the  SecretKeyFactory API  with the  PBKDF2WithHmacSHA256  algorithm to hash and salt the password using multiple iterations. The amount of iterations has to be the same when storing the password and when checking the password during authentication.",
      "Store the hash and the salt. Store the hash in the file or database of your choosing. It is important to store both the hash and the salt, because the salt will have to be used when comparing user entered passwords to the hashed value.",
      "Implement password verification. During authentication, the password entered by the user should be checked against the value calculated using PBKDF2. To do this, retrieve the hash value and the salt from password storage. Use PBKDF2 to calculate a value based on user input and the stored salt and compare the resulting string against the stored hash. If the resulting hash is the same as the stored hash, the user has entered the correct password.",
      "For more information about the SecretKeyFactory API and PBKDF2WithHmacSHA1, see http://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#SecreyKeyFactory"
    ],
    "p": [
      "Use iterative hashing to protect stored passwords.",
      "Storing hashes instead of plain-text passwords assures that an attacker cannot easily recover the passwords if he gains access to the password files. Adding salt to hashed files makes hashes much harder to break with dictionary attacks. Hashing should be applied multiple times to make hashing take longer and thus increase the computational resources required to attack the hashes. Iterative hashing applies a hashing function multiple times to a password and a salt, drastically increasing the time required to perform dictionary attacks.",
      "Use iterative hashing when storing passwords.",
      "The following steps show how to use iterative hashing:",
      "Note: Never store the user credentials or their hashes on the client side (e.g. in cookies, hidden fields, etc.). Use sessions when there is a need to track the user or store their hashed credentials.",
      "The following code validates the user based on a given username and password. It calculated the PBKDF2 using the password and salt. Then it compares the username and the produced hash against the hash stored in the backend database. Therefore, the password is not stored in the database."
    ],
    "ol": [
      "Define password storage requirements. Most applications with a database back-end store the passwords in a database table. Another option is to store the passwords in files. If your application implements the policy of preventing users from entering previously used passwords, then the salted hashes of the previously used passwords have to be stored also. If the amount of the previously used passwords that cannot be used is configurable, it is recommended to use a separate table or file to store the hashes and salts of the previously used passwords.\n Generate a random salt value. Each bit of salt doubles the memory and computational requirements for dictionary attacks. Recommended salt lengths are 64-bit or more. Use a random number generator of your choice to generate a random number of required size. Use this number as the salt.\n Hash the password and the salt using multiple iterations. Use the  SecretKeyFactory API  with the  PBKDF2WithHmacSHA256  algorithm to hash and salt the password using multiple iterations. The amount of iterations has to be the same when storing the password and when checking the password during authentication.\n Store the hash and the salt. Store the hash in the file or database of your choosing. It is important to store both the hash and the salt, because the salt will have to be used when comparing user entered passwords to the hashed value.\n Implement password verification. During authentication, the password entered by the user should be checked against the value calculated using PBKDF2. To do this, retrieve the hash value and the salt from password storage. Use PBKDF2 to calculate a value based on user input and the stored salt and compare the resulting string against the stored hash. If the resulting hash is the same as the stored hash, the user has entered the correct password."
    ],
    "strong": [
      "Define password storage requirements.",
      "Generate a random salt value.",
      "Hash the password and the salt using multiple iterations.",
      "Store the hash and the salt.",
      "Implement password verification.",
      "Note:"
    ],
    "tt": [
      "SecretKeyFactory API",
      "PBKDF2WithHmacSHA256"
    ],
    "pre": [
      "public boolean validateUser(String user, char[] pass)\n\t\n{\n\ttry {\n\t\t...\n\t\tbyte[] storedPassHash;\n\t\tbyte[] salt;\n\t\t// set storedPassHash and salt to values from database\n\t\tbyte[] passHash = hashCredentials(pass, salt);\n\t\treturn Arrays.equals(passHash, storedPassHash);\n\t} catch (NoSuchAlgorithmException nsae) {\n\t\t// Add the appropriate logging and exception handling mechanisms\n\t\treturn false;\n\t} catch (InvalidKeySpecException ikse) {\n\t\t// Add the appropriate logging and exception handling mechanisms\n\t\treturn false;\n\t}\n}\n\npublic String hashCredentials(char[] pass, byte[] salt)\n       throws NoSuchAlgorithmException, InvalidKeySpecException\n{\n\tString algorithm = “PBKDF2WithHmacSHA1”;\n\tint derivedKeyLength = 160;\n\tint iterations = 10000;\n\n\tKeySpec spec = newPBEKeySpec(pass, salt, iterations, derivedKeyLength);\n\tSecreyKeyFactory skf = SecreyKeyFactory.getInstance(algorithm);\n\n\tReturn skf.generateSecret(spec).getEncoded();\n}"
    ],
    "a": [
      "http://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#SecreyKeyFactory"
    ]
  },
  "links": [
    {
      "href": "http://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#SecreyKeyFactory",
      "text": "http://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#SecreyKeyFactory"
    }
  ],
  "html": "<h2>Applies To</h2><ul><li> Java</li>\n</ul><h2>What to Do</h2><p>Use iterative hashing to protect stored passwords.\n</p><h2>Why</h2><p>Storing hashes instead of plain-text passwords assures that an attacker cannot easily recover the passwords if he gains access to the password files. Adding salt to hashed files makes hashes much harder to break with dictionary attacks. Hashing should be applied multiple times to make hashing take longer and thus increase the computational resources required to attack the hashes. Iterative hashing applies a hashing function multiple times to a password and a salt, drastically increasing the time required to perform dictionary attacks.\n</p><h2>When</h2><p>Use iterative hashing when storing passwords.\n</p><h2>How</h2><p>The following steps show how to use iterative hashing:\n</p><ol>\n<li> <strong>Define password storage requirements.</strong> Most applications with a database back-end store the passwords in a database table. Another option is to store the passwords in files. If your application implements the policy of preventing users from entering previously used passwords, then the salted hashes of the previously used passwords have to be stored also. If the amount of the previously used passwords that cannot be used is configurable, it is recommended to use a separate table or file to store the hashes and salts of the previously used passwords.</li>\n<li> <strong>Generate a random salt value.</strong> Each bit of salt doubles the memory and computational requirements for dictionary attacks. Recommended salt lengths are 64-bit or more. Use a random number generator of your choice to generate a random number of required size. Use this number as the salt.</li>\n<li> <strong>Hash the password and the salt using multiple iterations.</strong> Use the <tt> SecretKeyFactory API </tt> with the <tt> PBKDF2WithHmacSHA256 </tt> algorithm to hash and salt the password using multiple iterations. The amount of iterations has to be the same when storing the password and when checking the password during authentication.</li>\n<li> <strong>Store the hash and the salt.</strong> Store the hash in the file or database of your choosing. It is important to store both the hash and the salt, because the salt will have to be used when comparing user entered passwords to the hashed value.</li>\n<li> <strong>Implement password verification.</strong> During authentication, the password entered by the user should be checked against the value calculated using PBKDF2. To do this, retrieve the hash value and the salt from password storage. Use PBKDF2 to calculate a value based on user input and the stored salt and compare the resulting string against the stored hash. If the resulting hash is the same as the stored hash, the user has entered the correct password.</li>\n</ol><p>\n<strong>Note:</strong> Never store the user credentials or their hashes on the client side (e.g. in cookies, hidden fields, etc.). Use sessions when there is a need to track the user or store their hashed credentials. \n</p><h2>Solution Example</h2><p>The following code validates the user based on a given username and password. It calculated the PBKDF2 using the password and salt. Then it compares the username and the produced hash against the hash stored in the backend database. Therefore, the password is not stored in the database.\n</p><pre>\n\npublic boolean validateUser(String user, char[] pass)\n\t\n{\n\ttry {\n\t\t...\n\t\tbyte[] storedPassHash;\n\t\tbyte[] salt;\n\t\t// set storedPassHash and salt to values from database\n\t\tbyte[] passHash = hashCredentials(pass, salt);\n\t\treturn Arrays.equals(passHash, storedPassHash);\n\t} catch (NoSuchAlgorithmException nsae) {\n\t\t// Add the appropriate logging and exception handling mechanisms\n\t\treturn false;\n\t} catch (InvalidKeySpecException ikse) {\n\t\t// Add the appropriate logging and exception handling mechanisms\n\t\treturn false;\n\t}\n}\n\npublic String hashCredentials(char[] pass, byte[] salt)\n       throws NoSuchAlgorithmException, InvalidKeySpecException\n{\n\tString algorithm = “PBKDF2WithHmacSHA1”;\n\tint derivedKeyLength = 160;\n\tint iterations = 10000;\n\n\tKeySpec spec = newPBEKeySpec(pass, salt, iterations, derivedKeyLength);\n\tSecreyKeyFactory skf = SecreyKeyFactory.getInstance(algorithm);\n\n\tReturn skf.generateSecret(spec).getEncoded();\n} \n\n</pre><h2>Additional Resources</h2><ul><li> For more information about the SecretKeyFactory API and PBKDF2WithHmacSHA1, see <a href=\"http://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#SecreyKeyFactory\">http://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#SecreyKeyFactory</a></li></ul>"
}