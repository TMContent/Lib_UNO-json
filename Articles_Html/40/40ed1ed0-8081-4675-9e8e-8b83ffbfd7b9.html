<h1>Applies to</h1>
  <p>Scala and Play Framework 2.1.0+<br /></p>
  <h1>What to Check For</h1>
  <p>Ensure that accounts&nbsp;are locked after consecutive failed login attempts.</p>
  <h1>Why</h1>
  <p>Multiple, consecutive failed login attempts over a short time period can sometimes be a symptom of an attack. Locking the account will prevent the attacker from continuing the break-in attempt.</p>
  <h1>How to Check</h1>
  <p>To ensure your application will lock an account after consecutive failed login attempts:</p>
  <ol>
    <li>
      <p>
        <strong>Verify that your application has a lockout policy.&nbsp;</strong>An account lockout policy is typically application specific. Review your application's requirements and design specifications and verify the&nbsp;following functionality:</p>
      <ul>
        <li>A mechanism to determine failed login attempts.</li>
        <li>A mechanism to specify an allowed number of login attempts.<br /></li>
        <li>A mechanism to lock accounts that have exceeded the allowed number of login attempts.</li>
        <li>A mechanism to unlock these accounts.<br /></li>
      </ul>
    </li>
    <li>
      <p>
        <strong>Verify that your application tracks login attempts for each user. </strong>Ensure that all authentication procedures track the number of login attempts, and that the login counter is reset to 0 upon a successful login.</p>
    </li>
    <li>
      <p>
        <strong>Verify that your application enforces the lockout policy. </strong>Ensure that all authentication procedures enforce your application's lockout policy. The implementation should&nbsp;match the lockout policy per the business requirements of your organization, which may change over time.</p>
    </li>
  </ol>
  <blockquote>
    <p>
      <strong>Note &nbsp;</strong> PCI DSS certification requires that logs must include failed login attempts, and that an account must be locked for at least 30 minutes after no more than six failed login attempts.</p>
  </blockquote>
  <h1>How to Fix</h1>
  <p>To successfully lock accounts after consecutive failed login attempts:</p>
  <ol>
    <li>
      <p>
        <strong>Determine a lockout policy. </strong>There are two variables to consider when determining a lockout policy:</p>
      <ul>
        <li>Number of allowed consecutive failed login attempts</li>
        <li>Amount of time that a locked account will remain locked</li>
      </ul>
      <p>A
 simple policy would be to lock an account after&nbsp;five failed login 
attempts for the duration of 15 minutes. Although this is an effective 
method for blocking a brute force attack, it exposes your application to
 denial of service as an attacker can easily keep an account locked 
through a small stream of authentication requests.<br /><br />When 
determining the lockout policy, it is important to evaluate the risk of 
attacks against the user and the support costs associated with 
reactivating a locked account. For example, requiring the user to 
contact your organization's support staff&nbsp;to reactivate a locked account
 will have a direct impact on support costs and would add general user 
frustration.&nbsp;However, it is important to use extra care when designing 
more sophisticated variations of your application's lockout policy, such
 as correlating a single or multiple user login attempts with a source 
IP. When adding extra levels of complexity, carefully consider and 
evaluate the scenarios where your application's lockout policy can be 
circumvented or can harm your business. For instance, consider scenarios
 where an attacker would attempt to compromise a user through the use of
 multiple hosts, or multiple users would authenticate using a shared 
office IP.</p>
    </li>
    <li>
      <p>
        <strong>Track login attempts. </strong>Use a login counter. Increment the counter when a user tries to log in. Reset the counter to 0 after a successful login. Example:</p>
      <pre>-- Authenticate the user<br />sql&gt; select login_attempts from users<br />      where user = {{username}} and pass = {{passDigest}};<br /> -- Reset the login counter<br />sql&gt; update users set login_attempts = 0 where user = {{username}};</pre>
    </li>
    <li>
      <p>
        <strong>Enforce the lockout policy. </strong>Enforce the policy at all points in the application where authentication is necessary. Example:</p>
      <pre>String dbStatement = "select login_attempts from users"<br />                   + "where user = ? and pass = ?;";<br />PreparedStatement st = dbConnection.prepareStatement(dbStatement);<br />st.setString(1, user);st.setString(2, passDigest);<br />ResultSet rs = st.executeQuery();<br /><br />if (rs.first())<br />{      <br />userIsValid = true;<br />      loginCount = rs.getInt(1);<br />}<br />else<br />{<br />      userIsValid = false;<br />}<br /><br />rs.close();<br /><br />if(userIsValid)<br />{<br />      if(loginCount &gt; 3)<br />      {<br />            throw new AccountIsLockedException();<br />      }<br /><br />      // The application checks the password's maturity<br />      checkPasswordMaturity(user);<br />}<br />else<br />{<br />      updateLastLoginAttempt(user);<br />}</pre>
    </li>
    <li>
      <p>
        <strong>Set an unlocking mechanism.&nbsp;</strong>Keep track of the lockout period. Based on your application's lockout 
policy, unlock the account after the lockout period has expired. Example:</p>
      <pre>-- Unlock all locked accounts whose 45 minute lockout period has expired<br />sql&gt; update users set login_attempts = 0<br />      where last_login </pre>
    </li>
  </ol>
  <blockquote>
    <p>
      <strong>Note &nbsp;</strong> PCI DSS requirements state that an account must be locked for at least 30 minutes after no more than six failed login attempts.</p>
  </blockquote>
  <h1>Problem Example</h1>
  <p>The following code executes the database transaction required during authentication. Because the transaction fails to check the login counter, it is possible for an attacker to compromise an account through the use of a brute force or a dictionary attack.</p>
  <pre>// The application fails to check the number of login attempts<br />String dbStatement = "select user from users where user = ? and pass = ?;";<br />st = dbConnection.prepareStatement(dbStatement);<br />st.setString(1, user);<br />st.setString(2, passDigest);<br />rs = st.executeQuery();</pre>
  <h1>Solution Example</h1>
  <p>The following code executes the database transaction required during authentication. Because the transaction checks the login counter, it would be very expensive for an attacker to compromise an account through the use of a brute force or a dictionary attack. <br /></p>
  <pre>// The application checks the number of login attempts<br />String dbStatement = "select login_attempts from users where user = ? and pass = ?;";<br />PreparedStatement st = dbConnection.prepareStatement(dbStatement);<br />st.setString(1, user);<br />st.setString(2, passDigest);<br />ResultSet rs = st.executeQuery();<br /><br />if (rs.first())<br />{<br />      userIsValid = true;<br />      loginCount = rs.getInt(1);<br />}<br />else<br />{<br />      userIsValid = false;<br />}<br /><br />rs.close();<br /><br />if(userIsValid)<br />{<br />      if(loginCount &gt; 3)<br />      {<br />            throw new AccountIsLockedException();<br />      }<br />      checkPasswordMaturity(user);<br />}<br />else<br />{<br />      updateLastLoginAttempt(user);<br />}</pre>
  <br />