{
  "id": "09603b85-0c14-493e-b611-c10b60e5c6a9",
  "checksum": "bdf86e721662677a932102e6129fc13f200836d1",
  "words": {
    "0": [
      "pre",
      "pre"
    ],
    "what": [
      "h1"
    ],
    "to": [
      "h1",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "do": [
      "h1",
      "p"
    ],
    "carefully": [
      "p"
    ],
    "track": [
      "p"
    ],
    "your": [
      "p",
      "p",
      "p"
    ],
    "acquires": [
      "p",
      "p"
    ],
    "and": [
      "p",
      "p",
      "p",
      "p",
      "title"
    ],
    "releases": [
      "p",
      "p"
    ],
    "when": [
      "p",
      "h1",
      "p",
      "p",
      "p",
      "title"
    ],
    "using": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "title"
    ],
    "a": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "semaphore": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "or": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "other": [
      "p",
      "p",
      "p",
      "p",
      "title"
    ],
    "reference": [
      "p",
      "p",
      "p",
      "title"
    ],
    "counting": [
      "p",
      "p",
      "p",
      "p",
      "title"
    ],
    "mechnisms": [
      "p"
    ],
    "ensure": [
      "p",
      "p",
      "p"
    ],
    "the": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "p",
      "p",
      "p",
      "p",
      "p",
      "pre",
      "pre"
    ],
    "stays": [
      "p"
    ],
    "balanced": [
      "p"
    ],
    "why": [
      "h1"
    ],
    "if": [
      "p",
      "p",
      "pre",
      "pre",
      "pre"
    ],
    "becomes": [
      "p"
    ],
    "unbalanced": [
      "p"
    ],
    "it": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "could": [
      "p",
      "p",
      "p"
    ],
    "either": [
      "p"
    ],
    "block": [
      "p",
      "p"
    ],
    "system": [
      "p"
    ],
    "execution": [
      "p",
      "p",
      "p"
    ],
    "too": [
      "p",
      "p",
      "p"
    ],
    "many": [
      "p",
      "p",
      "p"
    ],
    "allow": [
      "p"
    ],
    "threads": [
      "p"
    ],
    "access": [
      "p"
    ],
    "resource": [
      "p",
      "p"
    ],
    "releases.": [
      "p"
    ],
    "mechanisms": [
      "p",
      "title"
    ],
    "cause": [
      "p"
    ],
    "unexpected": [
      "p"
    ],
    "results": [
      "p"
    ],
    "such": [
      "p"
    ],
    "as": [
      "p",
      "p",
      "p"
    ],
    "memory": [
      "p"
    ],
    "leaks": [
      "p"
    ],
    "release": [
      "p",
      "p",
      "p",
      "p"
    ],
    "of": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "interfaces": [
      "p"
    ],
    "before": [
      "p",
      "p",
      "p"
    ],
    "code": [
      "p"
    ],
    "is": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "done": [
      "p"
    ],
    "them": [
      "p"
    ],
    "any": [
      "p"
    ],
    "mechanism": [
      "p"
    ],
    "how": [
      "h1"
    ],
    "trace": [
      "p",
      "p"
    ],
    "paths": [
      "p",
      "p"
    ],
    "make": [
      "p"
    ],
    "sure": [
      "p"
    ],
    "that": [
      "p",
      "p",
      "p"
    ],
    "each": [
      "p",
      "p"
    ],
    "aquire": [
      "p"
    ],
    "matched": [
      "p"
    ],
    "with": [
      "p",
      "p",
      "p"
    ],
    "easiest": [
      "p"
    ],
    "this": [
      "p"
    ],
    "match": [
      "p"
    ],
    "always": [
      "p"
    ],
    "made": [
      "p"
    ],
    "in": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "same": [
      "p"
    ],
    "function": [
      "p",
      "p"
    ],
    "so": [
      "p",
      "p"
    ],
    "you": [
      "p"
    ],
    "don't": [
      "p"
    ],
    "have": [
      "p"
    ],
    "between": [
      "p"
    ],
    "multiple": [
      "p"
    ],
    "functions": [
      "p"
    ],
    "components": [
      "p"
    ],
    "case": [
      "p",
      "p",
      "p"
    ],
    "best": [
      "p"
    ],
    "practice": [
      "p"
    ],
    "use": [
      "p"
    ],
    "for": [
      "p"
    ],
    "little": [
      "p"
    ],
    "time": [
      "p"
    ],
    "possible": [
      "p"
    ],
    "matching": [
      "p"
    ],
    "closely": [
      "p"
    ],
    "an": [
      "p",
      "p",
      "p"
    ],
    "acquire": [
      "p"
    ],
    "good": [
      "p"
    ],
    "idea": [
      "p"
    ],
    "be": [
      "p",
      "title"
    ],
    "especially": [
      "p"
    ],
    "careful": [
      "p",
      "title"
    ],
    "error": [
      "p",
      "p",
      "p",
      "pre",
      "p"
    ],
    "exceptions": [
      "p"
    ],
    "place": [
      "p"
    ],
    "call": [
      "p",
      "p",
      "p",
      "pre",
      "p",
      "p"
    ],
    "finally": [
      "p"
    ],
    "called": [
      "p"
    ],
    "course": [
      "p"
    ],
    "normal": [
      "p",
      "p"
    ],
    "exception": [
      "p"
    ],
    "handling": [
      "p"
    ],
    "logic": [
      "p"
    ],
    "return": [
      "p",
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "path": [
      "p"
    ],
    "out": [
      "p"
    ],
    "correct": [
      "p"
    ],
    "number": [
      "p"
    ],
    "references": [
      "p"
    ],
    "problem": [
      "h1"
    ],
    "example": [
      "h1",
      "p",
      "h1",
      "p"
    ],
    "following": [
      "p",
      "p"
    ],
    "acquired": [
      "p",
      "p"
    ],
    "read": [
      "p",
      "p",
      "pre",
      "p",
      "pre"
    ],
    "released": [
      "p",
      "p",
      "p"
    ],
    "after": [
      "p",
      "p"
    ],
    "parsebuffer": [
      "p",
      "p"
    ],
    "however": [
      "p"
    ],
    "not": [
      "p"
    ],
    "bool": [
      "pre",
      "pre"
    ],
    "readfromsocketsocket": [
      "pre",
      "pre"
    ],
    "socket": [
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "char": [
      "pre",
      "pre"
    ],
    "*recvbuffer": [
      "pre",
      "pre"
    ],
    "int": [
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "len{": [
      "pre",
      "pre"
    ],
    "//first": [
      "pre",
      "pre"
    ],
    "from": [
      "pre",
      "pre"
    ],
    "gsemaphoreaquire();": [
      "pre",
      "pre"
    ],
    "ret": [
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "=": [
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "readsocket,": [
      "pre",
      "pre"
    ],
    "recvbuffer": [
      "pre",
      "pre"
    ],
    "len": [
      "pre",
      "pre"
    ],
    "0;": [
      "pre",
      "pre"
    ],
    "{": [
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "//now": [
      "pre",
      "pre"
    ],
    "parse": [
      "pre",
      "pre"
    ],
    "buffer": [
      "pre",
      "pre"
    ],
    "parsebufferrecvbuffer,": [
      "pre",
      "pre"
    ],
    "len;": [
      "pre",
      "pre"
    ],
    "gsemaphorerelease();": [
      "pre",
      "pre",
      "pre"
    ],
    "true": [
      "pre",
      "pre"
    ],
    "}": [
      "pre",
      "pre"
    ],
    "else": [
      "pre",
      "pre"
    ],
    "//can": [
      "pre"
    ],
    "wsagetlasterror": [
      "pre"
    ],
    "we": [
      "pre"
    ],
    "need": [
      "pre"
    ],
    "details": [
      "pre"
    ],
    "false": [
      "pre",
      "pre"
    ],
    "}}": [
      "pre",
      "pre"
    ],
    "solution": [
      "h1"
    ],
    "also": [
      "p"
    ],
    "handler": [
      "p"
    ],
    "semaphores": [
      "title"
    ]
  },
  "tags": {
    "h1": [
      "What to Do",
      "Why",
      "When",
      "How",
      "Problem Example",
      "Solution Example"
    ],
    "p": [
      "Carefully track your acquires and releases when using a semaphore or other reference counting mechnisms to ensure the counting stays balanced.",
      "If a semaphore becomes unbalanced it could either block system execution (too many acquires) or it could allow too many threads to access a resource (too many releases). Other reference counting mechanisms could cause other unexpected results such as memory leaks or release of interfaces before your code is done using them.",
      "When using a semaphore or any other reference counting mechanism.",
      "Trace your execution paths to make sure that each aquire is matched with a release. It is easiest to do this if the match is always made in the same function so that you don't have to trace between multiple functions or components. In the case of a semaphore it is best practice to use the resource for as little time as possible so matching a release closely to an acquire is a good idea.",
      "Be especially careful with error paths. When using exceptions place the release call in a finally block to ensure it is called in the course of normal execution or in the case of an exception. When using normal error handling logic, ensure that each return path out of a function releases the correct number of references.",
      "In the following example, the semaphore is acquired before the read call and is released after the parseBuffer call. However, it is not released in the case of an error with the read.",
      "In the following example, the semaphore is acquired before the read call and is released after the parseBuffer call and also in the error handler."
    ],
    "pre": [
      "bool ReadFromSocket(SOCKET socket, char *recvBuffer, int len){  //first read from the socket  gSemaphore.Aquire();  int ret = read(socket, recvBuffer, len, 0);  if (ret >= 0)  {      //now parse the buffer      parseBuffer(recvBuffer, len);      gSemaphore.Release();      return true;  }  else  {      //can call WSAGetLastError if we need error details      return false;  }}",
      "bool ReadFromSocket(SOCKET socket, char *recvBuffer, int len){  //first read from the socket  gSemaphore.Aquire();  int ret = read(socket, recvBuffer, len, 0);  if (ret >= 0)  {      //now parse the buffer      parseBuffer(recvBuffer, len);      gSemaphore.Release();      return true;  }  else  {      gSemaphore.Release();      return false;  }}"
    ],
    "br": [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  "links": [],
  "html": "<h1>What to Do</h1>\r\n  <p>Carefully track your acquires and releases when using a semaphore or other reference counting mechnisms to ensure the counting stays balanced. </p>\r\n  <h1>Why</h1>\r\n  <p>If a semaphore becomes unbalanced it could either block system execution (too many acquires) or it could allow too many threads to access a resource (too many releases). Other reference counting mechanisms could cause other unexpected results such as memory leaks or release of interfaces before your code is done using them.</p>\r\n  <h1>When</h1>\r\n  <p>When using a semaphore or any other reference counting mechanism.</p>\r\n  <h1>How</h1>\r\n  <p>Trace your execution paths to make sure that each aquire is matched with a release. It is easiest to do this if the match is always made in the same function so that you don't have to trace between multiple functions or components. In the case of a semaphore it is best practice to use the resource for as little time as possible so matching a release closely to an acquire is a good idea.&nbsp; </p>\r\n  <p>Be especially careful with error paths. When using exceptions place the release call in a finally block to ensure it is called in the course of normal execution or in the case of an exception. When using normal error handling logic, ensure that each return path out of a function releases the correct number of references.</p>\r\n  <h1>Problem Example</h1>\r\n  <p>In the following example, the semaphore is acquired before the read call and is released after the parseBuffer call. However, it is not released in the case of an error with the read.</p>\r\n  <pre>bool ReadFromSocket(SOCKET socket, char &#42;recvBuffer, int len)<br />&#123;<br />  //first read from the socket<br />  gSemaphore.Aquire();<br />&nbsp; int ret = read(socket, recvBuffer, len, 0);<br /><br /><br />  if (ret &gt;= 0)<br />  &#123;<br />      //now parse the buffer<br />      parseBuffer(recvBuffer, len);<br />      gSemaphore.Release();<br />      return true;<br />  &#125;<br />  else<br />  &#123;<br />      //can call WSAGetLastError if we need error details<br />      return false;<br />  &#125;<br />&#125;</pre>\r\n  <h1>Solution Example</h1>\r\n  <p>In the following example, the semaphore is acquired before the read call and is released after the parseBuffer call and also in the error handler. </p>\r\n  <pre>bool ReadFromSocket(SOCKET socket, char &#42;recvBuffer, int len)<br />&#123;<br />  //first read from the socket<br />  gSemaphore.Aquire();<br />&nbsp; int ret = read(socket, recvBuffer, len, 0);<br /><br /><br />  if (ret &gt;= 0)<br />  &#123;<br />      //now parse the buffer<br />      parseBuffer(recvBuffer, len);<br />      gSemaphore.Release();<br />      return true;<br />  &#125;<br />  else<br />  &#123;<br />      gSemaphore.Release();<br />      return false;<br />  &#125;<br />&#125;</pre>"
}