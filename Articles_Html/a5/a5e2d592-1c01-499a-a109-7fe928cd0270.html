<h2>Applies To</h2><ul><li> Web Applications</li>
<li> Server-side</li>
</ul><h2>What to Do</h2><p>All web applications need to validate their input, and this should be performed in a single centralized place, to ensure consistency.
</p><h2>Why</h2><p>Inconsistent application of input validation does not adequately prevent attacks.  Also, centralization ensures that as data formats change, validation standards change with them in a consistent manner.  Centralization will also reduce development effort and help with future maintenance.
</p><h2>When</h2><p>All systems should centralize their input validation.
</p><h2>How</h2><p>Getting input validation correct is tricky; there's a reason that it's the number one security problem for web applications. However, when approached systematically, it's not too hard of a problem to solve. Follow these steps:
</p><ol>
<li> <strong>Determine all inputs.</strong> Identify all the inputs to your system, and what format they have.</li>
<li> <strong>Determine all trusted data stores.</strong> Identify all the places you pull data from that you can rely on to preserve data validity, and those whos output you need to validate.</li>
<li> <strong>Determine all crossover points.</strong> Find all the points where input might contaminate other data, and ensure that validation is performed before those points. </li>
<li> <strong>Determine all outputs.</strong> Find all the outputs from your system, and ensure that context-appropriate encoding is performed at those points.</li>
<li> <strong>Centralize your validation.</strong> Centralize all your validation code into a single module, and ensure that it's always used appropriately.</li>
<li> <strong>Centralize your encoding.</strong> Centralize all your encoding code into a single module, ensure it handles all your contexts, and that it's always used appropriately.</li>
<li> <strong>Ensure all paths preserve validation.</strong> Ensure that every path through the system keeps data in a valid form; watch out for round trips through the client or client-side validation.</li>
</ol><p>
One of the biggest dangers of implementing input validation is inconsistent validation; an attack may be caught on one data path, but not on another. An attacker will try all of them, however. The way to solve this problem is to have a single point of responsibility for input validation. Where this is depends on the design. If every piece of input is an object, then it may be appropriate to have the object constructs and setters perform the validation for that object's input. In a less strictly OO system, a single module with methods for each different input format may be more appropriate.
</p><p>
Which ever method is chosen, the input validation routine for a specific data type should be as strict as possible. For example, when validating a US zip code, allow either 5 or 9 numbers, and nothing else. If you're dealing with international postal codes, either validate them seperately with a looser format that also allows letters, or build a more complex validator that understands the postal codes of each nation, if you need to ensure a higher level of integrity.</p>