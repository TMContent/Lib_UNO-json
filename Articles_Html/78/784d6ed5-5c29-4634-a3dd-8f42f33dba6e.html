<h1>Applies To</h1>
  <ul>
    <li>ASP.NET 4.0</li>
  </ul>
  <h1>Summary</h1>
  <p>The purpose of this code snippet is to illustrate how to execute a new process under a different user account within a running .NET application.</p>
  <h1>Objectives</h1>
  <ul>
    <li>Secure execution of a new process from within a running application.</li>
    <li>Secure storage and retrieval of credentials needed to run a process encrypted in the DPAPI.</li>
    <li>Deploying an application in "least privilege" mode and making use of another, privileged component to perform a critical task.</li>
  </ul>
  <h1>Scenarios</h1>
  <ul>
    <li>Application component needs to access functionality that only exists in a different runtime component.</li>
    <li>Application occasionally needs access to privileged functionality but wants to use a low-privileged security context for enhanced overall security.</li>
  </ul>
  <h1>Solution Example</h1>
  <pre>// Execute a process under another user account, making<br />// use of credentials stored in the DPAPI<br />static public void ExecuteProcess(string fullProcessPath) {<br />    // Retrieve the user and password from the registry and decrypt<br />    byte[] encryptedUser = Registry.GetValue(@"HKEY_CURRENT_USER\ProcessExecCreds", "User", null) as byte[];<br />    byte[] encryptedPass = Registry.GetValue(@"HKEY_CURRENT_USER\ProcessExecCreds", "Pass", null) as byte[];<br />    string user = Encoding.ASCII.GetString(ProtectedData.Unprotect(encryptedUser, null, DataProtectionScope.CurrentUser));<br />    string pass = Encoding.ASCII.GetString(ProtectedData.Unprotect(encryptedPass, null, DataProtectionScope.CurrentUser));<br />    SecureString securepass = new SecureString();<br />    foreach(char b in pass.ToCharArray()) {<br />                securepass.AppendChar(b);<br />    }<br /><br />    // Execute a process as our stored user account<br />    // This process will run a simple batch file that outputs the runtime account name<br />    Process process = new Process();<br />    process.StartInfo.UseShellExecute = false;<br />    process.StartInfo.RedirectStandardOutput = true;<br />    process.StartInfo.RedirectStandardError = true;<br />    process.StartInfo.CreateNoWindow = true;<br /><br />    // Set the working directory to a value the user will be able to access<br />    process.StartInfo.FileName = fullProcessPath;<br />    process.StartInfo.WorkingDirectory = @"C:\";<br />    process.StartInfo.UserName = user;<br />    process.StartInfo.Password = securepass;<br />    process.Start();<br />    string output = process.StandardOutput.ReadToEnd();<br />    Console.WriteLine(output);<br />}</pre>
  <h1>Problem Example</h1>
  <p>The following example executes simple execution of a process within the user context defined by the running executable. An example </p>
  <pre>// Start my process with a given argument<br />Process.Start("MyProc.exe", @"MyArg");</pre>
  <ul>
    <li>The parent application must run with the same level of privileges as the executed process.</li>
    <li>The process path is not fully specified, rendering the Process.Start call more vulnerable to trojan execution.</li>
    <li>Application makes use of a different user context to run the process, but stores the credentials in clear text in a file or database</li>
  </ul>
  <h1>Test Case</h1>
  <p>The following classes must be included in any project making use of the sample code provided above:</p>
  <pre>using System.Diagnostics;<br />using System.IO;<br />using System.Runtime.InteropServices;<br />using System.Security;<br />using System.Security.AccessControl;<br />using System.Security.Cryptography;<br />using Microsoft.Win32;</pre>
  <p>Run the following code to store a set of credentials in the registry using the DPAPI and, in conjunction with the solution method, execute a command as a given user. The example test case executes the "<em>whoami</em>" command. </p>
  <pre>static void Main(string[] args){<br />    // prompt for credentials and store in the registry using DPAPI<br />    StoreUserCreds();<br /><br />    // retrieve the credentials from the DPAPI and run a process<br />    ExecuteProcess(@"whoami.exe");<br />}<br /><br />// This method provides a mechanism for storing credentials<br />// for a runtime process in the registry using the DPAPI.<br />static public void StoreUserCreds(){<br />    // Obtain username and password for the account<br />    Console.Write(@"Enter user name for process execution: ");<br />    string user = Console.ReadLine();<br />    Console.Write("Enter password for this user name: ");<br />    string pass = Console.ReadLine();<br /><br />    // Convert the username and passwords to byte arrays and encrypt<br />    // the data by using the DPAPI ProtectedData class.<br />    byte[] encryptedUser = ProtectedData.Protect(<br />            UnicodeEncoding.ASCII.GetBytes(user),<br />            null,<br />            DataProtectionScope.CurrentUser);<br />    byte[] encryptedPass = ProtectedData.Protect(<br />            UnicodeEncoding.ASCII.GetBytes(pass),<br />            null,<br />            DataProtectionScope.CurrentUser);<br /><br />    // Create a security context for a new key that we will use to store<br />    // the credentials that will restrict access to only the application user.<br />    string userEnv = Environment.UserDomainName + "\\" + Environment.UserName;<br />    RegistrySecurity security = new RegistrySecurity();<br />    RegistryAccessRule rule = new RegistryAccessRule(userEnv,<br />            RegistryRights.FullControl,<br />            InheritanceFlags.ContainerInherit,<br />            PropagationFlags.None,<br />            AccessControlType.Allow);<br />    security.AddAccessRule(rule);<br /><br />    // Create a new registry key and apply the security context<br />    Registry.CurrentUser.CreateSubKey("ProcessExecCreds",<br />            RegistryKeyPermissionCheck.ReadWriteSubTree,<br />            security);<br /><br />    // Write the encrypted credentials into the registry<br />    Registry.SetValue(@"HKEY_CURRENT_USER\ProcessExecCreds", "User", encryptedUser);<br />    Registry.SetValue(@"HKEY_CURRENT_USER\ProcessExecCreds", "Pass", encryptedPass);<br />}</pre>
  <h1>Expected Result</h1>
  <p>The following output was obtaining by running the test case as "<em>vm-win2003\Administrator</em>"</p>
  <pre>Enter user name for process execution: joeuser<br />Enter password for this user name: joeuser1234<br />vm-win2003\joeuser</pre>
  <h1>More Information</h1>
  <p>The code makes use of the <em>CurrentUser</em> scope instead of the <em>MachineKey</em> scope so that other, potentially malicious applications cannot access this key in the registry and decrypt. This provides additional security but sacrifices interoperability with other applications. Consider using the <em>MachineKey</em> scope if you have a need to share credential data between applications.</p>
  <br />
  <hr />
  <p>Adapted from Microsoft patterns &amp; practices guidance.</p>