<h1>Applies to</h1>
  <ul>
    <li>ASP.NET 4.0</li>
  </ul>
  <h1>Summary</h1>
  <p>This How To shows you how and when you should use impersonation in ASP.NET applications. By default, impersonation is turned off, and you can access resources by using the ASP.NET Web application's process identity. However, you can use impersonation to access local resources and perform operations by using the authenticated user's identity or by using a specific Windows identity. You can enable impersonation programmatically or by applying appropriate configuration settings in the Web.config file.</p>
  <p>Delegation allows you to use an impersonation token to access network resources. Your ability to use delegation depends on your selected authentication mechanism and appropriate account configuration. You should be careful when you use impersonation and delegation because of the additional security and scalability issues it can cause.</p>
  <h1>Contents</h1>
  <ul>
    <li>
      <div>Objectives</div>
      <li>
        <div>Overview</div>
        <li>Impersonation Scenarios <li><div>Impersonating the Original Caller</div><li><div>Impersonating the Original Caller Temporarily</div><li><div>Impersonating by Using LogonUser</div><li><div>Impersonating by Using the WindowsIdentity Constructor</div><li><div>Impersonating a Fixed Identity</div><li><div>Delegation</div><li><div>Impersonation / Delegation vs. Trusted Subsystem</div><li><div>Delegation Table</div><li><div>Additional Resources</div></li></li></li></li></li></li></li></li></li></li>
      </li>
    </li>
  </ul>
  <h1>Objectives</h1>
  <ul>
    <li>Configure your Web application to impersonate the original caller. <li>Configure your Web application to impersonate a specific Windows identity. <li>Impersonate the original caller programmatically to run specific code under an impersonated identity in your Web application. <li>Use delegation to access network resources. </li></li></li></li>
  </ul>
  <h1>Overview</h1>
  <p>By default, ASP.NET does not use impersonation, and your code runs using the ASP.NET application's process identity. On the Microsoft Windows Server 2003 and later operating systems, ASP.NET applications run in an Internet Information Services (IIS) application pool by default. The IIS application pool runs under the <em>NT AUTHORITY\Network Service</em> identity. </p>
  <p>Because impersonation is disabled, the application gains access to all resources by using the process identity. Any Windows resources, such as files and registry keys, must have an access control list (ACL) that grants access to the process identity.</p>
  <p>If you need to access resources by using the authenticated caller's identity or by using a specific Windows identity other than the process identity, you can configure your ASP.NET application to use impersonation. If you need to impersonate at the method level to perform specific operations or access particular resources, then you can use programmatic impersonation by using the <em>WindowsIdentity.Impersonate</em> method.</p>
  <h2>LogonUser vs. WindowsIdentity(userPrincipalName)</h2>
  <p>If your application authenticates callers by using custom authentication, such as forms authentication, then you cannot impersonate the original caller through ASP.NET configuration. Instead you must call the <em>Impersonate</em> method of a <em>WindowsIdentity</em> object that you create for the original caller. You can obtain an impersonation token for the original caller, provided that the caller has a Windows account, by calling the Win32 <em>LogonUser</em> API or by using a special form of the <em>WindowsIdentity</em> constructor that takes a single parameter of a user principal name (UPN). The technique you should use depends on the following: </p>
  <ul>
    <li>If you are impersonating a local account, you must use <em>LogonUser</em>. <li>If your application has access to the user name and password of the caller (perhaps through a logon Web page) and needs to access local resources, you should use the Win32 <em>LogonUser</em> API. This is preferable to using the <em>WindowsIdentity</em> constructor because you do not need to grant the ASP.NET process account the "<em>Act as part of the operating system</em>" privilege. <li>If your application has access to the user name only, you must use the <em>WindowsIdentity</em> constructor. However, if your application needs to access local resources, you must grant the ASP.NET process account the "<em>Act as part of the operating system</em>" privilege. </li></li></li>
  </ul>
  <h1>Impersonation Scenarios</h1>
  <p>The most common situations where you might require impersonation and delegation are: </p>
  <ul>
    <li>
      <b>Impersonating the original caller.</b> You want to access Windows resources that are protected with ACLs configured for your application's domain user accounts. <li><b>Impersonating the original caller programmatically. </b>You want to access resources predominantly by using the application's process identity, but specific methods need to use the original caller's identity. <li><b>Impersonating a specific Windows identity.</b> You need to use a specific identity or several Windows identities to access particular resources. <li><b>Using delegation to access network resources by using an impersonated identity.</b> You need to use an impersonated identity to access remote resources. </li></li></li></li>
  </ul>
  <p>This How To shows you when and how to use each approach.</p>
  <h1>Impersonating the Original Caller</h1>
  <p>If you need to access local resources, such as the file system or a local database, while assuming the identity of the original caller (the authenticated user), you need to use an appropriate IIS authentication type. Ideally, you should use IIS to configure your application's virtual directory for integrated Windows authentication, and then configure your ASP.NET application for Windows authentication and impersonation. This approach is shown in Figure 1.</p>
  <p>&nbsp;</p>
  <p>
    <b>
      <img alt="" src="http://msdn2.microsoft.com/en-us/library/ms998351.impersonationoriginalcaller(en-us,MSDN.10).gif" border="0" />
      <br />Figure 1. Impersonating the original caller</b>
  </p>
  <p>This configuration is generally required if you need to control access to Windows resources with ACLs set against the individual user of your application.</p>
  <p>To impersonate the original caller, you need to use IIS to configure appropriate authentication for your application's virtual directory and use appropriate configuration in the <em>Web.config</em> file.</p>
  <h3>To impersonate the original caller </h3>
  <ol>
    <li>Configure IIS to use Integrated Windows authentication and clear all other check boxes.&nbsp;While you could also select basic or digest authentication, integrated Windows authentication is recommended in this scenario.<b></b><li>Configure your ASP.NET application by adding the following configuration to the &lt;<em>system.web</em>&gt; section of your application's Web.config file. <div><pre>&lt;authentication mode="Windows" /&gt;<br />&lt;identity impersonate="true" /&gt;  </pre></div></li></li>
  </ol>
  <p>With this configuration, ASP.NET impersonates the IIS authenticated user, and the ASP.NET request threads that execute your Web application's code have the impersonation token attached to them. IIS passes a Windows token for the authenticated user to ASP.NET. The token can represent the authenticated user, if IIS is configured for Integrated Windows authentication, or another form of authentication such as basic, digest, or client certificate authentication. The token represents the anonymous user identity (<em>IUSR_MACHINENAME</em>) if IIS is configured to enable anonymous access.</p>
  <p>While the above configuration ensures that all resource access is performed using the identity of the original caller, if you need to access specific resources such as local files by using the process identity, you can temporarily remove the impersonation token from the ASP.NET request thread by using the following code:</p>
  <div>
    <pre>// Stop impersonation<br />WindowsImpersonationContext ctx = WindowsIdentity.Impersonate(IntPtr.Zero);<br />try <br />&#123;<br />&nbsp; // Thread is now running under the process identity.<br />&nbsp; // Any resource access here uses the process identity.<br />&#125;<br />finally <br />&#123;<br />&nbsp; // Resume impersonation<br />&nbsp; ctx.Undo(); <br />&#125;</pre>
  </div>
  <h1>Impersonating the Original Caller Temporarily</h1>
  <p>If you need to use the process identity for most resource access, and then impersonate the original caller to perform specific operations or to access specific resources, you need to use programmatic impersonation. (See Figure 2.)</p>
  <p>
    <img alt="" src="http://msdn2.microsoft.com/en-us/library/ms998351.impersonationoriginalcallertemporary(en-us,MSDN.10).gif" border="0" />
  </p>
  <p>
    <b>Figure 2. Using programmatic impersonation to temporarily impersonate the original caller.</b>
  </p>
  <p>To temporarily impersonate the original caller within a particular method, you need to obtain the <em>WindowsIdentity</em> object that represents the authenticated user, and then call its <em>Impersonate</em> method.</p>
  <h3>To temporarily impersonate the original caller </h3>
  <ol>
    <li>Ensure that impersonation is disabled for your ASP.NET application; for example, by using the following configuration in the <em>Web.config</em> file: <div><pre>&lt;identity impersonate="false" /&gt;  </pre></div><p><b>Note:</b>&nbsp;By default, impersonation is disabled for all ASP.NET applications.</p><li>Add the following code to the method that requires impersonation. <div><pre>using System.Security.Principal;<br />...<br />// Obtain the authenticated user's Identity<br />WindowsIdentity winId = (WindowsIdentity)HttpContext.Current.User.Identity;<br />WindowsImpersonationContext ctx = null;<br />try<br />&#123;<br />&nbsp; // Start impersonating<br />&nbsp; ctx = winId.Impersonate();<br />&nbsp; // Now impersonating<br />&nbsp; // Access resources using the identity of the authenticated user<br />&#125;<br />// Prevent exceptions from propagating<br />catch<br />&#123;<br />&#125;<br />finally<br />&#123;<br />&nbsp; // Revert impersonation<br />&nbsp; if (ctx &#33;= null)<br />&nbsp;&nbsp;&nbsp; ctx.Undo();<br />&#125;<br />// Back to running under the default ASP.NET process identity  </pre></div><p>This code impersonates the original caller. The original caller's identity is maintained in the <em>HttpContext.Current.User.Identity</em> object. </p></li></li>
  </ol>
  <h2>Exception Handling</h2>
  <p>Notice how the preceding code uses a <em>finally</em> block to ensure that impersonation is reverted even in the event of an exception. The code also uses a <em>catch</em> block to ensure that an exception cannot propagate itself up the call stack while the thread is impersonating.</p>
  <h1>Impersonating by Using LogonUser</h1>
  <p>If your users have Windows domain accounts, but you are using custom authentication, such as forms authentication, IIS does not authenticate the caller and it passes a logon token that represents the anonymous user account to ASP.NET. To impersonate the caller in this instance, you must programmatically create a <em>WindowsIdentity</em> object for the caller, which you can use to impersonate. Create a <em>WindowsIdentity</em> object either by using a logon token returned from the Win32 <em>LogonUser</em> API, or by using the <em>WindowsIdentity(userPrincipalName)</em> constructor that takes a single parameter of a user principal name (UPN).</p>
  <p>You can create a Windows token and associated logon session for a domain or local account by using the Win32 <em>LogonUser</em> API. You must pass the user name and password to this API, together with other parameters including the type of logon session you require.</p>
  <p>
    <b>Note:</b>&nbsp;You should protect the credentials passed to <em>LogonUser</em> by encrypting them.</p>
  <p>You can impersonate with the returned token and check which Windows groups the user is a member of. Whether you can access local resources or network resources depends on the logon session type that you request (you specify the logon session type in the third argument of <em>LogonUser</em>). The most commonly used logon session types when calling this API are the following: </p>
  <ul>
    <li>
      <b>Interactive logon.</b> If you need to access remote resources, request an interactive logon session. This results in a logon session that has network credentials. The user account passed to logon user must be granted the <em>Log on locally</em> user right. <li><b>Network logon:</b> This establishes a logon session with no network credentials. This means you can impersonate the token and access local resources only. The user account passed to logon user must be granted the <em>Access this computer from the network</em> user right. By default, all accounts have this right because it is granted to the <em>Everyone</em> group. </li></li>
  </ul>
  <h3>To check whether you have the Access this computer from the network user right </h3>
  <ol>
    <li>From the <em>Start</em> menu, click <em>Control Panel</em>. <li>Click <em>Administrative Tools</em>. <li>Click <em>Local Security Policy</em>. <li>Expand <em>Local Policies</em> and click <em>User Rights Assignments</em>. <li>Double-click <em>Access this computer from the network</em> to see the user accounts and groups that have this right assigned. If necessary, click the <em>Add User or Group</em> button to add the account you wish to impersonate. </li></li></li></li></li>
  </ol>
  <p>
    <b>Note:</b>&nbsp;The name of the network logon session type sometimes causes confusion. It is called a <i>network</i> logon because it is equivalent to a user accessing the local computer from somewhere else on the network. The resulting logon session does not have network credentials, and therefore cannot be used to access network resources.<b></b></p>
  <p>When you request an interactive logon, <em>LogonUser</em> returns a primary token that allows you to create processes while impersonating. When you request a network logon, <em>LogonUser</em> returns an impersonation token that can be used to access local resources, but not to create processes. If required, you can convert an impersonation token to a primary token by calling the Win32 <em>DuplicateToken</em> function.</p>
  <p>The following example shows how to use the Win32 <em>LogonUser</em> API, construct a <em>WindowsIdentity</em> object from the token, attach the token to the current thread to begin impersonation, and then cancel the impersonation.</p>
  <div>
    <pre>&lt;&#37;&#64; Page Language="C#" &#37;&gt;<br />&lt;&#37;&#64; Import Namespace="System.Security.Principal" &#37;&gt;<br />&lt;&#37;&#64; Import Namespace="System.Runtime.InteropServices" &#37;&gt;<br /><br />&lt;&#33;DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"&gt; <br /><br />&lt;script runat="server"&gt;<br />&nbsp;// Declare signatures for Win32 LogonUser and CloseHandle APIs<br />&nbsp;&#91;DllImport("advapi32.dll", SetLastError = true)&#93;<br />&nbsp;static extern bool LogonUser(<br />&nbsp;&nbsp; string principal,<br />&nbsp;&nbsp; string authority,<br />&nbsp;&nbsp; string password,<br />&nbsp;&nbsp; LogonSessionType logonType,<br />&nbsp;&nbsp; LogonProvider logonProvider,<br />&nbsp;&nbsp; out IntPtr token);<br /><br />&nbsp;  &#91;DllImport("kernel32.dll", SetLastError = true)&#93;<br />&nbsp;  static extern bool CloseHandle(IntPtr handle);<br />&nbsp;&nbsp;&nbsp;enum LogonSessionType : uint<br />&nbsp;&nbsp;&nbsp;&#123;<br />&nbsp;&nbsp;&nbsp;&nbsp; Interactive = 2,<br />&nbsp;&nbsp;&nbsp;&nbsp; Network,<br />&nbsp;&nbsp;&nbsp;&nbsp; Batch,<br />&nbsp;&nbsp;&nbsp;&nbsp; Service,<br />&nbsp;&nbsp;&nbsp;&nbsp; NetworkCleartext = 8,<br />&nbsp;&nbsp;&nbsp;&nbsp; NewCredentials<br />&nbsp;&nbsp; &#125;<br /><br />&nbsp;&nbsp; enum LogonProvider : uint<br />&nbsp;&nbsp;&nbsp;&#123;<br />&nbsp;&nbsp;&nbsp;&nbsp; Default = 0, // default for platform (use this&#33;)<br />&nbsp;&nbsp;&nbsp;&nbsp; WinNT35,&nbsp;&nbsp;&nbsp;&nbsp; // sends smoke signals to authority<br />&nbsp;&nbsp;&nbsp;&nbsp; WinNT40,&nbsp;&nbsp;&nbsp;&nbsp; // uses NTLM<br />&nbsp;&nbsp;&nbsp;&nbsp; WinNT50&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // negotiates Kerb or NTLM<br />&nbsp;&nbsp;&nbsp;&#125;<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;protected void logonUserbtn_Click(object sender, EventArgs e)<br />&nbsp;&nbsp;&nbsp;&#123;<br />&nbsp;&nbsp;&nbsp;&nbsp; IntPtr token = IntPtr.Zero;<br />&nbsp;&nbsp;&nbsp;&nbsp; WindowsImpersonationContext impersonatedUser = null;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp; try<br />&nbsp;&nbsp;&nbsp;&nbsp; &#123;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Create a token for DomainName\Bob<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Note: Credentials should be encrypted in configuration file<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool result = LogonUser("Bob", "DomainName", P&#64;ssw0rd,<br />    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LogonSessionType.Network,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LogonProvider.Default,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out token);<br /><br />&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#123;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WindowsIdentity id = new WindowsIdentity(token);<br /><br />   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Begin impersonation<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; impersonatedUser = id.Impersonate();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Log the new identity<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Response.Write(String.Format(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&lt;/p&gt;Identity after impersonation: &#123;0&#125;&lt;br&gt;",<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WindowsIdentity.GetCurrent().Name));<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Resource access here uses the impersonated identity<br />     &nbsp;&nbsp; &#125;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#123;<br />&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; Response.Write("&lt;/p&gt;LogonUser failed: " &#43;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Marshal.GetLastWin32Error().ToString());<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#123;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Prevent any exceptions that occur while the thread is <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // impersonating from propagating<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finally<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#123;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; // Stop impersonation and revert to the process identity<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (impersonatedUser &#33;= null)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; impersonatedUser.Undo();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Free the token<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (token &#33;= IntPtr.Zero)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CloseHandle(token);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#125;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Verify the old process identity<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Response.Write(String.Format("&lt;/p&gt;Identity after Undo: &#123;0&#125;&lt;br&gt;",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WindowsIdentity.GetCurrent().Name));<br />&nbsp; &#125;<br />&lt;/script&gt;<br /><br />&lt;html&gt;<br />&lt;head runat="server"&gt;<br />&nbsp;&nbsp;&nbsp; &lt;title&gt;LogonUser Test Page&lt;/title&gt;<br />&lt;/head&gt;<br />&lt;body&gt;<br />&nbsp;&nbsp;&nbsp; &lt;form id="form1" runat="server"&gt;<br />&nbsp;&nbsp;&nbsp; &lt;div&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;asp:Button ID="logonUserbtn" runat="server" OnClick="logonUserbtn_Click" Text="LogonUser" /&gt;&lt;/div&gt;<br />&nbsp;&nbsp;&nbsp; &lt;/form&gt;<br />&lt;/body&gt;<br />&lt;/html&gt;  </pre>
  </div>
  <p>The preceding example passes <em>LogonSessionType.Network</em> to <em>LogonUser</em>. This results in a network logon session which has no network credentials. If you need a token and logon session that you can use to access network resources use <em>LogonSessionType.Interactive</em>. </p>
  <p>For clarity, the code example shown above uses literal strings to specify the credentials passed to <em>LogonUser</em>. If you use <em>LogonUser</em>, you should store the credentials that you pass to the method in encrypted format in your <em>Web.config</em> file. Store credentials in the &lt;<em>appSettings</em>&gt; section as shown in the following example, and then use the <em>Aspnet_regiis.exe</em> utility and a protected configuration provider to encrypt this section.</p>
  <div>
    <pre>&lt;appSettings&gt;<br />&nbsp; &lt;add key="ImpIdentity" value="Domainname\Username;secretpassword"/&gt;<br />&lt;/appSettings&gt;  </pre>
  </div>
  <p>The following example shows how to access this configuration data to pass to <em>LogonUser</em>.</p>
  <div>
    <pre>string domain;<br />string username;<br />string password;<br /><br />// Access the &lt;appSettings&gt; value<br />string&#91;&#93; userAndPassword = ((string)ConfigurationManager.AppSettings&#91;"ImpIdentity"&#93;).Split(';');<br /><br />// Parse out the domain, username and password<br />domain = userAndPassword&#91;0&#93;.Substring(0, userAndPassword&#91;0&#93;.IndexOf(&#64;"\"));<br />userName = userAndPassword&#91;0&#93;.Substring(userAndPassword&#91;0&#93;.IndexOf(&#64;"\")&#43;1);<br />password = userAndPassword&#91;1&#93;;<br /><br />// Call LogonUser<br />bool result =<br /> LogonUser(userName, domain, password, LogonSessionTypes.Network,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LogonProviders.Default, out token);</pre>
  </div>
  <h2>Using LogonUser on Windows Server </h2>
  <p>When you use the <em>LogonUser</em> API for impersonation, you do not need to grant your application's process identity the <em>Act as part of the operating system</em> user right.</p>
  <p>On Windows Server, instead of using <em>LogonUser</em>, you can generate a token by using the <em>WindowsIdentity</em> constructor. The advantage of this approach is that you do not have to store credentials on your Web server. The downside is that to get an impersonate-level token to use to access local resources, your process identity requires the <em>Act as part of the operating system</em> user right.</p>
  <h1>Impersonating by Using the WindowsIdentity Constructor</h1>
  <p>One of the overloads for the constructor on the <em>WindowsIdentity</em> class permits you to obtain a Windows token and logon session for a given domain account by supplying a user principal name (UPN). With this approach (shown in the following example), you do not need the account's password.</p>
  <div>
    <pre>using System.Security.Principal;<br />...<br />WindowsIdentity wi = new WindowsIdentity(userName&#64;fullyqualifieddomainName);<br />WindowsImpersonationContext ctx = null;<br />try<br />&#123;<br />&nbsp; ctx = wi.Impersonate();<br />&nbsp; // Thread is now impersonating<br />&#125;<br />catch<br />&#123;<br />&nbsp; // Prevent exceptions propagating.<br />&#125;<br />finally<br />&#123;<br />&nbsp; // Ensure impersonation is reverted<br />&nbsp; ctx.Undo();<br />&#125;  </pre>
  </div>
  <p>This <em>WindowsIdentity</em> constructor relies on a Windows Server extension to the Kerberos protocol called Service for User to Self (S4U2Self). The advantage of this approach is that you do not have to store credentials as you do for <em>LogonUser</em>. However, the disadvantage is that if your code needs to access local resources, you must grant the <em>Act as part of the operating system</em> privilege to your Web application process account to get an impersonation-level token. </p>
  <h3>To grant the Act as part of the operating system privilege </h3>
  <ol>
    <li>On the <em>Start</em> menu, click <em>Control Panel</em>. <li>Click <em>Administrative Tools</em>. <li>Click <em>Local Security Policy</em>. <li>Expand <em>Local Policies</em>, and then click <em>User Rights Assignments</em>. <li>In the right pane, right-click <em>Act as part of the operating system</em>, and then click <em>Properties</em>. <li>Click the <em>Add User or Group</em> button, then enter the account used to run your ASP.NET application (<em>Network Service</em> by default). </li></li></li></li></li></li>
  </ol>
  <h2>Token Types</h2>
  <p>The type of token generated with the S4U2Self extension determines what you can do with the token while impersonating. You can obtain the following token types: </p>
  <ul>
    <li>
      <b>Identify-level token.</b> This is returned by default. With this type of token, you can check to see what groups are contained in the token, but you cannot use it as an impersonation token to access local or remote resources. <li><b>Impersonation-level token.</b> If you grant your process account the "<em>Act as part of the operating system</em>" user right, you get this type of token from the <em>WindowsIdentity</em> constructor. With this type of token, you can impersonate with it and access local resources. <p><b>Note:</b>&nbsp;This places your process within the trusted computing base (TCB) of the Web server, which makes your Web server process very highly privileged. Where possible, you should avoid this approach because an attacker who manages to inject code and compromise your Web application will have almost unrestricted capabilities on the local computer.<b></b></p><li><b>Delegate-level token. </b>If you configure your service or machine account in Active Directory to be trusted for constrained delegation, you will get a token that you can use to access network resources. <p><b>Note:</b>&nbsp;You will typically need TCB when accessing a remote service. For local resources, the TCB privilege controls access. For remote service access, TCB is not required, but an identify-level token will usually be insufficient. Therefore, you will need TCB to generate an identify-level token. For example, if you use ADO.NET to communicate with a remote SQL Server database, the call will fail before it leaves the Web server due to the local resources such as performance counters (and therefore registry keys) that the SQL Server managed data provider needs to access.</p></li></li></li>
  </ul>
  <h2>Impersonating a Fixed Identity</h2>
  <p>If you need to impersonate the same identity throughout the lifetime of your application, you can specify credentials on the &lt;<em>identity</em>&gt; element in your <em>Web.config</em> file. The following example shows how to impersonate a Windows account with the name <em>TestUser</em>.</p>
  <div>
    <pre>&lt;identity impersonate="true" username="TestUser" password="P&#64;ssw0rd" /&gt;  </pre>
  </div>
  <p>If you use this approach, you should encrypt the credentials.&nbsp;You can use&nbsp;the&nbsp;ASP.NET <em>Aspnet_regiis.exe</em> tool. </p>
  <p>
    <b>To encrypt the </b>&lt;<b>identity</b>&gt;<b> element by using Aspnet_regiis</b></p>
  <ul>
    <li>Run the following command to encrypt the &lt;<em>identity</em>&gt; element in the <em>Web.config</em> file. <pre>aspnet_regiis -pef "system.web/identity" " C:\Sites\IntranetSite" </pre></li>
  </ul>
  <p>
    <b>To decrypt the </b>&lt;<b>identity</b>&gt;<b> element</b></p>
  <ul>
    <li>Run the following command to revert the &lt;<em>identity</em>&gt; element to plain text. <pre>aspnet_regiis -pdf "system.web/identity" " C:/Sites/IntranetSite " </pre></li>
  </ul>
  <p>Note that the above commands use the default protected configuration provider named, which uses RSA encryption. To choose an alternative provider, add the <em>-prov</em> option naming the required provider. If your application runs in a Web farm, you should generally use the RSA provider.&nbsp; </p>
  <h2>Using Fixed Identities on Windows Server </h2>
  <p>You can configure credentials on the &lt;<em>identity</em>&gt; element on Windows Server to use a fixed identity for resource access on ASP.NET applications. However, if you are running with IIS&nbsp;configured to run in worker isolation mode (the default), you can avoid impersonation by configuring your ASP.NET application to run in a custom application pool that runs under a specific domain identity.</p>
  <h3>Delegation</h3>
  <p>To obtain an impersonation token so that you can access network resources, you have a number of options. </p>
  <ul>
    <li>
      <b>Use Kerberos authentication and delegation.</b> If you use Kerberos to authenticate your users, you can impersonate the original caller by using the techniques described in the sections "<em>Impersonating the Original Caller</em>" and "<em>Impersonating the Original Caller Temporarily</em>" and use Kerberos delegation to gain access to network resources. To do so: <ul><li>If your application runs under the <em>Network Service</em> account, you need to configure your computer account in Active Directory to be trusted for delegation. <li>If your application runs under a custom domain account, you need to configure your domain account in Active Directory to be trusted for delegation. You must also register a service principal name in Active Directory to associate the domain account with the HTTP service on your Web server. </li></li></ul><p>If you use domain accounts to run your Web application or the downstream service that you are accessing, you must also ensure that appropriate service principal names (SPNs) are created in Active Directory for those accounts.&nbsp; </p><li><b>Call LogonUser and request an Interactive logon session.</b> An interactive logon session has network credentials that allow you to authenticate against network servers. Use this approach when you cannot use Kerberos authentication to authenticate your users, and when you cannot use protocol transition. <p>Note that you must have access to both the user name and password to call <em>LogonUser</em>. You can only use the token to access network resources over a single hop, whereas Kerberos delegation allows the impersonated identity to flow across multiple tiers. </p><li><b>Use protocol transition. </b>With this approach, you use a non-Kerberos authentication mechanism to authenticate your users, and then use the new <em>WindowsIdentity</em> constructor to obtain a Windows token for the user on the server. Use this approach when you cannot use Kerberos authentication to authenticate your users, for example because they connect to your application over the Internet, but your users do have Windows domain accounts. To get a delegate-level token with this approach, you must be running on a Windows Server 2003 and you need to configure your computer or process account in Active Directory as trusted for delegation and protocol transition.&nbsp; <li><b>Use basic authentication and impersonation.</b> With basic authentication, the user name and password of the user are available in clear text on the server. When IIS authenticates a caller by using basic authentication, it creates a token that contains these credentials. The token can be used for network access. As result, if you configure your application to impersonate the original caller by using the &lt;<em>identity</em>&gt; element or impersonate programmatically by using <em>WindowsIdentity.Impersonate</em>, you can access network resources while impersonating. <p>Use basic authentication if you cannot use Kerberos authentication and delegation, and you cannot use <em>LogonUser</em> or protocol transition. For example, if you configure IIS to use integrated Windows authentication, it will use Kerberos authentication if possible, but otherwise default to NTLM authentication&#8212;which does not allow access to network resources with an impersonated identity. However, with basic authentication, the user's credentials pass through the network in clear text. Therefore, you should be sure that all network connections are secured with SSL or IPSEC. </p></li></li></li></li>
  </ul>
  <h1>Impersonation / Delegation vs. Trusted Subsystem</h1>
  <p>When you design the authentication that you require in your application, consider whether to use impersonation to use the original caller's identity for access to back-end resources, or whether to use the trusted subsystem model, where the Web or application server is responsible for authenticating users and the server then uses a service identity to access back-end resources. The two techniques have different advantages and disadvantages as explained in the following subsections.</p>
  <h2>Trusted Subsystem</h2>
  <p>A trusted subsystem model is where the database server trusts the Web application identity. The Web application identity is trusted to make calls on behalf of the original caller. (See Figure 3.)</p>
  <p>
    <img alt="" src="http://msdn2.microsoft.com/en-us/library/ms998351.trustedsubsystemmodel(en-us,MSDN.10).gif" border="0" />
  </p>
  <p>
    <b>Figure 3. Trusted subsystem model</b>
  </p>
  <h3>Trusted Subsystem Advantages</h3>
  <p>The advantages of the trusted subsystem model include: </p>
  <ul>
    <li>
      <b>Scalability.</b> The trusted subsystem model supports efficient connection pooling. Connection pooling allows multiple clients to reuse available pooled connections. Connection pooling works with this model because all back-end resources accessed use the security context of the application's service account, regardless of the caller's identity. <li><b>Minimal back-end ACL management.</b> Only the service account accesses back-end resources (for example, databases). ACLs are configured for this single identity. <li><b>No direct data access.</b> In the trusted subsystem model, only the service account is granted access to the back-end resources. As a result, users cannot directly access back-end data without going through the application (and being subjected to application authorization). </li></li></li>
  </ul>
  <h3>Trusted Subsystem Disadvantages</h3>
  <p>The trusted subsystem model has the following disadvantages: </p>
  <ul>
    <li>
      <b>Auditing.</b> To perform auditing at the back end, you can explicitly pass (at the application level) the identity of the original caller to the back end, and have the auditing performed there. With this approach, you have to trust the middle tier and you have a potential repudiation risk. Alternatively, you can generate an audit trail in the middle tier, and then correlate it with back-end audit trails. To use this approach, you must ensure that the server clocks are synchronized. <li><b>Increased risk from server compromise.</b> In the trusted subsystem model, the middle-tier service is granted broad access to back-end resources. As a result, a compromised middle-tier service could make it easier for an attacker to gain broad access to back-end resources. </li></li>
  </ul>
  <h2>Impersonation / Delegation</h2>
  <p>The impersonation and delegation model also has advantages and disadvantages.</p>
  <h3>Impersonation / Delegation Advantages</h3>
  <p>The advantages of the impersonation / delegation model include: </p>
  <ul>
    <li>
      <b>Auditing.</b> You<b></b>benefit from operating system auditing. This allows administrators to track which users have attempted to access specific resources. <li><b>Auditing across tiers.</b> The user's security context is maintained across the physical tiers of your application, which allows administrators to audit across tiers. Generally, auditing is considered most authoritative if the audits are generated at the precise time of resource access and by the same routines that access the resource. <li><b>Granular access controls.</b> You can configure granular access in the database. You can restrict individual user accounts independently of one another in the database. </li></li></li>
  </ul>
  <h3>Impersonation / Delegation Disadvantages</h3>
  <p>The disadvantages of the impersonation / delegation model include: </p>
  <ul>
    <li>
      <b>Scalability. </b>The impersonation / delegation model does not allow you to make efficient use of database connection pooling because database access is performed by using connections that are tied to the individual security contexts of the original callers. This significantly limits the application's ability to scale to large numbers of users. <li><b>Increased administration effort.</b> ACLs on back-end resources need to be maintained in such a way that each user is granted the appropriate level of access. When the number of back-end resources increases (and the number of users increases), a significant administration effort is required to manage ACLs. </li></li>
  </ul>
  <h1>Delegation Table</h1>
  <p>The IIS authentication type that you use affects whether or not you can impersonate the original caller and use the impersonation token to access network resources. To do so requires delegation. Table 1 shows the various IIS authentication types and whether or not you can impersonate the caller to access network resources.</p>
  <p>
    <b>Table 1: IIS Authentication Types and Delegation Capability</b>
  </p>
  <div>
    <table>
      <tbody>
        <tr>
          <th>Authentication Type</th>
          <th>Can Delegate</th>
          <th>Notes</th>
        </tr>
        <tr>
          <td>Anonymous</td>
          <td>Depends</td>
          <td>If the anonymous account (by default IUSR_MACHINE) is configured in IIS as a local account, it cannot be delegated unless the local (Web server) and remote computer have identical local accounts (with matching user names and passwords). <br />If the anonymous account is a domain account it can be delegated.</td>
        </tr>
        <tr>
          <td>Basic</td>
          <td>Yes</td>
          <td>If Basic authentication is used with local accounts, it can be delegated if the local accounts on the local and remote computers are identical. Domain accounts can also be delegated.</td>
        </tr>
        <tr>
          <td>Digest</td>
          <td>No</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>Integrated Windows</td>
          <td>Depends</td>
          <td>Integrated Windows authentication either results in NTLM or Kerberos (depending upon the version of operating system on client and server computer).<br />NTLM does not support delegation.<br />Kerberos supports delegation with the appropriate Active Directory configuration.</td>
        </tr>
        <tr>
          <td>Client Certificates</td>
          <td>Depends</td>
          <td>Can be delegated if used with IIS certificate mapping and the certificate is mapped to a local account that is duplicated on the remote computer or is mapped to a domain account. This works because the credentials for the mapped account are stored on the local server and are used to create an Interactive logon session (which has network credentials).<br />Active Directory certificate mapping does not support delegation.</td>
        </tr>
      </tbody>
    </table>
  </div>
  <hr />
  <p>Adapted from Microsoft patterns & practices guidance.</p>