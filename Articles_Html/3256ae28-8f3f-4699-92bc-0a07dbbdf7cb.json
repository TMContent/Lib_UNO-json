{
  "id": "3256ae28-8f3f-4699-92bc-0a07dbbdf7cb",
  "checksum": "fc09b77b1be2805ee188a6a250a9f983c2bb1012",
  "words": {
    "applies": [
      "h1"
    ],
    "to": [
      "h1",
      "h1",
      "p",
      "p",
      "p",
      "ul",
      "ul",
      "ul",
      "ul",
      "li",
      "p",
      "li",
      "p",
      "li",
      "li",
      "p",
      "p",
      "p"
    ],
    "c++": [
      "ul",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "what": [
      "h1"
    ],
    "do": [
      "h1"
    ],
    "use": [
      "p",
      "p",
      "p",
      "ul",
      "li",
      "p"
    ],
    "type-casts": [
      "p",
      "p",
      "p",
      "p"
    ],
    "instead": [
      "p",
      "p"
    ],
    "of": [
      "p",
      "p",
      "ul",
      "ul",
      "li",
      "p",
      "li",
      "p"
    ],
    "c": [
      "p"
    ],
    "why": [
      "h1"
    ],
    "supports": [
      "p"
    ],
    "c-style": [
      "p",
      "p",
      "title"
    ],
    "casts": [
      "p",
      "p",
      "p",
      "ul",
      "li",
      "p",
      "p",
      "p",
      "p",
      "title"
    ],
    "and": [
      "p",
      "p"
    ],
    "introduces": [
      "p"
    ],
    "its": [
      "p"
    ],
    "own": [
      "p"
    ],
    "safer": [
      "p",
      "p"
    ],
    "the": [
      "p",
      "p",
      "ul",
      "ul",
      "ul",
      "ul",
      "li",
      "p",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p"
    ],
    "new": [
      "p"
    ],
    "style": [
      "p",
      "p"
    ],
    "are": [
      "p",
      "p",
      "ul",
      "li",
      "p",
      "p"
    ],
    "because": [
      "p",
      "ul",
      "ul",
      "li",
      "p",
      "li",
      "p"
    ],
    "they": [
      "p"
    ],
    "allow": [
      "p"
    ],
    "compiler": [
      "p",
      "ul",
      "ul",
      "li",
      "p",
      "li",
      "p"
    ],
    "better": [
      "p"
    ],
    "detect": [
      "p"
    ],
    "dangerous": [
      "p"
    ],
    "type-casting": [
      "p"
    ],
    "how": [
      "h1"
    ],
    "change": [
      "p"
    ],
    "code": [
      "p",
      "ul",
      "li",
      "p"
    ],
    "there": [
      "p",
      "ul",
      "li",
      "p"
    ],
    "several": [
      "p"
    ],
    "type-cast": [
      "p",
      "ul",
      "li",
      "p"
    ],
    "options": [
      "p"
    ],
    "in": [
      "p",
      "ul",
      "li",
      "p",
      "p"
    ],
    "reinterpret_casttype>(expression).": [
      "ul",
      "li",
      "p",
      "strong"
    ],
    "a": [
      "ul",
      "ul",
      "ul",
      "ul",
      "ul",
      "ul",
      "ul",
      "ul",
      "li",
      "p",
      "li",
      "p",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p"
    ],
    "reinterpret_cast": [
      "ul",
      "ul",
      "li",
      "li",
      "p",
      "p"
    ],
    "provides": [
      "ul",
      "ul",
      "ul",
      "li",
      "p",
      "li",
      "p",
      "li",
      "p"
    ],
    "no": [
      "ul",
      "li",
      "p"
    ],
    "additional": [
      "ul",
      "ul",
      "li",
      "li",
      "p",
      "p"
    ],
    "security": [
      "ul",
      "ul",
      "ul",
      "li",
      "p",
      "li",
      "p",
      "li",
      "p"
    ],
    "it": [
      "ul",
      "ul",
      "ul",
      "li",
      "li",
      "p",
      "p",
      "li",
      "p"
    ],
    "can": [
      "ul",
      "li",
      "p"
    ],
    "convert": [
      "ul",
      "li",
      "p"
    ],
    "an": [
      "ul",
      "ul",
      "ul",
      "ul",
      "ul",
      "ul",
      "li",
      "li",
      "p",
      "p",
      "li",
      "li",
      "p",
      "p",
      "li",
      "li",
      "p",
      "p"
    ],
    "object": [
      "ul",
      "ul",
      "ul",
      "li",
      "li",
      "p",
      "p",
      "li",
      "p"
    ],
    "from": [
      "ul",
      "li",
      "p"
    ],
    "one": [
      "ul",
      "li",
      "p"
    ],
    "type": [
      "ul",
      "ul",
      "ul",
      "ul",
      "li",
      "li",
      "p",
      "p",
      "li",
      "li",
      "p",
      "p",
      "title"
    ],
    "another": [
      "ul",
      "li",
      "p"
    ],
    "without": [
      "ul",
      "li",
      "p"
    ],
    "any": [
      "ul",
      "li",
      "p"
    ],
    "checks": [
      "ul",
      "ul",
      "li",
      "p",
      "li",
      "p"
    ],
    "avoid": [
      "ul",
      "li",
      "p",
      "title"
    ],
    "using": [
      "ul",
      "li",
      "p",
      "title"
    ],
    "unless": [
      "ul",
      "li",
      "p"
    ],
    "is": [
      "ul",
      "ul",
      "ul",
      "li",
      "p",
      "li",
      "p",
      "li",
      "p"
    ],
    "absolutely": [
      "ul",
      "li",
      "p"
    ],
    "necessary": [
      "ul",
      "li",
      "p"
    ],
    "static_casttype>(expression).": [
      "ul",
      "li",
      "p",
      "strong"
    ],
    "static": [
      "ul",
      "li",
      "p",
      "p",
      "p"
    ],
    "cast": [
      "ul",
      "ul",
      "li",
      "li",
      "p",
      "p"
    ],
    "some": [
      "ul",
      "li",
      "p"
    ],
    "that": [
      "ul",
      "ul",
      "li",
      "p",
      "li",
      "p"
    ],
    "will": [
      "ul",
      "li",
      "p"
    ],
    "issue": [
      "ul",
      "li",
      "p"
    ],
    "error": [
      "ul",
      "li",
      "p"
    ],
    "if": [
      "ul",
      "li",
      "p"
    ],
    "invalid": [
      "ul",
      "li",
      "p"
    ],
    "attempted": [
      "ul",
      "li",
      "p"
    ],
    "not": [
      "ul",
      "li",
      "p"
    ],
    "all": [
      "ul",
      "li",
      "p"
    ],
    "valid": [
      "ul",
      "li",
      "p"
    ],
    "safe": [
      "ul",
      "li",
      "p"
    ],
    "however": [
      "ul",
      "li",
      "p"
    ],
    "dynamic_casttype>(expression).": [
      "ul",
      "li",
      "p",
      "strong"
    ],
    "dynamic_cast": [
      "ul",
      "ul",
      "ul",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p"
    ],
    "highest": [
      "ul",
      "li",
      "p"
    ],
    "degree": [
      "ul",
      "li",
      "p"
    ],
    "causes": [
      "ul",
      "li",
      "p"
    ],
    "insert": [
      "ul",
      "li",
      "p"
    ],
    "at": [
      "ul",
      "li",
      "p"
    ],
    "run-time": [
      "ul",
      "li",
      "p"
    ],
    "when": [
      "ul",
      "ul",
      "li",
      "li",
      "p",
      "p"
    ],
    "converting": [
      "ul",
      "ul",
      "li",
      "li",
      "p",
      "p"
    ],
    "incompatible": [
      "ul",
      "ul",
      "li",
      "li",
      "p",
      "p"
    ],
    "pointer": [
      "ul",
      "ul",
      "li",
      "li",
      "p",
      "p"
    ],
    "returns": [
      "ul",
      "li",
      "p"
    ],
    "null": [
      "ul",
      "li",
      "p"
    ],
    "throws": [
      "ul",
      "li",
      "p"
    ],
    "std:bad_cast": [
      "ul",
      "li",
      "p"
    ],
    "exception": [
      "ul",
      "li",
      "p"
    ],
    "const_casttype>(expression).": [
      "ul",
      "li",
      "p",
      "strong"
    ],
    "const_cast": [
      "ul",
      "ul",
      "li",
      "li",
      "p",
      "p"
    ],
    "used": [
      "ul",
      "li",
      "p",
      "p"
    ],
    "make": [
      "ul",
      "li",
      "p"
    ],
    "constant": [
      "ul",
      "li",
      "p"
    ],
    "variable": [
      "ul",
      "li",
      "p"
    ],
    "mutable": [
      "ul",
      "li",
      "p"
    ],
    "should": [
      "ul",
      "li",
      "p",
      "p"
    ],
    "hardly": [
      "ul",
      "li",
      "p"
    ],
    "ever": [
      "ul",
      "li",
      "p"
    ],
    "be": [
      "ul",
      "li",
      "p",
      "p"
    ],
    "need": [
      "ul",
      "li",
      "p"
    ],
    "most": [
      "p"
    ],
    "situations": [
      "p"
    ],
    "dynamic": [
      "p",
      "p"
    ],
    "generally": [
      "p"
    ],
    "preferred": [
      "p"
    ]
  },
  "tags": {
    "h1": [
      "Applies to",
      "What to Do",
      "Why",
      "How"
    ],
    "ul": [
      "C++",
      "reinterpret_cast<type>(expression). A reinterpret_cast provides no additional security, because it can convert an object from one type to an object of another type without any additional checks. Avoid using reinterpret_cast unless it is absolutely necessary.\r\n      \r\n        \r\n          static_cast<type>(expression). A static cast provides some security in that the compiler will issue an error if an invalid cast is attempted. Not all valid casts are safe, however.\r\n        \r\n          \r\n            dynamic_cast<type>(expression). A dynamic_cast provides the highest degree of security, because it causes the compiler to insert code that checks the type-cast at run-time. When converting an incompatible pointer type, dynamic_cast returns a null pointer. When converting an incompatible object type, dynamic_cast throws a std::bad_cast exception.\r\n          \r\n            \r\n              const_cast<type>(expression). A const_cast is used to make constant variable mutable. There should hardly ever be a need to use a const_cast."
    ],
    "li": [
      "C++",
      "reinterpret_cast<type>(expression). A reinterpret_cast provides no additional security, because it can convert an object from one type to an object of another type without any additional checks. Avoid using reinterpret_cast unless it is absolutely necessary.",
      "static_cast<type>(expression). A static cast provides some security in that the compiler will issue an error if an invalid cast is attempted. Not all valid casts are safe, however.",
      "dynamic_cast<type>(expression). A dynamic_cast provides the highest degree of security, because it causes the compiler to insert code that checks the type-cast at run-time. When converting an incompatible pointer type, dynamic_cast returns a null pointer. When converting an incompatible object type, dynamic_cast throws a std::bad_cast exception.",
      "const_cast<type>(expression). A const_cast is used to make constant variable mutable. There should hardly ever be a need to use a const_cast."
    ],
    "p": [
      "Use C++ type-casts instead of C type-casts.",
      "C++ supports C-style casts and introduces its own, safer type-casts. The new C++ style type-casts are safer to use because they allow the compiler to better detect dangerous type-casting.",
      "Change code to use C++ style casts instead of C-style casts. There are several type-cast options in C++:",
      "reinterpret_cast<type>(expression). A reinterpret_cast provides no additional security, because it can convert an object from one type to an object of another type without any additional checks. Avoid using reinterpret_cast unless it is absolutely necessary.",
      "static_cast<type>(expression). A static cast provides some security in that the compiler will issue an error if an invalid cast is attempted. Not all valid casts are safe, however.",
      "dynamic_cast<type>(expression). A dynamic_cast provides the highest degree of security, because it causes the compiler to insert code that checks the type-cast at run-time. When converting an incompatible pointer type, dynamic_cast returns a null pointer. When converting an incompatible object type, dynamic_cast throws a std::bad_cast exception.",
      "const_cast<type>(expression). A const_cast is used to make constant variable mutable. There should hardly ever be a need to use a const_cast.",
      "In most situations, static and dynamic casts should be used. Dynamic casts are generally preferred to static casts."
    ],
    "strong": [
      "reinterpret_cast<type>(expression).",
      "static_cast<type>(expression).",
      "dynamic_cast<type>(expression).",
      "const_cast<type>(expression)."
    ]
  },
  "links": [],
  "html": "<h1>Applies to</h1>\r\n  <ul>\r\n    <li>C&#43;&#43;</li>\r\n  </ul>\r\n  <h1>What to Do</h1>\r\n  <p>Use C&#43;&#43; type-casts instead of C type-casts.</p>\r\n  <h1>Why</h1>\r\n  <p>C&#43;&#43; supports C-style casts and introduces its own, safer type-casts. The new C&#43;&#43; style type-casts are safer to use because they allow the compiler to better detect dangerous type-casting.</p>\r\n  <h1>How</h1>\r\n  <p>Change code to use C&#43;&#43; style casts instead of C-style casts. There are several type-cast options in C&#43;&#43;:</p>\r\n  <ul>\r\n    <li>\r\n      <p>\r\n        <strong>reinterpret_cast&lt;type&gt;(expression).</strong> A reinterpret_cast provides no additional security, because it can convert an object from one type to an object of another type without any additional checks. Avoid using reinterpret_cast unless it is absolutely necessary.</p>\r\n      <li>\r\n        <p>\r\n          <strong>static_cast&lt;type&gt;(expression).</strong> A static cast provides some security in that the compiler will issue an error if an invalid cast is attempted. Not all valid casts are safe, however.</p>\r\n        <li>\r\n          <p>\r\n            <strong>dynamic_cast&lt;type&gt;(expression).</strong> A dynamic_cast provides the highest degree of security, because it causes the compiler to insert code that checks the type-cast at run-time. When converting an incompatible pointer type, dynamic_cast returns a null pointer. When converting an incompatible object type, dynamic_cast throws a std::bad_cast exception.</p>\r\n          <li>\r\n            <p>\r\n              <strong>const_cast&lt;type&gt;(expression).</strong> A const_cast is used to make constant variable mutable. There should hardly ever be a need to use a const_cast.</p>\r\n          </li>\r\n        </li>\r\n      </li>\r\n    </li>\r\n  </ul>\r\n  <p>In most situations, static and dynamic casts should be used. Dynamic casts are generally preferred to static casts.</p>"
}