<h2>Applies To</h2>
<ul>
<li>C++</li>
<li>Windows</li>
</ul>
<h2>What to Do</h2>
<p>Create files safely.</p>
<h2>Why</h2>
<p>Allowing user input in the lpFileName parameter of CreateFile() can lead to the creation or opening of unexpected objects.</p>
<h2>When</h2>
<p>Apply this guideline whenever creating files programmatically on Windows systems.</p>
<h2>How</h2>
<p>Perform the following actions to assure that files are created safely on Windows:</p>
<ol>
<li>
<p><strong>Review code.</strong> Search for all calls to the CreateFile() function.</p>
</li>
<li>
<p><strong>Validate file handles.</strong> Use GetFileType() to ensure that you are creating a file instead of some other unexpected object. By calling GetFileType on hfile (the return value of CreateFile()), you can ensure that only a file is created.</p>
</li>
</ol>
<h2>Problem Example</h2>
<p>In the code example below, the code is calling CreateFile and passing a command line argument (argv[1]) into the lpFileName parameter. A malicious attacker can exploit this code to force your application to open an unexpected object other than a file.</p>
<pre><code>int main(int argc, char *argv[])
{
    HANDLE hFile = CreateFile(
      argv[1],
      GENERIC_READ | GENERIC_WRITE,
      NULL,
      NULL,
      CREATE_ALWAYS,
      FILE_ATTRIBUTE_NORMAL,
      NULL);
}
</code></pre>
<h2>Solution Example</h2>
<p>Use GetFileType() to ensure that you are creating a file instead of some other unexpected object.</p>
<pre><code>int main(int argc, char *argv[])
{
    HANDLE hFile = CreateFile(
      argv[1],
      GENERIC_READ | GENERIC_WRITE,
      NULL,
      NULL,
      CREATE_ALWAYS,
      FILE_ATTRIBUTE_NORMAL,
      NULL);
   if (GetFileType(hFile) != FILE_TYPE_DISK)
   {
  // Error Handling
  CloseHandle(hFile);
   }
}
</code></pre>
