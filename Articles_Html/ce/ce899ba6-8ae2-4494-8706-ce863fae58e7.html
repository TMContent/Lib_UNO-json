<h1>What to Do</h1>
  <p>Carefully validate use supplied filename and path to ensure correct format and validity of location within the context of the application</p>
  <h1>Why</h1>
  <p>Filtering paths and filenames helps to avoid a Canonicalization Attack where your application may be caused to read or write to arbitrary files on the server.</p>
  <h1>When</h1>
  <p>Whenever the user input used as a filename or path component for a file or similar resource on the server is received.</p>
  <h1>How</h1>
  <p>Whenever possible, user supplied input should not be used as a component of any filename or path. When storing files supplied by a user, keep the user-provided filename in a database and store the file on disk under a GUID. Likewise, do not allow users to specify details about which files to access unless absolutely necessary. When you must allow a user to specify part of a filename or path, the following three methods should be used to ensure safe handling of user supplied paths and filenames:</p>
  <ol>
    <li>
      <p>
        <strong>Validate file paths and names</strong>: to avoid canonicalization bugs, canonicalize the file name by using the System.IO.Path.GetFullPath method.</p>
    </li>
    <li>
      <p>
        <strong>Use MapPath to prevent cross application mapping</strong>: When using <strong>MapPath</strong> to map a supplied virtual path to a physical path on the server, use the overload of Request.MapPath that accepts a bool parameter so that you can prevent cross-application mapping. In the sample below the final <strong>false</strong> parameter prevents cross-application mapping. This means that a user cannot successfully supply a path that contains ".." to traverse outside of your application's virtual directory hierarchy. Any attempt to do this results in an exception:</p>
    </li>
    <li>
      <p>
        <strong>Use Code Access Security to restrict File IO</strong>: You can configure all the file operations by the web-application to be restricted to its own virtual directory. This is done by configuring the application to run with Medium trust, you can do this by setting the <strong>&lt;trust&gt;</strong> element in Web.config or Machine.config as follows:</p>
      <pre> &lt;trust level="Medium" /&gt;</pre>
      <p>Running applications successfully in <strong>Medium trust</strong> requires appropriate design and development techniques. </p>
    </li>
  </ol>
  <h1>Problem Example</h1>
  <p>In the following code example, the server receives a file name from the user. The server appends the user supplied filename to the a hardcoded path and verifies to see if this file exists on the server. If the file exists, the server opens the file and performs operations on it.</p>
  <blockquote>
    <pre>&lt;%@ Page Language="C#" ValidateRequest="false" %&gt;<br /> &lt;script runat="server"&gt;<br />   void submitBtn_Click(object sender, EventArgs e)<br />   {<br />       String fileName = "c:\\configfiles\\" + inputPath.Text;<br />       if (System.IO.File.Exists (fileName))<br />       {<br />            System.IO.FileStream fs = System.IO.File.Open(fileName, System.IO.FileMode.Open);<br />       }<br />   }<br /> &lt;/script&gt;<br /> &lt;html xmlns="http://www.w3.org/1999/xhtml/Overview.html"&gt;<br />   &lt;body&gt;<br />     &lt;form id="form1" runat="server"&gt;<br />       &lt;div&gt;<br />         &lt;asp:TextBox ID="inputPath" Runat="server"<br />               TextMode="MultiLine" Width="382px" Height="152px"&gt;<br />         &lt;/asp:TextBox&gt;<br />         &lt;asp:Button ID="submitBtn" Runat="server" Text="Submit"<br />                      OnClick="submitBtn_Click" /&gt;<br />       &lt;/div&gt;<br />     &lt;/form&gt;<br />   &lt;/body&gt;<br /> &lt;/html&gt;</pre>
  </blockquote>
  <p>Here one can clearly notice that the intention of the developer is to limit access to the <strong>C:\ConfigFiles</strong> folder. However, if a user supplied the input "..\windows\system32\critical.ini" then the application will readily join the user supplied input with the hardcoded path and give the attacker access to critical system files.</p>
  <h1>Solution Example</h1>
  <p>The server side code of this application is now updated to use the GetFullPath method:</p>
  <blockquote>
    <pre> &lt;script runat="server"&gt;<br />   void submitBtn_Click(object sender, EventArgs e)<br />   {<br />       String fileName = "c:\\configfiles\\" + inputPath.Text;<br />       fileName = System.IO.Path.GetFullPath(fileName).ToLower();<br />       if (fileName.StartsWith("c:\\configfiles") &amp;&amp;<br />            System.IO.File.Exists (fileName))<br />       {<br />            System.IO.FileStream fs = System.IO.File.Open(fileName, System.IO.FileMode.Open);<br />       }<br />   }<br /> &lt;/script&gt;</pre>
  </blockquote>
  <p>Now, the website calls GetFullPath and then verifies that the file name is indeed pointing to somewhere within the C:\ConfigFiles\ folder.</p>
  <br />
  <hr />
  <p>Adapted from Microsoft patterns &amp; practices guidance. </p>