<h2>Applies To</h2>
<ul>
<li>C++</li>
<li>Linux</li>
<li>Windows</li>
<li>Embedded Systems</li>
</ul>
<h2>What to Do</h2>
<p>Review, and rewrite if necessary, all the functions that throw exceptions to ensure that cleanup code is executed in object destructors.</p>
<p>In languages like Java and C# there is a special <code>finally</code> block with guaranteed execution immediately before function exit, regardless of whether an exception was thrown or not. In C++, it is the developer’s responsibility to ensure proper local cleanup.</p>
<h2>Why</h2>
<p>Unlike Java or C#, where an object destructor is called only by a garbage collector, and therefore cannot be used by the developer, in C++ the object destructor is called when the object goes out of scope. An object going out of scope happens either when the function returns or when an exception is thrown. Variables located on the function stack are called automatic variables because they are initialized at function entry and automatically destroyed at function exit. The developer can use this feature by putting code responsible for resource release in the object destructor. In this case, no matter what, the resources will be cleaned up upon function exit. The most useful technique for this in C++ is called &quot;Resource Acquisition Is Initialization (RAII)&quot;, when initialization is performed in an object constructor and cleanup in the destructor.</p>
<h2>When</h2>
<p>Always perform proper cleanup of local resources before function exit. Pay extra attention in a situation when the function throws an exception and regular call flow is disrupted.</p>
<h2>How</h2>
<p>To implement local cleanup for error handling code:</p>
<ol>
<li>
<p><strong>Review the application code</strong>. Review the application code and find all places where exceptions are thrown. Ensure that all functions that could throw exceptions are called within a try – catch {} block. Don’t leave uncaught exceptions. Doing so could lead to unexpected process termination.</p>
</li>
<li>
<p><strong>Release all allocated memory</strong>. Release all the memory allocated during function execution that is not shared with other application modules. If memory was allocated with C <code>…alloc()</code> family methods, use <code>free()</code> to deallocate it. For C++ style <code>new</code> and <code>new[]</code> operators, use the corresponding <code>delete</code> and <code>delete[]</code> operators. Never mix C functions and C++ operators.</p>
</li>
<li>
<p><strong>Release all acquired locks</strong>. Release all the locks acquired during function execution. If locks are not released in a timely fashion, multi-threaded applications could easily run into a deadlock situation, where application reset, or even whole device reset, is the only option.</p>
</li>
<li>
<p><strong>Close all files and database connections</strong>. Close all the open files and database connections that are no longer needed by the application upon function exit. Files and database connections left opened consume system memory and, especially on embedded devices with limited memory, could exhaust all system resources. Additionally, file handles that are not closed may prevent other processes or users from working with these files.</p>
</li>
<li>
<p><strong>Identify all local resources acquired or initialized in a function</strong>. These resources could be memory pointers, opened files, database or network connections, acquired locks, and other resources that require explicit calls to clean, close, release, or have other actions be performed before object destruction.</p>
</li>
<li>
<p><strong>Use STL special helper classes for automatic cleanup</strong>. The C++ STL library provides several utility classes for automated memory and lock release, like <code>unique_ptr</code>, <code>shared_ptr</code>, and <code>lock_guard</code>.</p>
</li>
<li>
<p><strong>Use object destructors</strong>. For other objects, when possible re-write destructors of identified object classes in such a way that ensures that proper cleanup code is executed during object destruction. If there is a chance that cleanup code in the destructor may throw an exception, always enclose it in try – catch {} block.</p>
</li>
<li>
<p><strong>Use object wrappers</strong>. If re-writing is not possible, for example for third party classes and libraries, define a special automatic cleanup helper class. In the constructor, provide as a parameter a reference to the object that needs to be cleaned up or closed. Save this reference as a helper object attribute. Put all the code related to object cleanup in a helper class destructor.</p>
</li>
</ol>
