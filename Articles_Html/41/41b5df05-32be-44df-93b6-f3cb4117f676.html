<h2>Applies To</h2>
<ul>
<li>C++</li>
</ul>
<h2>What to Do</h2>
<p>Use locks with mutexes, instead of manual locking and unlocking.</p>
<h2>Why</h2>
<p>Using std::lock_guard makes it simpler to prevent deadlocks, because it unlocks mutexes automaticaly when a function exits.</p>
<h2>How</h2>
<p>Perform the following actions to use locks with mutexes:</p>
<ol>
<li>
<p><strong>Identify unsafe code.</strong> Search for code that manually locks and unlocks mutexes by calling <code>lock()</code> and <code>unlock()</code> functions.</p>
</li>
<li>
<p><strong>Add locks.</strong> Add locks to functions that manually <code>lock()</code> and <code>unlock()</code> mutexes by declaring them in a manner such as <code>const std::lock_guard&lt;std::mutex&gt;(mutex);</code></p>
</li>
<li>
<p><strong>Remove old code.</strong> Remove calls to <code>lock()</code> and <code>unlock()</code> from the functions where a lock is now being used.</p>
</li>
</ol>
<h2>Solution Example</h2>
<p>In the following example, a lock is being used with the mutex. Notice that nothing else is necessary to assure concurrency when using a lock.</p>
<pre><code>static std::mutex mutex;

void function(){

const std::lock_guard&lt;std::mutex&gt;(mutex);

//do stuff
}
</code></pre>
<h2>Additional Resources</h2>
<ul>
<li>For more information about using locks with mutexes, see <a href="https://www.securecoding.cert.org/confluence/display/cplusplus/CON02-CPP.+Use+lock+classes+for+mutex+management">https://www.securecoding.cert.org/confluence/display/cplusplus/CON02-CPP.+Use+lock+classes+for+mutex+management</a></li>
</ul>
