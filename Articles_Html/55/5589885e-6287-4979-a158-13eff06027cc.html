<h1>What to Do</h1>
  <p>Control flow analysis is the mechanism used to step through logical conditions in the code. The process works as follows:</p>
  <ol>
    <li>Look at a function and determine each branch condition. These can include loops, if statements, and try/catch blocks. </li>
    <li>Understand the conditions under which each block will be executed. </li>
    <li>Move to the next function and repeat.</li>
  </ol>
  <h1>Why</h1>
  <p>Use control flow analysis to find vulnerabilities caused by logic errors.</p>
  <h1>When</h1>
  <p>Perform control flow analysis during the development stage of the application development life cycle.</p>
  <h1>How</h1>
  <p>Control flow analysis is the mechanism used to step through logical conditions in the code. The process works as follows:</p>
  <ol>
    <li>Look at a function and determine each branch condition. These can include loops, if statements, and try/catch blocks. </li>
    <li>Understand the conditions under which each block will be executed. </li>
    <li>Move to the next function and repeat.</li>
  </ol>
  <p>As you investigate the control flow keep the following questions in mind.</p>
  <h2>Does the application rely on client side validation? </h2>
  <p>Managed or web app code is easy to modify on the client, the server should never trust client code. It is easy to modify the behavior of the client or just write a new client from scratch that doesn’t observe the same data validation rules.</p>
  <p>Example:</p>
  <pre>&lt;html&gt;&lt;head&gt;<br />&lt;script language=‘javascript’&gt;<br />function validateAndSubmit(form)<br />{<br /> if(form.elments[“path”].value.length() &gt; 0)<br /> {<br /> form.submit();<br /> }<br />}<br />&lt;/script&gt;<br />&lt;form action=“mypage.asp” method=“post”&gt;<br />&lt;input type=‘text’ id=‘path’/&gt;<br />&lt;input type=‘button’ onclick=‘validateAndSubmit(this.parent)’&gt;Submit&lt;/input&gt;<br />&lt;/form&gt;<br />&lt;/script&gt;&lt;/head&gt;&lt;body&gt;…&lt;/body&gt;&lt;/html&gt;</pre>
  <p>In this example, client side scripting validates that the length of the “path” is greater than zero. If the server processing of this value relies on this assumption to mitigate a security threat, the attacker will have an easy time breaking the system.</p>
  <h2>Are there secrets or critical IP embedded in the code? </h2>
  <p>Managed code is easy to decompile, in fact it is possible to recover code from the final executable that is very similar to the original code. Any sensitive IP or hard coded secrets can be stolen with ease. An obfuscator can make this type of theft more difficult but cannot completely prevent it. Another common problem is to use hidden form fields thinking this information will not be visible to the user.</p>
  <p>Example:</p>
  <pre>IntPtr tokenHandle = new IntPtr(0);<br />IntPtr dupeTokenHandle = new IntPtr(0);<br />string userName = "joe", domainName = "acmecorp", password="p@Ssw0rd";<br />const int LOGON32_PROVIDER_DEFAULT = 0;<br /><br />//This parameter causes LogonUser to create a primary token.<br />const int LOGON32_LOGON_INTERACTIVE = 2;<br />const int SecurityImpersonation = 2;<br />tokenHandle = IntPtr.Zero;<br />dupeTokenHandle = IntPtr.Zero;<br /><br />// Call LogonUser to obtain a handle to an access token.<br />bool returnValue = LogonUser(userName, domainName, password, <br />LOGON32_LOGON_INTERACTIVE, LOGON32_PROVIDER_DEFAULT, ref tokenHandle);</pre>
  <h2>Is sensitive data being stored in predictable locations (such as temp files), or being sent in clear text over the network?</h2>
  <p>Sensitive data should be stored and transmitted in encrypted form, anything less invites theft. </p>
  <p>Example:</p>
  <p>A common error is to store server password in the ASP.NET web.config file:</p>
  <pre>&lt;!-- web.config --&gt;<br />&lt;connectionStrings&gt;<br /> &lt;add name="MySQLServer" <br /> connectionString="Initial Catalog=finance;<br /> data source=localhost;Integrated Security=SSPI"<br /> providerName="System.Data.SqlClient"/&gt;<br />&lt;/connectionStrings&gt;</pre>
  <pre>aspnet_regiis -pe "connectionStrings" -app "/MachineDPAPI" <br />               -prov "DataProtectionConfigurationProvider"</pre>
  <p>Instead, the connection strings should be encrypted:</p>
  <pre>
    <br />&lt;!—web.config after encrypting the connection strings section --&gt;<br />. . .<br />&lt;protectedData&gt;<br /> &lt;protectedDataSections&gt;<br /> &lt;add name="connectionStrings" <br /> provider="dataprotectionconfigurationprovider"<br /> inheritedByChildren="false" /&gt;<br /> &lt;/protectedDataSections&gt;<br />&lt;/protectedData&gt;<br />. . .<br />&lt;connectionStrings&gt;<br /> &lt;EncryptedData&gt;<br /> &lt;CipherData&gt;<br />&lt;CipherValue&gt;AQAAANCMnd8BFdERjHoAwE/Cl+sBAAAAexuIJ/8oFE+sGTs7jBKZdgQAA<br />AACAAAAAAADZgAAqAAAABAAAAAKms84dyaCPAeaSC1dIMIBAAAAAASAAACgAAAAEAAAAKa<br />VI6aAOFdqhdc6w1Er3HMwAAAAcZ00MZOz1dI7kYRvkMIn/BmfrvoHNUwz6H9rcxJ6Ow41E<br />3hwHLbh79IUWiiNp0VqFAAAAF2sXCdb3fcKkgnagkHkILqteTXh&lt;/CipherValue&gt;<br /> &lt;/CipherData&gt;<br /> &lt;/EncryptedData&gt;<br />&lt;/connectionStrings&gt;<br />. . .</pre>
  <p>Similarly forms authentication credentials should not be stored in the web.config file:</p>
  <pre> &lt;authentication mode="Forms"&gt;<br /> &lt;forms name="App" loginUrl="/login.aspx"&gt;<br /> &lt;credentials passwordFormat = "Clear" <br /> &lt;user name="UserName1" password="Password1"/&gt;<br /> &lt;user name="UserName2" password="Password2"/&gt;<br /> &lt;user name="UserName3" password="Password3"/&gt;<br /> &lt;/credentials&gt;<br /> &lt;/forms&gt;</pre>
  <p>Instead use an external well ACLed user store.</p>
  <h2>Is cryptography being used?</h2>
  <p>Look for poor random number generators. You should ensure System.Security.Cryptography.RNGCryptoServiceProvider is being used to generate cryptographically secure random numbers.</p>
  <p>Look for poor management of keys. Flag hard coded key values, leaving these in the code will help to ensure your cryptography is broken. Ensure that key values are not passed from method to method by-value as this will leave many copies of the secret in memory to be discovered by an attacker.</p>
  <p>Look for failure to clear secrets from memory after use. Due to the fact that the CLR manages memory for you this is actually harder to do in managed code than it used to be in native code. In order to ensure secrets are adequately cleared make sure the following steps have been taken:</p>
  <ul>
    <li>Strings should not be used to store secrets; they are immutable and cannot be effectively cleared. Instead check to see that a byte Array or a CLR 2.0 SecureString has been used. </li>
    <li>Whichever type you use, make sure to call the .clear method as soon as you are done with the data. </li>
    <li>If your secret is paged to disk it can persist for long periods of time and be difficult to completely clear. Ensure that GCHandle.Alloc and GCHandleType.Pinned were used to keep the managed objects from being paged to disk. </li>
  </ul>
  <p>Look for custom cryptographic routines. Ensure the use of System.Security.Cryptography. Cryptography is notoriously tricky to get right. The Windows crypto APIs are provably good, being implementation of algorithms derived from years of academic research and study. Some think that a less well known algorithm equals more security but this is not true. Cryptographic algorithms are mathematically proven, and as such the more eyes on them the better; obscurity will not protect your flawed implementation from a determined attacker. </p>
  <h2>Is CAS being used?</h2>
  <p>Look closely at each use of LinkDemand and Assert calls. These can open the code to luring attacks since the code access stack walk will be stopped before it is complete. While their use is sometimes necessary for performance reasons, make sure that there can be no un-trusted callers higher in the stack that could use this method’s LinkDemand or Assert call as a mechanism for attack. Pay particular attention if the component you are reviewing allows partially trusted callers: </p>
  <pre>[assembly: AllowPartiallyTrustedCallersAttribute()]</pre>
  <p>This will allow the assembly to be accessible from callers which are not fully trusted. If the component you are reviewing then calls into an assembly that does not allow partial trusted callers a security bug could result. <br />Also check for requests for dangerous permissions such as: UnmanagedCode, MemberAccess, SerializationFormatter, SkipVerification, ControlEvidence / ControlPolicy, ControlAppDomain, ControlDomainPolicy, SuppressUnmanagedCodeSecurityAttribute.</p>
  <p>Example:</p>
  <pre>[DllImport("Crypt32.dll", SetLastError=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]<br />[SuppressUnmanagedCodeSecurity]<br />private static extern bool CryptProtectData(<br />ref DATA_BLOB pDataIn, <br />String szDataDescr, <br />ref DATA_BLOB pOptionalEntropy,<br />IntPtr pvReserved, <br />ref CRYPTPROTECT_PROMPTSTRUCT pPromptStruct, <br />int dwFlags, <br />ref DATA_BLOB pDataOut);</pre>
  <h2>Are there undocumented public interfaces?</h2>
  <p>Look for public interfaces that have not been documented as well as the other interfaces in your application. Is the interface you are looking at a test interface or a backdoor administrative interface? Many times these shouldn’t be in the product at all, and they are almost never given the same level of design and test scrutiny as the rest of the product.</p>
  <h2>Is the component giving dependencies too much trust?</h2>
  <p>Without explicit safeguards it is possible for an attacker to trick your code into loading a malicious library instead of trusted code. Check to see if all the loaded assemblies are strongly named; this step ensures that tampering cannot occur. Without strong names your code could be calling into malicious code without knowing it. The use of native code libraries makes this harder to do so be cautious about trusting native code implicitly. Native libraries can be checked with a hash or a certificate. Additionally you should make sure that all libraries are loaded with a complete path in order to avoid canonicalization attacks.</p>
  <p>Also check whether delay signing is enabled. Delay signing is generally regarded as a good practice since it helps protect the confidentiality of the private key that will be used for signing the component:</p>
  <pre>[assembly:AssemblyDelaySignAttribute(true)]</pre>
  <h2>Is there proper and consistent error checking?</h2>
  <p>Ensure that there is consistent use of try/catch and return value checking. Keep an eye out for empty catch blocks. Double check error handling every time an assembly is loaded dynamically; look for calls to System.Reflection.Assembly.Load. Make sure that if a library contains security functionality and it fails to load that the code defaults to higher security. </p>
  <p>Also look for cases where impersonation or elevated privileges may not be lowered in the case an exception is thrown. This can occur either due to a logic bug - catch doesn’t contain the right code - or due to a subtle misuse of a finally block by an attacker.</p>
  <p>Exception filters run before the finally block so it may result in malicious code executing in the context of the privileged code rather than in the partially trusted context it should be running in.</p>
  <p>Example:</p>
  <p>Bad logic -</p>
  <pre>try<br />{<br />ElevatePrivilege();<br />//If ReadSecretFile throws an exception privileges will not be lowered<br />ReadSecretFile();<br />LowerPrivilege();<br />}<br />catch(FileException fe)<br />{<br />ReportException();<br />}</pre>
  <p>Misuse of finally - </p>
  <pre>‘Malicious VB Client<br />Imports VictimLib<br />Module MalCode<br /> Sub Main()<br /> Dim victim As New Victim<br /> Try<br /> victim.Operation(-1)<br /> Catch When Malware(victim) = True<br /> End Try<br /> End Sub<br /> Function Malware(ByVal victim As Victim) As Boolean<br /> 'Do malicious stuff in here<br /> Return True<br /> End Function<br />End Module</pre>
  <pre>‘Victim Server<br />using System;<br />namespace VictimLib {<br /> public class Victim {<br /> public void Operation(int param) {<br /><br />  try {<br /> RaisePrivilege();<br /> if(param &lt; 0) {<br /> throw new ArithmeticException("Invalid input");<br /> }<br /> }<br /> /*<br /> catch(Exception e_) {<br /> LowerPrivilege();<br /> throw(e_);<br /> }<br /> */<br /> finally {<br /> LowerPrivilege();<br /> }<br /> }<br /> }<br />}</pre>
  <h2>Do error messages give away too much information? </h2>
  <p>Error messages should be helpful to the average user without giving away information that an attacker could use against you. Ensure that the code doesn’t give away call stacks, lines of code, server file paths or anything else internal to the application. This information is not helpful to a user but can be very helpful to an attacker. </p>
  <p>Make sure custom error pages have been implemented in ASP.NET applications in order to ensure no sensitive data is given away and make sure application tracing has been turned off.</p>
  <p>Check security sensitive error paths with caution. For instance, be careful about changing error messages for differing error code paths during user authentication. A common problem is to display a&nbsp;different error message for bad username/bad password vs. good username/bad password. While the difference in errors may be subtle the end result will give the attacker information that they can use against you.</p>
  <p>Example:</p>
  <p>Logging in with a bad username gives one error message. Logging in with a good username but a bad password gives a different error message.</p>
  <h2>Does your application expose sensitive information via user session?</h2>
  <p>If you are reviewing a web application and it reveals sensitive information via user session then pay particular attention to how the session is managed. In ASP.Net the session ID is properly randomized so it is hard to guess session IDs, however, there are other ways an attacker can get at this information. Make sure that the session ID is sent over SSL, and check to ensure that the session timeout is short:</p>
  <pre>&lt;sessionState mode="InProc" stateConnectionString="tcpip=127.0.0.1:42424"<br /> sqlConnectionString="data source=127.0.0.1;user id=&lt;username&gt;;<br /> password=&lt;strong password&gt;" cookieless="false" timeout="20"<br /> regenerateExpiredSessionId = “true” /&gt;</pre>
  <h2>Can write operations be performed with a GET request?</h2>
  <p>Check to see if it is possible to modify data or content with a GET request. This opens the door for an attacker to trick a legitimate user into performing illegitimate actions with their account. In an ASP.Net application ensure that Request.RequestType is checked before making a SQL query or any other operation that can cause data or content changes.</p>
  <h2>Is the code multithreaded?</h2>
  <p>Check for race conditions, especially in static methods and constructors.</p>
  <p>Example:</p>
  <pre>private static int amtRecvd = 0;<br />public static int IncrementAmountReceived(int increment)<br />{<br />return(amtRecvd += increment);<br />}</pre>
  <p>If two threads call into this code at once it could result in an incorrect calculation on the amtRecvd value.</p>
  <br />