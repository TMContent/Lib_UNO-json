<h1>Applies to</h1>
  <ul>
    <li>C#</li>
  </ul>
  <h1>Summary</h1>
  <p>The purpose of this code snippet is to demonstrate how to implement secure password persistence using a cryptographic hashing algorithm with a randomly generated "salt" (or "nonce") value. Cryptographic hashing algorithms are one-way encryption algorithms used to store sensitive data in a non-readable format. A salt can be used in conjunction with cryptographic hashing to add additional entropy to encrypted values and to protect against pre-computed hash or dictionary attacks on a compromised hash value.</p>
  <h1>Objectives</h1>
  <ul>
    <li>Protect user credentials <li>Avoid storing user passwords <li>Protect against certain brute-force attacks on a compromised hash value <li>Generate a cryptographically random value for the salt that cannot be predicted <li>Add enough entropy to the password hash to increase the difficulty of a cracking attempt exponentially</li></li></li></li></li>
  </ul>
  <h1>Scenarios</h1>
  <ul>
    <li>Application makes use of a dedicated user account management system and stores passwords <li>Application stores a "Secret Question/Answer" credential for password reset operations <li>Application requires storage of highly sensitive data (social security number, credit card number, etc) but does not need to retrieve that data.</li></li></li>
  </ul>
  <h1>Solution Example</h1>
  <pre>using System.Security.Cryptography;</pre>
  <pre>...</pre>
  <pre>public static byte&#91;&#93; CreatePasswordHash(string password)&#123;<br />    // Convert the string password value to a byte array<br />    byte&#91;&#93; passwordData = UnicodeEncoding.ASCII.GetBytes(password);<br />    // Create a 4-byte salt using a cryptographically secure random number generator<br />    byte&#91;&#93; saltData = new byte&#91;4&#93;;<br />    RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();<br />    rng.GetNonZeroBytes(saltData);<br />     // Append the salt to the end of the password<br />    byte&#91;&#93; saltedPasswordData = new byte&#91;passwordData.Length &#43; saltData.Length&#93;;<br />    Array.Copy(passwordData, 0, saltedPasswordData, 0, passwordData.Length);<br />    Array.Copy(saltData, 0, saltedPasswordData, passwordData.Length, saltData.Length);<br />    // Create a new SHA-1 instance and compute the hash <br />    SHA1Managed sha = new SHA1Managed();<br />    byte&#91;&#93; hashData = sha.ComputeHash(saltedPasswordData);<br />    // Optional - add salt bytes onto end of the password hash for storage<br />    bool APPEND_SALT_TO_HASH = true;    if (APPEND_SALT_TO_HASH)<br />    &#123;<br />     &#9;byte&#91;&#93; hashSaltData = new byte&#91;hashData.Length &#43; saltData.Length&#93;;<br />        Array.Copy(hashData, 0, hashSaltData, 0, hashData.Length);<br />        Array.Copy(saltData, 0, hashSaltData, hashData.Length, saltData.Length);<br />        return hashSaltData;<br />    &#125;<br />    else<br />    &#123;<br />        return hashData;<br />    &#125;<br />&#125;</pre>
  <h1>Problem Example</h1>
  <p>The following code snippet shows password hashing without the use of a salt and using a weaker hashing algorithm.</p>
  <pre>// password is obtained from the user as a C# string<br />string password = Request.Form&#91;"password"&#93;;<br />// Convert the string password value to a byte<br /> arraybyte&#91;&#93; passwordData = UnicodeEncoding.ASCII.GetBytes(password);<br />// Create a new MD5 instance and compute the hash<br /> MD5CryptoServiceProvider md5 = new MD5CryptoServiceProvider();<br />byte&#91;&#93; hashData = md5.ComputeHash(passwordData);</pre>
  <ul>
    <li>Hash values are vulnerable to pre-computed hash attacks <li>Depending on password value, password hash may also be vulnerable to a dictionary attack <li>MD5 offers less encryption strengtgh than SHA-1 and has recently been "broken" by cryptography researchers</li></li></li>
  </ul>
  <h1>Test Case</h1>
  <p>The following classes must be included in any project making use of the sample code provided above:</p>
  <pre>using System.Security.Cryptography;</pre>
  <p>Execute a test encryption and comparison of a salted password hash using the following test case methods:</p>
  <pre>static void Main(string&#91;&#93; args)<br />&#123;<br />    // Create a Hash and compare to two subsequent hashes<br />    byte&#91;&#93; hash = CreatePasswordHash("foobar");<br />    Console.WriteLine("\nCreated new salted hash for 'foobar'");<br />    Console.WriteLine("foobar produces same hash:\t" &#43; <br />&#9;&#9;ComparePasswordToHash("foobar", hash).ToString());<br />    Console.WriteLine("fo0bar produces same hash:\t" &#43; <br />&#9;&#9;ComparePasswordToHash("f0obar", hash).ToString());<br />&#125;<br />public static bool ComparePasswordToHash(string password, byte&#91;&#93; hashData)<br />&#123;<br />    // First, pluck the four-byte salt off of the end of the hash<br />    byte&#91;&#93; saltData = new byte&#91;4&#93;;<br />    Array.Copy(hashData, hashData.Length - saltData.Length, saltData, 0, saltData.Length);<br />    // Convert Password to bytes<br />    byte&#91;&#93; passwordData = UnicodeEncoding.ASCII.GetBytes(password);<br />    // Append the salt to the end of the password<br />    byte&#91;&#93; saltedPasswordData = new byte&#91;passwordData.Length &#43; saltData.Length&#93;;<br />    Array.Copy(passwordData, 0, saltedPasswordData, 0, passwordData.Length);<br />    Array.Copy(saltData, 0, saltedPasswordData, passwordData.Length, saltData.Length);<br />    // Create a new SHA-1 instance and compute the hash<br />     SHA1Managed sha = new SHA1Managed();<br />    byte&#91;&#93; newHashData = sha.ComputeHash(saltedPasswordData);<br />    // Add salt bytes onto end of the password hash for storage<br />    byte&#91;&#93; newHashSaltData = new byte&#91;newHashData.Length &#43; saltData.Length&#93;;<br />    Array.Copy(newHashData, 0, newHashSaltData, 0, newHashData.Length);<br />    Array.Copy(saltData, 0, newHashSaltData, newHashData.Length, saltData.Length);<br />    // Compare and return<br />    return (Convert.ToBase64String(hashData).Equals(Convert.ToBase64String(newHashSaltData)));<br />&#125;</pre>
  <h1>Expected Result</h1>
  <pre>Created new salted hash for 'foobar'foobar produces same hash:      True<br />fo0bar produces same hash:      False</pre>
  <h1>More Information</h1>
  <p>Password hash and salt values should always be securely protected in storage. An attacker able to compromise a specific hash and salt value from a database may succeed in using other types of brute-force attacks against the compromised hash. In the example given, the four-byte salt would require an attacker to maintain 4.3 trillion values for every given plaintext value. Assuming the victim required passwords of only 4 alphabetical characters in length with no other complexity requirements (a very weak password policy by our standards), defeating a four-byte salt would require the attacker to have a database of 2 x 10&#94;15 precomputed hashes handy. Assuming each of these hashes only required one byte to store, this would require 2 petabytes of storage. </p>
  <hr />
  <p>Adapted from Microsoft patterns & practices guidance.</p>