<h1>Applies to</h1>
  <ul>
    <li>C&#43;&#43;</li>
  </ul>
  <h1>What to Do</h1>
  <p>Use C&#43;&#43; type-casts instead of C type-casts.</p>
  <h1>Why</h1>
  <p>C&#43;&#43; supports C-style casts and introduces its own, safer type-casts. The new C&#43;&#43; style type-casts are safer to use because they allow the compiler to better detect dangerous type-casting.</p>
  <h1>How</h1>
  <p>Change code to use C&#43;&#43; style casts instead of C-style casts. There are several type-cast options in C&#43;&#43;:</p>
  <ul>
    <li>
      <p>
        <strong>reinterpret_cast&lt;type&gt;(expression).</strong> A reinterpret_cast provides no additional security, because it can convert an object from one type to an object of another type without any additional checks. Avoid using reinterpret_cast unless it is absolutely necessary.</p>
      <li>
        <p>
          <strong>static_cast&lt;type&gt;(expression).</strong> A static cast provides some security in that the compiler will issue an error if an invalid cast is attempted. Not all valid casts are safe, however.</p>
        <li>
          <p>
            <strong>dynamic_cast&lt;type&gt;(expression).</strong> A dynamic_cast provides the highest degree of security, because it causes the compiler to insert code that checks the type-cast at run-time. When converting an incompatible pointer type, dynamic_cast returns a null pointer. When converting an incompatible object type, dynamic_cast throws a std::bad_cast exception.</p>
          <li>
            <p>
              <strong>const_cast&lt;type&gt;(expression).</strong> A const_cast is used to make constant variable mutable. There should hardly ever be a need to use a const_cast.</p>
          </li>
        </li>
      </li>
    </li>
  </ul>
  <p>In most situations, static and dynamic casts should be used. Dynamic casts are generally preferred to static casts.</p>