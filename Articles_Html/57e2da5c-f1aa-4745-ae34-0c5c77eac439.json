{
  "id": "57e2da5c-f1aa-4745-ae34-0c5c77eac439",
  "checksum": "45127493a829bff4d157c3ce59de64bd312b76f0",
  "words": {
    "2048": [
      "pre"
    ],
    "applies": [
      "h1"
    ],
    "to": [
      "h1",
      "p",
      "ul",
      "ul",
      "ul",
      "li",
      "li",
      "li",
      "ul",
      "ul",
      "ul",
      "ul",
      "li",
      "li",
      "li",
      "li",
      "pre",
      "p",
      "p",
      "ul",
      "li",
      "pre",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "pre",
      "pre"
    ],
    "c#": [
      "ul",
      "li"
    ],
    "summary": [
      "h1"
    ],
    "this": [
      "p",
      "pre"
    ],
    "code": [
      "p",
      "p"
    ],
    "demonstrates": [
      "p"
    ],
    "generation": [
      "p"
    ],
    "of": [
      "p",
      "ul",
      "ul",
      "ul",
      "ul",
      "li",
      "li",
      "li",
      "li",
      "ul",
      "ul",
      "ul",
      "li",
      "li",
      "li",
      "p",
      "ul",
      "li",
      "p",
      "pre",
      "p",
      "p",
      "p",
      "p",
      "title"
    ],
    "an": [
      "p",
      "ul",
      "li",
      "pre",
      "ul",
      "li",
      "p",
      "title"
    ],
    "rsa": [
      "p",
      "ul",
      "li",
      "pre",
      "pre",
      "p",
      "p",
      "p",
      "ul",
      "li",
      "title"
    ],
    "signature": [
      "p",
      "ul",
      "li",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "title"
    ],
    "on": [
      "p",
      "ul",
      "ul",
      "li",
      "li",
      "ul",
      "li",
      "p",
      "p"
    ],
    "a": [
      "p",
      "ul",
      "ul",
      "ul",
      "li",
      "li",
      "li",
      "ul",
      "ul",
      "li",
      "li",
      "pre",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "p",
      "p",
      "ul",
      "li",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "pre",
      "title"
    ],
    "given": [
      "p",
      "ul",
      "li",
      "p",
      "title"
    ],
    "message": [
      "p",
      "p",
      "ul",
      "ul",
      "li",
      "li",
      "pre",
      "pre",
      "p",
      "p",
      "ul",
      "li",
      "p",
      "p",
      "p",
      "p",
      "title"
    ],
    "which": [
      "p",
      "ul",
      "li",
      "pre",
      "p",
      "p",
      "pre"
    ],
    "can": [
      "p",
      "ul",
      "li",
      "pre",
      "p"
    ],
    "be": [
      "p",
      "ul",
      "ul",
      "li",
      "li",
      "pre",
      "ul",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "used": [
      "p",
      "ul",
      "li",
      "p",
      "p"
    ],
    "perform": [
      "p",
      "pre",
      "p",
      "p",
      "ul",
      "li"
    ],
    "integrity": [
      "p",
      "ul",
      "li"
    ],
    "checking": [
      "p"
    ],
    "and": [
      "p",
      "ul",
      "li",
      "pre",
      "p"
    ],
    "provides": [
      "p"
    ],
    "non-repudiation": [
      "p",
      "ul",
      "li",
      "ul",
      "li"
    ],
    "for": [
      "p",
      "ul",
      "li",
      "ul",
      "li",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "p"
    ],
    "the": [
      "p",
      "ul",
      "li",
      "ul",
      "ul",
      "ul",
      "li",
      "li",
      "li",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "p",
      "p",
      "pre",
      "ul",
      "ul",
      "ul",
      "li",
      "li",
      "li",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "p",
      "pre",
      "pre"
    ],
    "sent": [
      "p"
    ],
    "by": [
      "p",
      "ul",
      "li",
      "pre",
      "p",
      "p"
    ],
    "another": [
      "p"
    ],
    "entity": [
      "p",
      "p"
    ],
    "objectives": [
      "h1"
    ],
    "create": [
      "ul",
      "li",
      "pre",
      "pre"
    ],
    "cryptographic": [
      "ul",
      "li",
      "pre"
    ],
    "public": [
      "ul",
      "ul",
      "li",
      "li",
      "pre",
      "p",
      "p",
      "pre",
      "pre",
      "p",
      "pre",
      "p"
    ],
    "key": [
      "ul",
      "ul",
      "li",
      "li",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "p",
      "pre"
    ],
    "in": [
      "ul",
      "li",
      "ul",
      "li",
      "pre",
      "ul",
      "ul",
      "ul",
      "li",
      "li",
      "li",
      "p",
      "pre",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "providing": [
      "ul",
      "li"
    ],
    "checks": [
      "ul",
      "li"
    ],
    "data": [
      "ul",
      "ul",
      "ul",
      "li",
      "li",
      "li",
      "ul",
      "li",
      "pre",
      "p",
      "pre",
      "p"
    ],
    "stored": [
      "ul",
      "li",
      "ul",
      "li",
      "ul",
      "li",
      "p"
    ],
    "periods": [
      "ul",
      "li",
      "ul",
      "li"
    ],
    "time": [
      "ul",
      "li",
      "ul",
      "ul",
      "li",
      "li"
    ],
    "or": [
      "ul",
      "ul",
      "li",
      "li",
      "ul",
      "li",
      "pre",
      "ul",
      "ul",
      "li",
      "li",
      "p",
      "p"
    ],
    "transmitted": [
      "ul",
      "li"
    ],
    "provide": [
      "ul",
      "li",
      "ul",
      "ul",
      "li",
      "li"
    ],
    "piece": [
      "ul",
      "li"
    ],
    "independently": [
      "ul",
      "li"
    ],
    "validated": [
      "ul",
      "li"
    ],
    "users": [
      "ul",
      "li"
    ],
    "who": [
      "ul",
      "li"
    ],
    "posess": [
      "ul",
      "li"
    ],
    "scenarios": [
      "h1"
    ],
    "two": [
      "ul",
      "li",
      "p"
    ],
    "entities": [
      "ul",
      "li",
      "p"
    ],
    "client-server": [
      "ul",
      "li"
    ],
    "client-client": [
      "ul",
      "li"
    ],
    "architecture": [
      "ul",
      "li"
    ],
    "need": [
      "ul",
      "li"
    ],
    "transmit": [
      "ul",
      "li"
    ],
    "with": [
      "ul",
      "li",
      "pre",
      "pre",
      "p",
      "ul",
      "li",
      "pre",
      "pre",
      "p",
      "pre"
    ],
    "mechanism": [
      "ul",
      "li"
    ],
    "validate": [
      "ul",
      "li"
    ],
    "authenticity": [
      "ul",
      "li"
    ],
    "sender": [
      "ul",
      "li",
      "p"
    ],
    "non-repududiation": [
      "ul",
      "li"
    ],
    "application": [
      "ul",
      "li",
      "pre"
    ],
    "stores": [
      "ul",
      "li"
    ],
    "files": [
      "ul",
      "ul",
      "li",
      "li"
    ],
    "prolonged": [
      "ul",
      "li"
    ],
    "developer": [
      "ul",
      "li"
    ],
    "wants": [
      "ul",
      "li"
    ],
    "ensure": [
      "ul",
      "li",
      "pre",
      "p",
      "p",
      "pre"
    ],
    "they": [
      "ul",
      "li"
    ],
    "aren't": [
      "ul",
      "li"
    ],
    "altered": [
      "ul",
      "li"
    ],
    "over": [
      "ul",
      "li",
      "p",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "solution": [
      "h1",
      "p"
    ],
    "example": [
      "h1",
      "h1",
      "p"
    ],
    "//": [
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "signatures": [
      "pre",
      "p"
    ],
    "is": [
      "pre",
      "pre",
      "p",
      "p",
      "ul",
      "li",
      "pre",
      "p",
      "p",
      "p",
      "pre",
      "pre"
    ],
    "hashed": [
      "pre",
      "p"
    ],
    "predefined": [
      "pre"
    ],
    "hashing": [
      "pre",
      "p"
    ],
    "algorithm//": [
      "pre"
    ],
    "digest": [
      "pre",
      "p",
      "pre"
    ],
    "hash": [
      "pre",
      "ul",
      "li"
    ],
    "signed": [
      "pre"
    ],
    "private": [
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "pre"
    ],
    "keypairpublic": [
      "pre"
    ],
    "static": [
      "pre",
      "pre"
    ],
    "byte]": [
      "pre",
      "pre",
      "pre"
    ],
    "signmessagebyte[]": [
      "pre"
    ],
    "rsaparameters": [
      "pre",
      "pre",
      "pre"
    ],
    "privkey{": [
      "pre"
    ],
    "crypto": [
      "pre"
    ],
    "provider": [
      "pre"
    ],
    "default": [
      "pre"
    ],
    "creating": [
      "pre"
    ],
    "new": [
      "pre",
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "rsacryptoserviceprovider": [
      "pre",
      "pre",
      "pre"
    ],
    "causes": [
      "pre"
    ],
    "/": [
      "pre",
      "ul",
      "li"
    ],
    "pair": [
      "pre",
      "p"
    ],
    "generated": [
      "pre"
    ],
    "myrsaprovider": [
      "pre"
    ],
    "=": [
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "rsacryptoserviceprovider);": [
      "pre"
    ],
    "import": [
      "pre"
    ],
    "our": [
      "pre",
      "p",
      "pre"
    ],
    "so": [
      "pre"
    ],
    "we": [
      "pre",
      "pre"
    ],
    "signing": [
      "pre",
      "p",
      "pre",
      "p",
      "ul",
      "li"
    ],
    "operation": [
      "pre"
    ],
    "myrsaproviderimportparameters(privkey);": [
      "pre"
    ],
    "myrsaprovidersigndata(message,": [
      "pre"
    ],
    "sha1cryptoserviceprovider));": [
      "pre"
    ],
    "return": [
      "pre",
      "pre"
    ],
    "signature}": [
      "pre"
    ],
    "problem": [
      "h1"
    ],
    "perhaps": [
      "p",
      "p"
    ],
    "most": [
      "p",
      "p",
      "p"
    ],
    "common": [
      "p",
      "p",
      "p"
    ],
    "pitfall": [
      "p",
      "p"
    ],
    "developers": [
      "p"
    ],
    "encounter": [
      "p"
    ],
    "when": [
      "p",
      "pre",
      "p",
      "pre"
    ],
    "communicating": [
      "p"
    ],
    "remote": [
      "p",
      "pre",
      "p",
      "pre"
    ],
    "node": [
      "p"
    ],
    "communications": [
      "p",
      "ul",
      "li",
      "p"
    ],
    "channel": [
      "p"
    ],
    "failure": [
      "p"
    ],
    "any": [
      "p",
      "p"
    ],
    "such": [
      "p"
    ],
    "as": [
      "p",
      "p"
    ],
    "that": [
      "p",
      "pre",
      "p",
      "pre",
      "pre"
    ],
    "implemented": [
      "p"
    ],
    "next": [
      "p"
    ],
    "simply": [
      "p",
      "ul",
      "li"
    ],
    "using": [
      "p",
      "pre"
    ],
    "algortihm": [
      "p"
    ],
    "demonstrated": [
      "p"
    ],
    "below": [
      "p",
      "pre",
      "pre"
    ],
    "string": [
      "pre",
      "pre",
      "pre"
    ],
    "generatedigeststring": [
      "pre"
    ],
    "input{": [
      "pre"
    ],
    "instantiate": [
      "pre"
    ],
    "sha1": [
      "pre",
      "pre"
    ],
    "sha": [
      "pre"
    ],
    "sha1cryptoserviceprovider);": [
      "pre"
    ],
    "asciiencodingascii.getstring(sha.computehash(asciiencoding.ascii.getbytes(input)));}": [
      "pre"
    ],
    "if": [
      "ul",
      "li",
      "pre",
      "pre"
    ],
    "intercepted": [
      "ul",
      "li"
    ],
    "transit": [
      "ul",
      "li"
    ],
    "modified": [
      "ul",
      "li"
    ],
    "storage": [
      "ul",
      "li",
      "p"
    ],
    "attacker": [
      "ul",
      "li"
    ],
    "may": [
      "ul",
      "li",
      "p",
      "p"
    ],
    "their": [
      "ul",
      "li"
    ],
    "own": [
      "ul",
      "li"
    ],
    "representation": [
      "ul",
      "li"
    ],
    "value": [
      "ul",
      "li",
      "pre",
      "pre"
    ],
    "included": [
      "ul",
      "li",
      "p"
    ],
    "along": [
      "ul",
      "li"
    ],
    "file": [
      "ul",
      "li"
    ],
    "disk": [
      "ul",
      "li"
    ],
    "test": [
      "h1",
      "pre",
      "p",
      "p",
      "p"
    ],
    "case": [
      "h1",
      "pre",
      "pre",
      "p",
      "p",
      "p"
    ],
    "following": [
      "p",
      "p",
      "p"
    ],
    "classes": [
      "p"
    ],
    "must": [
      "p"
    ],
    "project": [
      "p"
    ],
    "making": [
      "p"
    ],
    "use": [
      "p",
      "p"
    ],
    "sample": [
      "p"
    ],
    "provided": [
      "p"
    ],
    "above": [
      "p",
      "p"
    ],
    "systemtext;using": [
      "pre"
    ],
    "systemsecurity;using": [
      "pre"
    ],
    "systemsecurity.cryptography;static": [
      "pre"
    ],
    "void": [
      "pre"
    ],
    "mainstring[]": [
      "pre"
    ],
    "args{": [
      "pre"
    ],
    "keypair": [
      "pre"
    ],
    "strong": [
      "pre"
    ],
    "keysize": [
      "pre"
    ],
    "bits": [
      "pre"
    ],
    "production": [
      "pre"
    ],
    "would": [
      "pre"
    ],
    "load": [
      "pre"
    ],
    "from": [
      "pre",
      "p"
    ],
    "dpapi": [
      "pre"
    ],
    "protected": [
      "pre"
    ],
    "registry": [
      "pre"
    ],
    "rsaprovider": [
      "pre"
    ],
    "rsacryptoserviceprovider2048);": [
      "pre"
    ],
    "exportparameters": [
      "pre",
      "pre"
    ],
    "method": [
      "pre",
      "pre"
    ],
    "takes": [
      "pre",
      "pre"
    ],
    "boolean": [
      "pre",
      "pre"
    ],
    "determines": [
      "pre",
      "pre"
    ],
    "whether": [
      "pre"
    ],
    "export": [
      "pre",
      "pre",
      "p",
      "pre",
      "p"
    ],
    "within": [
      "pre",
      "p",
      "pre"
    ],
    "parameters": [
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "exporting": [
      "pre"
    ],
    "only": [
      "pre",
      "p",
      "p",
      "p",
      "pre"
    ],
    "parameter": [
      "pre",
      "pre"
    ],
    "shared": [
      "pre",
      "p",
      "pre"
    ],
    "party": [
      "pre",
      "pre"
    ],
    "rsapubkeyparams": [
      "pre",
      "pre"
    ],
    "rsaproviderexportparameters(false);": [
      "pre",
      "pre"
    ],
    "we'll": [
      "pre"
    ],
    "also": [
      "pre"
    ],
    "operations": [
      "pre"
    ],
    "rsaprivkeyparams": [
      "pre"
    ],
    "rsaproviderexportparameters(true);": [
      "pre"
    ],
    "message1": [
      "pre"
    ],
    "\"the": [
      "pre",
      "pre"
    ],
    "quick": [
      "pre",
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "brown": [
      "pre",
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "fox": [
      "pre",
      "pre",
      "pre"
    ],
    "jumped": [
      "pre",
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "lazy": [
      "pre",
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "dog\"": [
      "pre"
    ],
    "message2": [
      "pre"
    ],
    "dog": [
      "pre",
      "pre"
    ],
    "fox\"": [
      "pre"
    ],
    "sig": [
      "pre",
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "signmessageasciiencoding.ascii.getbytes(message1),": [
      "pre"
    ],
    "rsaprivkeyparams;": [
      "pre"
    ],
    "consoleout.writeline(\"msg:": [
      "pre"
    ],
    "\"+message1;": [
      "pre"
    ],
    "consoleout.writeline(\"\\nrsa": [
      "pre"
    ],
    "\"": [
      "pre",
      "pre",
      "pre"
    ],
    "+converttobase64string(sig));": [
      "pre"
    ],
    "consoleout.writeline(\"\\ntest": [
      "pre",
      "pre"
    ],
    "#1\");": [
      "pre"
    ],
    "consoleout.writeline(\"validating": [
      "pre",
      "pre"
    ],
    "msg": [
      "pre",
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "+": [
      "pre",
      "pre"
    ],
    "message1;": [
      "pre"
    ],
    "verifymessagesignature(asciiencoding.ascii.getbytes(message1),": [
      "pre"
    ],
    "rsapubkeyparams)": [
      "pre",
      "pre"
    ],
    "{": [
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "consoleout.writeline(\"valid": [
      "pre",
      "pre"
    ],
    "signature\");": [
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "}": [
      "pre",
      "pre",
      "pre"
    ],
    "else": [
      "pre",
      "pre"
    ],
    "consoleout.writeline(\"invalid": [
      "pre",
      "pre"
    ],
    "#2\");": [
      "pre"
    ],
    "message2;": [
      "pre"
    ],
    "verifymessagesignature(asciiencoding.ascii.getbytes(message2),": [
      "pre"
    ],
    "}}": [
      "pre"
    ],
    "expected": [
      "h1"
    ],
    "result": [
      "h1",
      "p"
    ],
    "running": [
      "p"
    ],
    "will": [
      "p"
    ],
    "output": [
      "p"
    ],
    "dogrsa": [
      "pre"
    ],
    "e1ugw7omhpop9lgnjfla7iwuqhlrxl87tmhnkqgpowcssx70ftt78t4me5lf5iog4eligbtuh5mivjdsqkxztbk64v+w5gcuqsesiqcmjztchpbeyc0e9tqnbaflo+8yisp6aisdss9w5osngnj0tn3vt2vnrqwa8qorlmifvrpxtqu4gm60sho2rkitsimu81m3mfni3is/madln6bwxnnvdnxjfpdadenaihvdbsrideev4cbaqe59gbjjsbbfy15xc5x0ufnske0eg+k3lurjeqdsg03ofnbhmi8zl7otawhw0xrygh/abqzctettjj+rslpxv5nsrxhzsfxldw==": [
      "pre"
    ],
    "#1": [
      "p"
    ],
    "validating": [
      "pre",
      "pre"
    ],
    "dogvalid": [
      "pre"
    ],
    "#2": [
      "p"
    ],
    "foxinvalid": [
      "pre"
    ],
    "more": [
      "h1",
      "p",
      "p"
    ],
    "information": [
      "h1",
      "p"
    ],
    "potential": [
      "p"
    ],
    "pitfalls": [
      "p"
    ],
    "secure": [
      "p",
      "p"
    ],
    "include": [
      "p",
      "p"
    ],
    "session": [
      "p",
      "p",
      "p",
      "p"
    ],
    "replay": [
      "p",
      "p",
      "p"
    ],
    "attacks": [
      "p"
    ],
    "mitigated": [
      "p"
    ],
    "through": [
      "p"
    ],
    "includes": [
      "p"
    ],
    "timestamp": [
      "p"
    ],
    "identifier": [
      "p"
    ],
    "once": [
      "p"
    ],
    "performing": [
      "p"
    ],
    "it": [
      "p"
    ],
    "possible": [
      "p"
    ],
    "protect": [
      "p"
    ],
    "against": [
      "p"
    ],
    "because": [
      "p"
    ],
    "generate": [
      "p",
      "title"
    ],
    "valid": [
      "p"
    ],
    "properties": [
      "p"
    ],
    "asymmetric": [
      "p",
      "p"
    ],
    "encryption": [
      "p",
      "p"
    ],
    "algorithms": [
      "p"
    ],
    "single": [
      "p"
    ],
    "important": [
      "p"
    ],
    "design": [
      "p"
    ],
    "consideration": [
      "p"
    ],
    "communication": [
      "p"
    ],
    "protocol": [
      "p"
    ],
    "altogether": [
      "p"
    ],
    "however": [
      "p"
    ],
    "routines": [
      "p"
    ],
    "are": [
      "p",
      "p"
    ],
    "expensive": [
      "p"
    ],
    "generally": [
      "p"
    ],
    "performed": [
      "p"
    ],
    "during": [
      "p",
      "p"
    ],
    "initial": [
      "p"
    ],
    "exchange": [
      "p"
    ],
    "process": [
      "p"
    ],
    "agree": [
      "p"
    ],
    "secret": [
      "p"
    ],
    "-": [
      "p"
    ],
    "symmetric": [
      "p"
    ],
    "efficient": [
      "p"
    ],
    "hmac": [
      "p"
    ],
    "algorithm": [
      "p"
    ],
    "care": [
      "p"
    ],
    "should": [
      "p"
    ],
    "taken": [
      "p"
    ],
    "keys": [
      "p",
      "p"
    ],
    "container": [
      "p"
    ],
    "please": [
      "p"
    ],
    "refer": [
      "p"
    ],
    "http//msdn2.microsoft.com/en-us/library/system.security.cryptography.cspparameters(vs.80).aspx).": [
      "p"
    ],
    "sharing": [
      "p"
    ],
    "always": [
      "p"
    ],
    "exported": [
      "p"
    ],
    "rather": [
      "p"
    ],
    "than": [
      "p"
    ],
    "full": [
      "p"
    ],
    "one": [
      "p"
    ],
    "call": [
      "p"
    ],
    "methods": [
      "p"
    ],
    "whether//": [
      "pre"
    ],
    "exporting//": [
      "pre"
    ],
    "alternatively": [
      "p"
    ],
    "just": [
      "p"
    ],
    "xml": [
      "p"
    ],
    "setting": [
      "pre"
    ],
    "argument": [
      "pre"
    ],
    "false": [
      "pre"
    ],
    "ensures": [
      "pre"
    ],
    "private//": [
      "pre"
    ],
    "not": [
      "pre"
    ],
    "exportedrsapubstring": [
      "pre"
    ],
    "myrsaprovidertoxmlstring(false);": [
      "pre"
    ],
    "additional": [
      "h1"
    ],
    "resources": [
      "h1"
    ],
    "encrycryption": [
      "ul",
      "li"
    ],
    "http//en.wikipedia.org/wiki/rsa": [
      "ul",
      "li",
      "a"
    ],
    "adapted": [
      "p"
    ],
    "microsoft": [
      "p"
    ],
    "patterns": [
      "p"
    ],
    "&": [
      "p"
    ],
    "practices": [
      "p"
    ],
    "guidance": [
      "p"
    ]
  },
  "tags": {
    "h1": [
      "Applies to",
      "Summary",
      "Objectives",
      "Scenarios",
      "Solution Example",
      "Problem Example",
      "Test Case",
      "Expected Result",
      "More Information",
      "Additional Resources"
    ],
    "ul": [
      "C#",
      "To create a cryptographic public key signature of a given message, to be used in providing integrity checks on data stored for periods of time or on transmitted data. To provide non-repudiation of a message or piece of data which can be independently validated by users who posess the RSA public key.",
      "Two entities in a client-server or client-client architecture need to transmit data with a mechanism to validate the authenticity of the sender and provide non-repududiation. An application stores files for prolonged periods of time. The developer wants to provide non-repudiation of files stored to ensure they aren't altered over time.",
      "If a message is intercepted in transit or modified in storage, an attacker may simply perform their own hash representation of the value to be included in the communications or stored along with the file on disk.",
      "RSA Encrycryption / Signing: http://en.wikipedia.org/wiki/RSA"
    ],
    "li": [
      "C#",
      "To create a cryptographic public key signature of a given message, to be used in providing integrity checks on data stored for periods of time or on transmitted data.",
      "To provide non-repudiation of a message or piece of data which can be independently validated by users who posess the RSA public key.",
      "Two entities in a client-server or client-client architecture need to transmit data with a mechanism to validate the authenticity of the sender and provide non-repududiation.",
      "An application stores files for prolonged periods of time. The developer wants to provide non-repudiation of files stored to ensure they aren't altered over time.",
      "If a message is intercepted in transit or modified in storage, an attacker may simply perform their own hash representation of the value to be included in the communications or stored along with the file on disk.",
      "RSA Encrycryption / Signing: http://en.wikipedia.org/wiki/RSA"
    ],
    "p": [
      "This code demonstrates generation of an RSA signature on a given message which can be used to perform integrity checking and provides non-repudiation for the message sent by another entity.",
      "Perhaps the most common pitfall developers encounter when communicating with a remote node over a public communications channel is the failure to perform any message signing such as that implemented by our Solution Example.",
      "The next most common pitfall is to simply perform a hashed digest of the message using a public hashing algortihm demonstrated below:",
      "The following classes must be included in any project making use of the sample code provided above:",
      "Running the test case above will result in the following output:",
      "Test Case #1:",
      "Test Case #2:",
      "Potential pitfalls in secure communications include session replay attacks. Session replay may be mitigated through use of RSA signatures in which a message includes a timestamp or session identifier to be used once. By performing an RSA signature on the message it is possible to protect against session replay because only the sender can generate a valid signature of a message given the properties of asymmetric encryption algorithms.",
      "Perhaps the single most important design consideration in a secure communication protocol is to include message signing altogether. However, Asymmetric encryption routines are expensive and generally performed during the initial key exchange process during which two entities agree on a common shared (secret - symmetric) key to be used in a more efficient HMAC algorithm.",
      "Care should be taken in storage of the private key pair. Ensure that keys are stored within a container (for more information please refer to: http://msdn2.microsoft.com/en-us/library/system.security.cryptography.cspparameters(VS.80).aspx).",
      "When sharing keys with a remote entity always ensure only the public key data is exported rather than the full RSA key. To export only the private key one may call the following methods:",
      "Or alternatively export just the public key data as XML:",
      "Adapted from Microsoft patterns & practices guidance."
    ],
    "pre": [
      "// In RSA signatures a message is hashed with a predefined cryptographic hashing algorithm// and the digest or hash is signed with the private keypairpublic static byte[] SignMessage(byte[] message, RSAParameters privkey){    byte[] signature;    // Create an RSA Crypto provider, by default creating a new RSACryptoServiceProvider    // causes a public / private key pair to be generated.    RSACryptoServiceProvider myRsaProvider = new RSACryptoServiceProvider();    // Import our private key so we can perform the signing operation    myRsaProvider.ImportParameters(privkey);    signature = myRsaProvider.SignData(message, new SHA1CryptoServiceProvider());    return signature;}",
      "public static string GenerateDigest(string input){    // Instantiate the SHA1 Digest    SHA1 sha = new SHA1CryptoServiceProvider();    return ASCIIEncoding.ASCII.GetString(sha.ComputeHash(ASCIIEncoding.ASCII.GetBytes(input)));}",
      "using System.Text;using System.Security;using System.Security.Cryptography;static void Main(string[] args){    // Create a test keypair with a strong keysize of 2048 bits. In a production application     // we would load this value from a DPAPI protected registry value    RSACryptoServiceProvider rsaProvider = new RSACryptoServiceProvider(2048);    // The ExportParameters method below takes a boolean, which determines whether    // to export the private key data within the parameters. When exporting parameters    // ensure that only the public key parameter is shared with the remote party:    RSAParameters rsaPubKeyParams = rsaProvider.ExportParameters(false);    // We'll also export the private key for our signing operations    RSAParameters rsaPrivKeyParams = rsaProvider.ExportParameters(true);    string message1 = \"the quick brown fox jumped over the lazy dog\";    string message2 = \"the quick brown dog jumped over the lazy fox\";    byte[] sig = SignMessage(ASCIIEncoding.ASCII.GetBytes(message1), rsaPrivKeyParams);    Console.Out.WriteLine(\"MSG: \"+message1);    Console.Out.WriteLine(\"\\nRSA Sig: \" +Convert.ToBase64String(sig));    Console.Out.WriteLine(\"\\nTest Case #1:\");    Console.Out.WriteLine(\"Validating signature for MSG: \" + message1);    if (VerifyMessageSignature(ASCIIEncoding.ASCII.GetBytes(message1), sig, rsaPubKeyParams)) {        Console.Out.WriteLine(\"Valid signature.\");    }    else {        Console.Out.WriteLine(\"Invalid signature.\");    }    Console.Out.WriteLine(\"\\nTest Case #2:\");    Console.Out.WriteLine(\"Validating signature for MSG: \" + message2);    if (VerifyMessageSignature(ASCIIEncoding.ASCII.GetBytes(message2), sig, rsaPubKeyParams))    {        Console.Out.WriteLine(\"Valid signature.\");    }    else    {        Console.Out.WriteLine(\"Invalid signature.\");    }}",
      "MSG: the quick brown fox jumped over the lazy dogRSA Sig:         E1uGW7OmhpoP9LgnjfLA7IWUQhlrxL87tmHnkqGPowCssX70ftT78T4mE5lF5iog4elIgBTUH5miVJdsqKXzTBK64V+W5gCUqsESiqcmJztchpbeyc0E9tqNBaFlo+8yiSp6aIsDsS9W5OsNgnj0Tn3vT2vnRqWA8qORLmifVrPXtQU4gm60sHO2RKiTsiMu81m3MfNI3Is/MadLn6bwxnnvDNxJFpDADENaihVdBSrIDeEV4CBaQE59GbJJSBBfY15xC5X0ufNske0eG+k3LURJeQDSg03oFNBHMi8ZL7oTaWHw0xRygh/aBqZCTEtTjj+RsLPxv5NsrxhzSFXlDw==",
      "Validating signature for MSG: the quick brown fox jumped over the lazy dogValid signature.",
      "Validating signature for MSG: the quick brown dog jumped over the lazy foxInvalid signature.",
      "// The ExportParameters method below takes a boolean, which determines whether// to export the private key data within the parameters. When exporting// parameters ensure that only the public key parameter is shared with the // remote party:   rsaPubKeyParams = rsaProvider.ExportParameters(false);",
      "// Setting the argument to false ensures that the private// key is not exported.rsaPubString = myRsaProvider.ToXmlString(false);"
    ],
    "br": [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
    ],
    "a": [
      "http://en.wikipedia.org/wiki/RSA"
    ],
    "hr": [
      ""
    ]
  },
  "links": [
    {
      "href": "http://en.wikipedia.org/wiki/RSA",
      "text": "http://en.wikipedia.org/wiki/RSA"
    }
  ],
  "html": "<h1>Applies to</h1>\r\n  <ul>\r\n    <li>C# </li>\r\n  </ul>\r\n  <h1>Summary</h1>\r\n  <p>This code demonstrates generation of an RSA signature on a given message which can be used to perform integrity checking and provides non-repudiation for the message sent by another entity.</p>\r\n  <h1>Objectives</h1>\r\n  <ul>\r\n    <li>To create a cryptographic public key signature of a given message, to be used in providing integrity checks on data stored for periods of time or on transmitted data. <li>To provide non-repudiation of a message or piece of data which can be independently validated by users who posess the RSA public key. </li></li>\r\n  </ul>\r\n  <h1>Scenarios</h1>\r\n  <ul>\r\n    <li>Two entities in a client-server or client-client architecture need to transmit data with a mechanism to validate the authenticity of the sender and provide non-repududiation. <li>An application stores files for prolonged periods of time. The developer wants to provide non-repudiation of files stored to ensure they aren't altered over time. </li></li>\r\n  </ul>\r\n  <h1>Solution Example</h1>\r\n  <pre>// In RSA signatures a message is hashed with a predefined cryptographic hashing algorithm<br />// and the digest or hash is signed with the private keypair<br />public static byte&#91;&#93; SignMessage(byte&#91;&#93; message, RSAParameters privkey)&#123;<br />    byte&#91;&#93; signature;<br />    // Create an RSA Crypto provider, by default creating a new RSACryptoServiceProvider<br />    // causes a public / private key pair to be generated.<br />    RSACryptoServiceProvider myRsaProvider = new RSACryptoServiceProvider();<br />    // Import our private key so we can perform the signing operation<br />    myRsaProvider.ImportParameters(privkey);<br />    signature = myRsaProvider.SignData(message, new SHA1CryptoServiceProvider());<br />    return signature;<br />&#125;</pre>\r\n  <h1>Problem Example</h1>\r\n  <p>Perhaps the most common pitfall developers encounter when communicating with a remote node over a public communications channel is the failure to perform any message signing such as that implemented by our Solution Example.</p>\r\n  <p>The next most common pitfall is to simply perform a hashed digest of the message using a public hashing algortihm demonstrated below:</p>\r\n  <pre>public static string GenerateDigest(string input)&#123;<br />    // Instantiate the SHA1 Digest<br />    SHA1 sha = new SHA1CryptoServiceProvider();<br />    return ASCIIEncoding.ASCII.GetString(sha.ComputeHash(ASCIIEncoding.ASCII.GetBytes(input)));<br />&#125;</pre>\r\n  <ul>\r\n    <li>If a message is intercepted in transit or modified in storage, an attacker may simply perform their own hash representation of the value to be included in the communications or stored along with the file on disk. </li>\r\n  </ul>\r\n  <h1>Test Case</h1>\r\n  <p>The following classes must be included in any project making use of the sample code provided above:</p>\r\n  <pre>using System.Text;<br />using System.Security;<br />using System.Security.Cryptography;<br />static void Main(string&#91;&#93; args)&#123;<br />    // Create a test keypair with a strong keysize of 2048 bits. In a production application<br />     // we would load this value from a DPAPI protected registry value<br />    RSACryptoServiceProvider rsaProvider = new RSACryptoServiceProvider(2048);<br />    // The ExportParameters method below takes a boolean, which determines whether<br />    // to export the private key data within the parameters. When exporting parameters<br />    // ensure that only the public key parameter is shared with the remote party:<br />    RSAParameters rsaPubKeyParams = rsaProvider.ExportParameters(false);<br />    // We'll also export the private key for our signing operations<br />    RSAParameters rsaPrivKeyParams = rsaProvider.ExportParameters(true);<br />    string message1 = \"the quick brown fox jumped over the lazy dog\";<br />    string message2 = \"the quick brown dog jumped over the lazy fox\";<br />    byte&#91;&#93; sig = SignMessage(ASCIIEncoding.ASCII.GetBytes(message1), rsaPrivKeyParams);<br />    Console.Out.WriteLine(\"MSG: \"&#43;message1);<br />    Console.Out.WriteLine(\"\\nRSA Sig: \" &#43;Convert.ToBase64String(sig));<br />    Console.Out.WriteLine(\"\\nTest Case #1:\");<br />    Console.Out.WriteLine(\"Validating signature for MSG: \" &#43; message1);<br />    if (VerifyMessageSignature(ASCIIEncoding.ASCII.GetBytes(message1), sig, rsaPubKeyParams)) &#123;<br />        Console.Out.WriteLine(\"Valid signature.\");<br />    &#125;<br />    else &#123;<br />        Console.Out.WriteLine(\"Invalid signature.\");<br />    &#125;<br />    Console.Out.WriteLine(\"\\nTest Case #2:\");<br />    Console.Out.WriteLine(\"Validating signature for MSG: \" &#43; message2);<br />    if (VerifyMessageSignature(ASCIIEncoding.ASCII.GetBytes(message2), sig, rsaPubKeyParams))<br />    &#123;<br />        Console.Out.WriteLine(\"Valid signature.\");<br />    &#125;<br />    else<br />    &#123;<br />        Console.Out.WriteLine(\"Invalid signature.\");<br />    &#125;<br />&#125;</pre>\r\n  <h1>Expected Result</h1>\r\n  <p>Running the test case above will result in the following output:</p>\r\n  <pre>MSG: the quick brown fox jumped over the lazy dog<br />RSA Sig:         E1uGW7OmhpoP9LgnjfLA7IWUQhlrxL87tmHnkqGPowCssX70ftT78T4m<br />E5lF5iog4elIgBTUH5miVJdsqKXzTBK64V&#43;W5gCUqsESiqcmJztchpbeyc0E9tqNBaFlo&#43;8yi<br />Sp6aIsDsS9W5OsNgnj0Tn3vT2vnRqWA8qORLmifVrPXtQU4gm60sHO2RKiTsiMu81m3MfNI3I<br />s/MadLn6bwxnnvDNxJFpDADENaihVdBSrIDeEV4CBaQE59GbJJSBBfY15xC5X0ufNske0eG&#43;k<br />3LURJeQDSg03oFNBHMi8ZL7oTaWHw0xRygh/aBqZCTEtTjj&#43;RsLPxv5NsrxhzSFXlDw==</pre>\r\n  <p>Test Case #1:</p>\r\n  <pre>Validating signature for MSG: the quick brown fox jumped over the lazy dog<br />Valid signature.</pre>\r\n  <p>Test Case #2:</p>\r\n  <pre>Validating signature for MSG: the quick brown dog jumped over the lazy fox<br />Invalid signature.</pre>\r\n  <h1>More Information</h1>\r\n  <p>Potential pitfalls in secure communications include session replay attacks. Session replay may be mitigated through use of RSA signatures in which a message includes a timestamp or session identifier to be used once. By performing an RSA signature on the message it is possible to protect against session replay because only the sender can generate a valid signature of a message given the properties of asymmetric encryption algorithms.</p>\r\n  <p>Perhaps the single most important design consideration in a secure communication protocol is to include message signing altogether. However, Asymmetric encryption routines are expensive and generally performed during the initial key exchange process during which two entities agree on a common shared (secret - symmetric) key to be used in a more efficient HMAC algorithm.</p>\r\n  <p>Care should be taken in storage of the private key pair. Ensure that keys are stored within a container (for more information please refer to: http://msdn2.microsoft.com/en-us/library/system.security.cryptography.cspparameters(VS.80).aspx).</p>\r\n  <p>When sharing keys with a remote entity always ensure only the public key data is exported rather than the full RSA key. To export only the private key one may call the following methods:</p>\r\n  <pre>// The ExportParameters method below takes a boolean, which determines whether<br />// to export the private key data within the parameters. When exporting<br />// parameters ensure that only the public key parameter is shared with the <br />// remote party:   rsaPubKeyParams = rsaProvider.ExportParameters(false);</pre>\r\n  <p>Or alternatively export just the public key data as XML:</p>\r\n  <pre>// Setting the argument to false ensures that the private<br />// key is not exported.<br />rsaPubString = myRsaProvider.ToXmlString(false);</pre>\r\n  <h1>Additional Resources</h1>\r\n  <ul>\r\n    <li>RSA Encrycryption / Signing: <a href=\"http://en.wikipedia.org/wiki/RSA\">http://en.wikipedia.org/wiki/RSA</a></li>\r\n  </ul>\r\n  <hr />\r\n  <p>Adapted from Microsoft patterns & practices guidance.</p>"
}