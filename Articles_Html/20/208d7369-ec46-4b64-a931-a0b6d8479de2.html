<h1>Applies to</h1>
  <ul>
    <li>ASP.NET 4.0</li>
  </ul>
  <h1>Summary</h1>
  <p>This How to explains the &lt;<em>machineKey</em>&gt; element in the <em>Web.config</em> file and shows how to configure the &lt;<em>machineKey</em>&gt; element to control tamper proofing and encryption of <em>ViewState</em>, forms authentication tickets, and role cookies. <em>ViewState</em> is signed and tamper proof by default. You can request encryption for pages that contain sensitive items in their <em>ViewState</em> by using the <em>ViewStateEncryptionMode</em> attribute. Forms authentication and role cookies are signed and encrypted by default. You do not need to modify the default settings unless your application is in a Web farm or if you need to share authentication tickets across applications. In these cases, you need to manually generate encryption and hashing keys.</p>
  <h1>Contents</h1>
  <ul>
    <li>Objectives </li>
    <li>Overview </li>
    <li>Machine Key Explained </li>
    <li>ViewState </li>
    <li>Forms Authentication Tickets </li>
    <li>Membership </li>
    <li>Anonymous Identification </li>
    <li>Role Cookies </li>
    <li>Web Farm Deployment Considerations </li>
    <li>Sharing Authentication Tickets Across Applications </li>
    <li>Upgrading ASP.NET Versions </li>
    <li>Additional Resources</li>
  </ul>
  <h1>Objectives</h1>
  <ul>
    <li>Verify <em>ViewState</em> is configured to be tamper proof. </li>
    <li>Configure the &lt;<em>machineKey</em>&gt; to encrypt <em>ViewState</em>. </li>
    <li>Verify forms authentication tickets are configured to be tamper proof. </li>
    <li>Configure &lt;<em>machineKey</em>&gt; to encrypt forms authentication tickets. </li>
    <li>Learn to configure the membership feature to use an encrypted password instead of a hashed password by using <em>machineKey</em>. </li>
    <li>Learn to protect an anonymous identification cookie by using <em>machineKey</em>. </li>
    <li>Learn to protect role cookies by using <em>machineKey</em>. </li>
    <li>Generate random key values for use in a Web farm. </li>
  </ul>
  <h1>Overview</h1>
  <p>The default ASP.NET settings ensure that forms authentication tickets are tamper proof and encrypted, and that <em>ViewState</em> is tamper proof. This ensures that any modification of the <em>ViewState</em> or authentication tickets either on the client's computer or over the network is detected when the server processes the data.</p>
  <p>To provide tamper proof <em>ViewState</em>, a hashed message authentication code (HMAC) is generated from the <em>ViewState</em> content and the hash is compared on subsequent requests. The <em>validation</em> attribute of the &lt;<em>machineKey</em>&gt; indicates which hashing algorithm to use, and it defaults to SHA1, which uses the HMACSHA1 algorithm. Valid choices for hashing include SHA1 or MD5, although SHA1 is preferable because it produces a larger hash and is considered cryptographically stronger than MD5. The <em>validationKey</em> attribute of &lt;<em>machineKey</em>&gt; is used in conjunction with the <em>ViewState</em> content to produce the HMAC. If your application is installed in a Web farm, you need to change the <em>validationKey</em> from <em>AutoGenerate,IsolateApps</em> to a specific manually generated key value.</p>
  <p>If you need to use round trips for potentially sensitive data, you can force encryption of <em>ViewState</em> for a specific page. To do this, set <em>ViewStateEncryptionMode="Always"</em> on the <em>@Page</em> directive for that page. Alternatively, you can use a control to request that the page's <em>ViewState</em> be encrypted by calling the <em>Page.RegisterRequiresViewStateEncryption</em> method. Using this method in conjunction with the default setting of <em>ViewStateEncryptionMode="Auto"</em> ensures that <em>ViewState</em> is only encrypted for those pages that need it.</p>
  <p>To encrypt <em>ViewState</em> in a Web farm, you need to manually set the <em>validationKey</em> value. The encryption algorithm is determined by the <em>validation</em> attribute of the &lt;<em>machineKey</em>&gt;. The <em>validation</em> attribute defaults to <em>SHA1</em>, which provides tamper proofing but not encryption. To support <em>ViewState</em> encryption, you should set the <em>validation</em> attribute to <em>AES</em>, the recommended symmetric encryption algorithm.</p>
  <p>Forms authentication tickets are tamper proof and encrypted by default. The <em>decryption</em> and <em>decryptionKey</em> attributes control the encryption. The <em>validationKey</em> controls the hashing. If your application is in a Web farm, you need to manually set the <em>validationKey</em> and <em>decryptionKey</em>. Also, if you need to share forms authentication tickets across applications in separate virtual directories, you need to manually set the keys to ensure that they match in each application's <em>Web.config</em> file.</p>
  <p>If you use the <em>Role Manager</em> feature, and choose to cache roles, a roles cookie is created. The roles cookie is also signed and encrypted by default, using the same mechanisms as forms authentication tickets.</p>
  <h1>Machine Key Explained</h1>
  <p>The default settings for the &lt;<em>pages</em>&gt; and &lt;<em>machineKey</em>&gt; elements are defined in the machine-level <em>Web.config.comments</em> file. The relevant default settings are shown here for reference.</p>
  <pre>&lt;pages enableViewStateMac="true" viewStateEncryptionMode="Auto" ... /&gt;<br />&lt;machineKey validationKey="AutoGenerate,IsolateApps"&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decryptionKey="AutoGenerate,IsolateApps" <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; validation="SHA1" decryption="Auto" /&gt;</pre>
  <p>When you configure <em>ViewState</em>, the &lt;<em>pages</em>&gt; element is used in conjunction with the &lt;<em>machineKey</em>&gt; element.</p>
  <p>The &lt;<em>machineKey</em>&gt; attributes are as follows: </p>
  <ul>
    <li>
      <p />
      <b>
        <em>validationKey</em>.</b> This specifies the key that the HMAC algorithm uses to make <em>ViewState</em> tamper proof. The <em>ViewState</em> MAC is checked at the server when either the <em>enableViewStateMAC</em> attribute of the &lt;<em>pages</em>&gt; element or the <em>EnableViewStateMac</em> attribute of the <em>@Page</em> directive is set to <em>true</em>. <pre>&lt;pages enableViewStateMAC="true" ... /&gt;</pre>or<pre>&lt;%@Page EnableViewStateMac="true" ... %&gt;</pre><p>Forms authentication also uses this key for signing the authentication ticket. Role manager and anonymous identification, if enabled, also uses this key for signing their cookies. If you use anonymous identification in cookieless mode, the data on the URL is also signed with this value.</p></li>
    <li>
      <p>
        <b>
          <em>decryptionKey</em>.</b> This specifies the key used to encrypt and decrypt data. Forms authentication, role manager and anonymous identification features use this key to encrypt and decrypt the authentication ticket, roles cookie and anonymous identification cookie. ASP.NET uses the key to encrypt and decrypt <em>ViewState</em>, but only if the <em>validation</em> attribute is set to <em>AES</em> or <em>3DES</em>. </p>
    </li>
    <li>
      <p>
        <b>
          <em>decryption</em>.</b> This specifies the symmetric encryption algorithm used to encrypt and decrypt forms authentication tickets. </p>
    </li>
    <li>
      <p />
      <b>
        <em>validation</em>.</b> This specifies the hashing algorithm used to generate HMACs to make <em>ViewState</em> and forms authentication tickets tamper proof. This attribute is also used to specify the encryption algorithm used for <em>ViewState</em> encryption. This attribute supports the following options: <ul><li><b><em>SHA1</em>. </b><em>SHA1</em> is used to tamper proof <em>ViewState</em> and, if configured, the forms authentication ticket. When <em>SHA1</em> is selected for the <em>validation</em> attribute, the algorithm used is <em>HMACSHA1</em>. </li><li><b><em>MD5</em>. </b><em>MD5</em> is used to tamper proof <em>ViewState</em> and, if configured, the forms authentication ticket. </li><li><b><em>AES</em>. </b><em>AES</em> is used to encrypt <em>ViewState</em> with the key specified in the <em>decryptionKey</em> attribute. </li><li><b><em>3DES</em>. </b><em>3DES</em> is used to encrypt <em>ViewState</em> with the key specified in the <em>decryptionKey</em> attribute.&nbsp;Using&nbsp;3DES is not recommended, because it is&nbsp;generally considered not as strong as AES.&nbsp;</li></ul></li>
  </ul>
  <p />
  <p>In general, you should choose SHA1 over MD5 for tamper-proofing because this produces a larger hash than MD5 and is considered cryptographically stronger.</p>
  <p>Forms authentication defaults to SHA1 for tamper proofing (if <em>&lt;forms protection="validation"&gt;</em> or <em>"All"</em>). When <em>&lt;forms protection="All"&gt;</em> or <em>&lt;forms protection = "Encryption"&gt;</em>, then forms authentication hashes the forms authentication ticket by using either MD5 or HMACSHA1 (HMACSHA1 is used even if validation is set to AES or 3DES). Forms authentication then encrypts the ticket using the algorithm specified in the <em>decryption</em> attribute.</p>
  <h1>ViewState</h1>
  <p>You can protect <em>ViewState</em> in the following ways: </p>
  <ul>
    <li>Use an HMAC to make <em>ViewState</em> tamper proof. </li>
    <li>Use encryption to turn <em>ViewState</em> into unintelligible cipher text. This ensures that any sensitive data in <em>ViewState</em> cannot be viewed. </li>
  </ul>
  <p>To enable hashing of <em>ViewState</em>, you must use one of the following configurations.</p>
  <pre>&lt;pages enableViewStateMAC="true" ... /&gt; </pre>
  <p>or</p>
  <pre>&lt;%@Page EnableViewStateMac="true" ... %&gt;</pre>
  <p>To enable encryption of <em>ViewState</em>, you must use one of the following configurations.</p>
  <pre>&lt;pages viewStateEncryptionMode="Auto" ... /&gt;<br />&lt;pages viewStateEncryptionMode="Always" ... /&gt;</pre>
  <p>or</p>
  <pre>&lt;%@Page ViewStateEncryptionMode="Auto" ... %&gt;<br />&lt;%@Page ViewStateEncryptionMode="Always" ... %&gt;</pre>
  <p>With <em>viewStateEncryptionMode</em> set to <em>Auto</em>, the page is only encrypted if a control has specifically asked for it by calling the <em>Page.RegisterRequiresViewStateEncryption</em> method to request encryption. If it set to <em>Always</em>, this forces encryption even if a control does not request it. </p>
  <p>
    <b>Note:</b> Do not encrypt <em>ViewState</em> unless it contains sensitive data. To avoid the performance overhead of encryption, consider storing sensitive data on the server and not in <em>ViewState</em>.</p>
  <h2>Verifying that ViewState Is Tamper Proof</h2>
  <p>
    <em>ViewState</em> is tamper proof by default. <em>ViewState</em> tamper proofing is enabled by the <em>enableViewStateMac</em> attribute on the &lt;<em>pages</em>&gt; element and the <em>validationKey</em> and <em>validation</em> attributes on the &lt;<em>machineKey</em>&gt; element.</p>
  <p>
    <b>Note:</b> You can see the default &lt;<em>machineKey</em>&gt; setting in the <em>Machine.config.comments </em>file.</p>
  <p>
    <b>To verify that tamper proofing is enabled for <em>ViewState</em></b>
  </p>
  <ol>
    <li>Verify the <em>enableViewStateMac</em> attribute of the &lt;<em>pages</em>&gt; element is set to <em>true</em>, as shown in the following example. <pre>&lt;pages enableViewStateMac="true" ... /&gt;</pre><p><b>Note:</b> You can<b></b>override the machine's<strong></strong><em>enableViewStateMac</em> setting at the application or page level.</p></li>
    <li>Verify that the <em>validation</em> attribute of the &lt;<em>machineKey</em>&gt; element is set to SHA1, as shown in the following example. <pre>&lt;machineKey ...  validation="SHA1" ... /&gt;</pre><p>The <em>validation</em> attribute specifies the hashing algorithm used to tamper proof <em>ViewState</em>. The default value is <em>"SHA1"</em>, and you should use this rather than MD5 because it produces a larger hash than MD5 and is cryptographically stronger. </p></li>
    <li>Review the <em>validationKey</em> setting of the &lt;<em>machineKey</em>&gt; element. <pre>&lt;machineKey validationKey="AutoGenerate,IsolateApps" ... /&gt;</pre><p>In the default settings shown above, the <em>AutoGenerate</em> setting instructs ASP.NET to generate a random key. The <em>IsolateApps</em> modifier causes ASP.NET to generate a unique key for each application on your server by using the application ID of each application. </p><p>The default value is correct for a single server deployment. You do not need to change the default settings unless your application is deployed in a Web farm. In a Web farm, you must manually generate the <em>validationKey</em> value and make sure that it is the same on all servers in the farm. For more information, see the section, Web Farm Deployment Considerations in this document. </p></li>
  </ol>
  <h2>Configuring &lt;machineKey&gt; to Encrypt ViewState</h2>
  <p>By default, information in <em>ViewState</em> is encoded, but not encrypted. A user could decode and view the <em>ViewState</em> data.</p>
  <p>To encrypt <em>ViewState</em>, either a control on a page needs to explicitly request <em>ViewState</em> encryption or the <em>viewStateEncryptionMode</em> attribute of the &lt;<em>pages</em>&gt; element must be set to <em>Always</em>. To request encryption, a control must call the <em>RegisterRequiresViewStateEncryption</em> method of the <em>Page</em> class.</p>
  <p>The <em>viewStateEncryptionMode</em> attribute can take one of three possible attributes: </p>
  <ul>
    <li>
      <b>Auto.</b> This is the default setting, which means the <em>ViewState</em> on the page is only encrypted if a control has specifically asked for it. <p><b>Note:</b> If a control on the page requests encryption, then the entire <em>ViewState</em> is encrypted (not just the <em>ViewState</em> for the control).</p></li>
    <li>
      <b>Always.</b> This forces encryption even if a control does not ask for it. </li>
    <li>
      <b>Never.</b> This disables encryption even if a control does ask for it. </li>
  </ul>
  <p>Ideally, you should not store sensitive data in <em>ViewState</em> and thereby avoid the need to encrypt it. If you do need to encrypt <em>ViewState</em>, then you need to specify the encryption algorithm to use on the <em>validation</em> attribute.</p>
  <p>
    <b>To encrypt ViewState</b>
  </p>
  <ol>
    <li>Check that the <em>viewStateEncryptionMode</em> attribute of the &lt;<em>pages</em>&gt; element is set to <em>Always</em>, as shown in the following example. <pre>&lt;pages ... viewStateEncryptionMode="Always" ... /&gt;</pre><p>If you do not want every page to used encrypted <em>ViewState</em>, check that the <em>viewStateEncryptionMode</em> attribute of the &lt;<em>pages</em>&gt; element is set to <em>Auto</em>, as shown in the following example. </p><pre>&lt;pages ... viewStateEncryptionMode="Auto" ... /&gt;   </pre><p>Then, from within your code, call the <em>RegisterRequiresViewStateEncryption</em> method as shown in the following example. </p><pre>Page.RegisterRequiresViewStateEncryption();</pre></li>
    <li>Specify the encryption algorithm to use on the <em>validation</em> attribute, as shown in the following example. <pre>&lt;machineKey ... validation="AES" ... /&gt;</pre><p>The <em>validation</em> attribute is overloaded and can be used to specify either the hashing algorithm or the encryption algorithm. You can specify either 3DES or AES.&nbsp;Because AES offers larger key sizes (128 bits, 192 bits, or 256 bits) than 3DES, it is considered more secure and should be used. </p></li>
    <li>Review the <em>decryptionKey</em> attribute of the &lt;<em>machineKey</em>&gt; element: <pre>&lt;machineKey decryptionKey="AutoGenerate,IsolateApps" ... /&gt;</pre><p>Unless your application is installed in a Web farm, you should leave the <em>decryptionKey</em> attribute with the default values shown in the example. In a Web farm, you must manually generate the <em>decryptionKey</em> value and ensure that the value is the same across all servers in the farm. For more information, see the section, Web Farm Deployment Considerations in this document. </p></li>
  </ol>
  <p>For <em>ViewState</em> encryption, your &lt;<em>machineKey</em>&gt; configuration should resemble the following example</p>
  <pre>&lt;machineKey <br />&nbsp;&nbsp;&nbsp; validationKey="AutoGenerate,IsolateApps"&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; decryptionKey="AutoGenerate,IsolateApps" <br />&nbsp;&nbsp;&nbsp; validation="AES" <br />&nbsp;&nbsp;&nbsp; decryption="Auto" /&gt;</pre>
  <p>
    <b>Note:</b> By default, <em>ViewState</em> is transmitted as a Base64 encoded string. Although at first glance it is unintelligible, Base64 encoding provides no security because it is easily decoded. If you need to ensure that <em>ViewState</em> contents remain confidential, you must use encryption.</p>
  <h1>Forms Authentication Tickets</h1>
  <p>You can protect forms authentication tickets in two ways: </p>
  <ul>
    <li>Use an HMAC to make the ticket tamper proof. </li>
    <li>Use encryption to turn the ticket contents into unintelligible cipher text. This ensures that the data stored in the ticket, such as user names, cannot be viewed on the client or between the browser and server if the ticket is sent in a cookie. </li>
  </ul>
  <p>To ensure that forms authentication tickets are encrypted and protected against tampering, set the <em>protection</em> attribute of the &lt;<em>forms</em>&gt; element to <em>All</em>, as shown in the following example.</p>
  <pre>&lt;system.web&gt;<br />&nbsp; &lt;authentication mode="Forms"&gt;<br />&nbsp;&nbsp;&nbsp; &lt;forms name=".AuthCookie" loginUrl="login.aspx" protection="All"/&gt;<br />&nbsp; &lt;/authentication&gt;<br />&lt;/system.web&gt;</pre>
  <h2>Verifying that Forms Authentication Tickets Are Tamper Proof</h2>
  <p>By default, forms authentication tickets are configured for tamper proofing by using the <em>validationKey</em> and <em>validation</em> attributes of the &lt;<em>machineKey</em>&gt; element.</p>
  <p>
    <b>To review forms authentication ticket configuration for tamper proofing</b>
  </p>
  <ol>
    <li>Check that the <em>protection</em> attribute of the &lt;<em>forms</em>&gt; element to <em>All</em>, as shown in the following example. <pre>&lt;forms ... protection="All" ... /&gt;</pre><p>You can<b></b>override the <em>protection</em> attribute setting for all Web applications on the server by using the machine-level <em>Web.config</em> file or, for a specific application, by using its <em>Web.config</em> file. </p></li>
    <li>Review the <em>validation</em> attribute of the &lt;<em>machineKey</em>&gt; element, as shown in the following example. <pre>&lt;machineKey ... validation="SHA1" ... /&gt;</pre><p>The <em>validation</em> attribute specifies the hashing algorithm used by the HMAC algorithm used to tamper proof the forms authentication ticket. You should use the default SHA1 setting because this produces a larger hash than MD5 and is cryptographically stronger. </p><p>You do not need to change the default settings unless your application is deployed in a Web farm. In a Web farm, you must manually generate the <em>validationKey</em> value and make sure that the same value is used across all servers in the farm. For more information, see the section, Web Farm Deployment Considerations in this document. </p></li>
    <li>Review the <em>validationKey</em> attribute of the &lt;<em>machineKey</em>&gt; element , as shown in the following example. <pre>&lt;machineKey validationKey="AutoGenerate,IsolateApps" ... /&gt;</pre><p>The example configuration shows the default settings. The <em>AutoGenerate</em> setting instructs ASP.NET to generate a random key. The <em>IsolateApps</em> modifier causes ASP.NET to generate a unique key for each application on your server by using the application ID of each application. </p></li>
  </ol>
  <h2>Configuring &lt;machineKey&gt; to Encrypt Forms Authentication Tickets</h2>
  <p>To encrypt forms authentication tickets, ASP.NET uses the <em>decryptionKey</em> and the new <em>decryption</em> attribute of the &lt;<em>machineKey</em>&gt; element. The <em>decryption</em> attribute lets you specify the encryption algorithm to use. </p>
  <p>
    <b>To encrypt Form authentication tickets</b>
  </p>
  <ol>
    <li>Check that the <em>protection</em> attribute of the &lt;<em>forms</em>&gt; element is set to <em>All</em>, as shown in the following example. <pre>&lt;forms protection="All" ... /&gt;</pre></li>
    <li>Use the <em>decryption</em> attribute of the &lt;<em>machineKey</em>&gt; element to specify the encryption algorithm as shown in the following example. <a class="copyCode" href="javascript:CopyCode('ctl00_LibFrame_ctl24');"></a>&nbsp;<pre>&lt;machineKey decryption="Auto" ... /&gt;</pre><p>With the default <em>Auto</em> setting, if the value of the <em>decryptionKey</em> attribute is 8 bytes long (16 characters) then <em>Auto</em> defaults to DES. Otherwise, <em>Auto</em> defaults to AES. ASP.NET supports AES, 3DES and DES algorithms. You should use AES because it offers larger key sizes (128 bits, 192 bits, 256 bits) than 3DES. </p></li>
    <li>Review the <em>decryptionKey</em> attribute of the &lt;<em>machineKey</em>&gt; element. <pre>&lt;machineKey decryptionKey="AutoGenerate,IsolateApps" ... /&gt;</pre><p>Unless your application is installed in a Web farm or you need to share authentication tickets across two or more applications, you should leave the <em>decryptionKey</em> attribute with the default values shown in the example. In a Web farm or if you need to share authentication tickets across applications, you must manually generate the <em>decryptionKey</em> value and make sure that the same value is used for all servers in the farm. For more information, see the sections, Web Farm Deployment Considerations and Sharing Authentication Tickets Across Applications in this document. </p></li>
  </ol>
  <p>For forms authentication ticket encryption, the &lt;<em>machineKey</em>&gt; settings should resemble the following example.</p>
  <pre>&lt;machineKey <br />&nbsp; validationKey="AutoGenerate,IsolateApps" <br />&nbsp; decryptionKey="AutoGenerate,IsolateApps" <br />&nbsp; validation="AES" <br />&nbsp; decryption="Auto" /&gt;</pre>
  <h1>Membership</h1>
  <p>If you use the membership feature, password hashes are stored in the membership database by default. The membership system also supports encrypted passwords. If you select encrypted password format, then the &lt;<em>machineKey</em>&gt; settings are used when encrypting and decrypting the data. If you want to store encrypted passwords, use the following configuration in the Web.config file. Notice that <em>passwordFormat</em> is set to <em>"Encrypted"</em>.</p>
  <pre>&lt;membership defaultProvider="AspNetSqlMembershipProvider"<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; userIsOnlineTimeWindow="15" hashAlgorithmType=""&gt;<br />&nbsp; &lt;providers&gt;<br />&nbsp;&nbsp;&nbsp; &lt;clear /&gt;<br />&nbsp;&nbsp;&nbsp; &lt;add connectionStringName="LocalSqlServer" enablePasswordRetrieval="false" <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enablePasswordReset="true" requiresUniqueEmail="false"<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; passwordFormat="Encrypted" .../&gt;<br />&nbsp; &lt;/providers&gt;<br />&lt;/membership&gt;</pre>
  <p>
    <b>Note:</b> The default setting for the <em>passwordFormat </em>attribute is <em>"Hashed"</em>.</p>
  <h1>Anonymous Identification</h1>
  <p>ASP.NET supports anonymous identification, and you can encrypt the anonymous identification cookie. Encryption of the cookie uses the &lt;<em>machineKey</em>&gt; configuration. To enable anonymous identification, set <em>enabled="true"</em> on the &lt;<em>anonymousIdentification</em>&gt;<b></b>element in your <em>Web.config</em> file. To enable the cookies to be encrypted, set <em>cookieProtection="Encrypted"</em>, as shown here.</p>
  <pre>&lt;anonymousIdentification enabled="true" cookieName=".ASPXANONYMOUS"<br /> cookieTimeout="100000" cookiePath="/" cookieRequireSSL="false"<br /> cookieSlidingExpiration="true" cookieProtection="Encrypted"<br /> cookieless="UseCookies" domain="" /&gt;</pre>
  <p>The <em>cookieProtection</em> attribute can take any of the following values: </p>
  <ul>
    <li>
      <b>
        <em>"All"</em>
      </b> (to perform both validation and encryption) </li>
    <li>
      <em>"<b>Encryption</b>"</em>
    </li>
    <li>
      <em>"<b>Validation"</b></em> (the default) </li>
    <li>
      <em>"<b>None</b>"</em>
    </li>
  </ul>
  <h1>Role Cookies</h1>
  <p>ASP.NET also uses the &lt;<em>machineKey</em>&gt; settings to protect role cookies. The Role Manager can use role cookies to cache role names for a particular user. If you enable the Role Manager feature and elect to cache role names in the roles cookie, the default configuration in the <em>Machine.config.comments</em> file ensures that the roles cookie is tamper proof and encrypted. The <em>cookieProtection</em> attribute on the &lt;<em>roleManager</em>&gt; element is set to <em>All</em>.</p>
  <p>If you enable the Role Manager and cache role names, you can ensure that the cookie is protected by setting <em>cookieProtection="All"</em> as shown in the following code example.</p>
  <pre>&lt;roleManager enabled="true" <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cacheRolesInCookie="true"<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cookieProtection="All" ... /&gt;</pre>
  <h1>Web Farm Deployment Considerations</h1>
  <p>If you deploy your application in a Web farm, you must ensure that the configuration files on each server share the same value for <em>validationKey</em> and <em>decryptionKey</em>, which are used for hashing and decryption respectively. This is required because you cannot guarantee which server will handle successive requests.</p>
  <p>With manually generated key values, the &lt;<em>machineKey</em>&gt; settings should be similar to the following example.</p>
  <pre>&lt;machineKey&nbsp; <br /> validationKey="21F090935F6E49C2C797F69BBAAD8402ABD2EE0B667A8B44EA7DD4374267A75D7<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; AD972A119482D15A4127461DB1DC347C1A63AE5F1CCFAACFF1B72A7F0A281B"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> decryptionKey="ABAA84D7EC4BB56D75D217CECFFB9628809BDB8BF91CFCD64568A145BE59719F"<br /> validation="SHA1"<br /> decryption="AES"<br />/&gt;</pre>
  <p>If you want to isolate your application from other applications on the same server, place the &lt;<em>machineKey</em>&gt; in the <em>Web.config</em> file for each application on each server in the farm. Ensure that you use separate key values for each application, but duplicate each application's keys across all servers in the farm.</p>
  <h2>Generate Cryptographically Random Keys</h2>
  <p>To generate cryptographically random keys: </p>
  <ul>
    <li>Use the <em>RNGCryptoServiceProvider</em> class to generate a cryptographically strong random number. </li>
    <li>Choose an appropriate key size. The recommended key lengths are as follows: <ul><li>For SHA1, set the <em>validationKey</em> to 64 bytes (128 hexadecimal characters). </li><li>For AES, set the <em>decryptionKey</em> to 32 bytes (64 hexadecimal characters). </li><li>For 3DES, set the <em>decryptionKey</em> to 24 bytes (48 hexadecimal characters). </li></ul></li>
  </ul>
  <p>The following code shows how to generate random key values. Compile the code to create a console application, and then pass the required key size as a command line argument expressed as the desired number of hexadecimal characters. Each byte is represented by two hexadecimal characters; therefore, to request a 32-byte key, pass 64 as a command line argument. If you do not specify an argument, the code returns a 128 hexadecimal character (64-byte) key.</p>
  <h3>C# Example</h3>
  <pre>using System.Text;<br />using System.Security;<br />using System.Security.Cryptography;<br /><br />class App {<br />&nbsp; static void Main(string[] argv) {<br />&nbsp;&nbsp;&nbsp; int len = 128;<br />&nbsp;&nbsp;&nbsp; if (argv.Length &gt; 0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len = int.Parse(argv[0]);<br />&nbsp;&nbsp;&nbsp; byte[] buff = new byte[len/2];<br />&nbsp;&nbsp;&nbsp; RNGCryptoServiceProvider rng = new <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RNGCryptoServiceProvider();<br />&nbsp;&nbsp;&nbsp; rng.GetBytes(buff);<br />&nbsp;&nbsp;&nbsp; StringBuilder sb = new StringBuilder(len);<br />&nbsp;&nbsp;&nbsp; for (int i=0; i&lt;buff.Length; i++)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sb.Append(string.Format("{0:X2}", buff[i]));<br />&nbsp;&nbsp;&nbsp; Console.WriteLine(sb);<br />&nbsp; }<br />}</pre>
  <p>Run the application two times, and then copy and paste the resulting keys into the &lt;<em>machineKey</em>&gt; element—one time for <em>validationKey</em> and the other time for <em>decryptionKey</em>.</p>
  <h1>Sharing Authentication Tickets Across Applications</h1>
  <p>If you need a single logon to work across multiple applications located in separate virtual directories, you need to share a common authentication ticket. To configure a common authentication ticket, you must manually generate <em>validationKey</em> and <em>decryptionKey</em> values and ensure that each application shares these values.</p>
  <p>If you want to share tickets across all applications on your server you can set these manual values on the &lt;<em>machineKey</em>&gt; element in the machine level <em>Web.config</em> file. To share tickets across specific applications, you can use a &lt;<em>machineKey</em>&gt; element with common <em>validationKey</em> and <em>decryptionKey</em> values in the relevant application's <em>Web.config</em> files.</p>
  <p>For information about how to generate manual key values, see the section, "Web Farm Deployment Considerations," in this document.</p>
  <h1>Upgrading ASP.NET Versions</h1>
  <p>There is another important reason to explicitly set the &lt;<em>machineKey</em>&gt;. Each time you upgrade to a new version of ASP.NET, the key material used to automatically generate keys changes. Therefore, even if your application runs on a single Web server, if the keys need to remain stable over time, you should explicitly set the values for both <em>validation</em> and <em>decryption</em>.</p>
  <hr />
  <p>Adapted from Microsoft patterns & practices guidance.</p>