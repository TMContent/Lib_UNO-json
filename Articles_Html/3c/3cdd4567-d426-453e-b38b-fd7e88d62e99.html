<h2>Applies To</h2><ul><li> Java</li>
</ul><h2>What to Check For</h2><p>Verify that strong encryption keys are used.
</p><h2>Why</h2><p>Use strong encryption keys to make your encryption hard to break. The strength of the encryption keys used is one of the major factors determining the overall strength of a cryptographic solution.
</p><h2>How to Check</h2><p>To verify that strong encryption keys are used:
</p><ol>
<li> <strong>Identify encryption key strength requirements.</strong> The exact encryption key strength requirements are different for different algorithms. Current recommendations are 4096-bit keys for RSA and 256-bit keys for AES. </li>
<li> <strong>Identify the key generation method.</strong> Review the code used to generate cryptographic keys to identify the key generation method.</li>
<li> <strong>Determine whether the key generation method meets the strength requirements.</strong> Review the code used to generate cryptographic keys to make sure that it produces keys of sufficient length. It is also important to use a strong cryptographic pseudo-random number generator (PRNG) and to get a sufficiently large amount of entropy from it whenever random numbers are required by the key generation algorithm(s). Ideally, the amount of entropy (bits) read from the PRNG should match or exceed the length of the key. </li>
<li> <strong>Verify that key generation functions are used for encryption.</strong> Review the code that performs the encryption to make sure that it actually uses generated keys, as opposed to hard-coded keys, for example.</li>
</ol><h2>How to Fix</h2><p>To use strong encryption keys:
</p><ol>
<li> <strong>Identify encryption key strength requirements.</strong> The exact encryption key strength requirements are different for different algorithms. Current recommendations are 4096-bit keys for RSA and 256-bit keys for AES. </li>
<li> <strong>Determine a key generation method.</strong> The process of generating keys is different for symmetric and asymmetric encryption algorithms. <ol>
<li>Asymmetric algorithms have specific procedures for generating keys, because the public and the private keys have to match. Keys for asymmetric algorithms usually have to be generated using special functions that are bundled together with the asymmetric encryption algorithms. </li>
<li>Symmetric encryption keys can be generated with a cryptographically strong pseudo-random number generator, or can be derived from pass phrases. If split knowledge of the encryption key is required, it is possible to concatenate two separate pass phrases and then pass them through a sequence of strong cryptographic hash algorithms. When this split knowledge approach is used, both people have to enter their pass phrases separately, and their input is then concatenated and passed through the sequence of cryptohashing functions to produce the encryption key that can be used to encrypt and/or decrypt data. </li></ol></li>
<li> <strong>Implement key generation functions.</strong> Write code that implements the key generation method(s) required by the application. It is reasonable to implement pass phrase based key derivation, pseudo-random number generation, and asymmetric key generation so that all these functions are available if/when the application needs them.</li>
<li> <strong>Integrate key generation functions into the cryptographic solution.</strong> Encryption keys are themselves sensitive information and have to be handled appropriately. Key generation functionality should be integrated with the key management functionality in a manner that allows the keys to be stored securely immediately after they have been generated. Usually, this means the keys themselves have to be encrypted with another key that has already been generated. The exact key management procedures are different for different applications. One simple approach is to derive a "master key" from a pass phrase and then use this "master key" to encrypt other keys, which can be entirely random. For applications where split knowledge of the "master key" is required, it is possible to derive a key from two separate pass phrases by concatenating these pass phrases and then passing them through a sequence of cryptographic hash functions. </li>
</ol><h2>Additional Information</h2><ul><li> For information about generating random numbers for cryptography, see <a href="http://tools.ietf.org/html/rfc4086">http://tools.ietf.org/html/rfc4086</a></li>
</ul>