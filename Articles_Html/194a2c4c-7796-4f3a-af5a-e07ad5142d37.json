{
  "id": "194a2c4c-7796-4f3a-af5a-e07ad5142d37",
  "checksum": "031e5eb7c5b46a3d7f475990ec842da3b581b8b4",
  "words": {
    "0": [
      "pre",
      "p",
      "pre",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "pre",
      "strong",
      "strong"
    ],
    "1": [
      "ul",
      "li",
      "h1",
      "b"
    ],
    "2": [
      "ul",
      "li",
      "h1"
    ],
    "3": [
      "ul",
      "li",
      "h1",
      "ol",
      "li"
    ],
    "4": [
      "ul",
      "li",
      "h1"
    ],
    "5": [
      "table",
      "table",
      "table",
      "table",
      "tbody",
      "tbody",
      "tbody",
      "tbody",
      "tr",
      "tr",
      "tr",
      "tr",
      "td",
      "td",
      "td",
      "td",
      "p",
      "b",
      "p",
      "b",
      "p",
      "b",
      "p",
      "b"
    ],
    "9": [
      "table",
      "tbody",
      "tr",
      "td",
      "p"
    ],
    "13": [
      "table",
      "tbody",
      "tr",
      "td",
      "p"
    ],
    "32": [
      "p",
      "p",
      "pre",
      "strong"
    ],
    "37": [
      "table",
      "tbody",
      "tr",
      "td",
      "p"
    ],
    "69": [
      "table",
      "tbody",
      "tr",
      "td",
      "p"
    ],
    "133": [
      "table",
      "tbody",
      "tr",
      "td",
      "p"
    ],
    "261": [
      "table",
      "tbody",
      "tr",
      "td",
      "p"
    ],
    "517": [
      "table",
      "tbody",
      "tr",
      "td",
      "p"
    ],
    "999": [
      "p"
    ],
    "1029": [
      "table",
      "tbody",
      "tr",
      "td",
      "p"
    ],
    "2008": [
      "p"
    ],
    "16389": [
      "table",
      "tbody",
      "tr",
      "td",
      "p"
    ],
    "32773": [
      "table",
      "tbody",
      "tr",
      "td",
      "p"
    ],
    "65541": [
      "table",
      "tbody",
      "tr",
      "td",
      "p"
    ],
    "applies": [
      "h1"
    ],
    "to": [
      "h1",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "p",
      "b",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "title"
    ],
    "c++": [
      "ul",
      "li",
      "p"
    ],
    "summary": [
      "h1"
    ],
    "in": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "b",
      "p",
      "p",
      "p"
    ],
    "software": [
      "p"
    ],
    "security": [
      "p"
    ],
    "a": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "p",
      "b",
      "table",
      "table",
      "table",
      "table",
      "table",
      "table",
      "table",
      "table",
      "table",
      "table",
      "table",
      "table",
      "table",
      "table",
      "table",
      "tbody",
      "tbody",
      "tbody",
      "tbody",
      "tbody",
      "tbody",
      "tbody",
      "tbody",
      "tbody",
      "tbody",
      "tbody",
      "tbody",
      "tbody",
      "tbody",
      "tbody",
      "tr",
      "tr",
      "tr",
      "tr",
      "tr",
      "tr",
      "tr",
      "tr",
      "tr",
      "tr",
      "tr",
      "tr",
      "tr",
      "tr",
      "tr",
      "td",
      "td",
      "td",
      "td",
      "td",
      "td",
      "td",
      "td",
      "td",
      "td",
      "td",
      "td",
      "td",
      "td",
      "td",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "b",
      "p",
      "b",
      "p",
      "b",
      "p",
      "b",
      "p",
      "p"
    ],
    "buffer": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "h2",
      "em",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "b",
      "title"
    ],
    "underflow": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "h2",
      "em",
      "p",
      "p",
      "p",
      "p",
      "p",
      "title"
    ],
    "-or": [
      "p"
    ],
    "underrun-": [
      "p"
    ],
    "is": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "programming": [
      "p"
    ],
    "error": [
      "p"
    ],
    "that": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p"
    ],
    "occurs": [
      "p",
      "p",
      "p",
      "ol",
      "li"
    ],
    "due": [
      "p"
    ],
    "incorrect": [
      "p",
      "p",
      "p",
      "ol",
      "li",
      "p"
    ],
    "memory": [
      "p",
      "p",
      "p",
      "ol",
      "li",
      "p"
    ],
    "handling": [
      "p"
    ],
    "this": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "bug": [
      "p",
      "p",
      "p"
    ],
    "when": [
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "an": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "li"
    ],
    "application": [
      "p",
      "p",
      "p",
      "p",
      "ol",
      "li",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "p",
      "p"
    ],
    "uses": [
      "p",
      "p"
    ],
    "index": [
      "p",
      "p",
      "p",
      "pre",
      "p",
      "i",
      "p",
      "i",
      "p",
      "p",
      "p",
      "pre",
      "pre"
    ],
    "variable": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "access": [
      "p",
      "ol",
      "ol",
      "li",
      "li",
      "p"
    ],
    "and": [
      "p",
      "p",
      "ul",
      "li",
      "p",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "h1",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "b"
    ],
    "lets": [
      "p"
    ],
    "take": [
      "p",
      "p"
    ],
    "unexpected": [
      "p",
      "p"
    ],
    "value": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "li"
    ],
    "allowing": [
      "p"
    ],
    "it": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p"
    ],
    "reference": [
      "p"
    ],
    "segment": [
      "p"
    ],
    "outside": [
      "p",
      "p",
      "p",
      "p"
    ],
    "of": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "b",
      "p",
      "p",
      "p"
    ],
    "the": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "b",
      "b"
    ],
    "like": [
      "p",
      "p"
    ],
    "location": [
      "p",
      "p",
      "ol",
      "li",
      "p"
    ],
    "stack": [
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "li",
      "li",
      "p"
    ],
    "attackers": [
      "p",
      "p",
      "p"
    ],
    "use": [
      "p",
      "p",
      "p",
      "b",
      "p"
    ],
    "conditions": [
      "p"
    ],
    "write": [
      "p"
    ],
    "critical": [
      "p"
    ],
    "locations": [
      "p"
    ],
    "return": [
      "p",
      "p",
      "ol",
      "li",
      "pre",
      "p",
      "strong"
    ],
    "address": [
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "function": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "get": [
      "p"
    ],
    "execution": [
      "p",
      "p",
      "p",
      "ol",
      "li",
      "p",
      "p",
      "p"
    ],
    "control": [
      "p",
      "p",
      "ol",
      "li",
      "p"
    ],
    "target": [
      "p",
      "p",
      "p",
      "ol",
      "li"
    ],
    "follow": [
      "p",
      "p"
    ],
    "these": [
      "p",
      "p"
    ],
    "steps": [
      "p",
      "p"
    ],
    "test": [
      "p",
      "ul",
      "li",
      "h1",
      "p",
      "p",
      "h2",
      "em",
      "p",
      "ol",
      "ol",
      "li",
      "li",
      "b",
      "p",
      "p",
      "p",
      "p",
      "title"
    ],
    "for": [
      "p",
      "pre",
      "p",
      "p",
      "p",
      "p",
      "h2",
      "em",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "title"
    ],
    "underrun": [
      "p",
      "p"
    ],
    "vulnerabilities": [
      "p",
      "p"
    ],
    "step": [
      "ul",
      "ul",
      "ul",
      "ul",
      "li",
      "li",
      "li",
      "li",
      "h1",
      "h1",
      "h1",
      "ol",
      "li",
      "h1"
    ],
    "understand": [
      "ul",
      "li",
      "h1",
      "p",
      "p",
      "p"
    ],
    "attack": [
      "ul",
      "li",
      "h1",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "scenarios": [
      "ul",
      "li",
      "h1"
    ],
    "analyze": [
      "ul",
      "li",
      "h1"
    ],
    "causes": [
      "ul",
      "li",
      "h1",
      "p",
      "p",
      "ol",
      "li",
      "p"
    ],
    "countermeasures": [
      "ul",
      "li",
      "h1"
    ],
    "execute": [
      "ul",
      "ul",
      "li",
      "li",
      "h1",
      "p",
      "h1",
      "p",
      "p",
      "p"
    ],
    "cases": [
      "ul",
      "li",
      "h1",
      "p",
      "p",
      "p"
    ],
    "additional": [
      "ul",
      "li",
      "h1"
    ],
    "testing": [
      "ul",
      "li",
      "p",
      "p",
      "p",
      "p",
      "h1",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "first": [
      "p"
    ],
    "necessary": [
      "p",
      "p",
      "p"
    ],
    "anatomy": [
      "p"
    ],
    "vulnerability": [
      "p",
      "p",
      "p"
    ],
    "similar": [
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "overflow": [
      "p",
      "p",
      "p"
    ],
    "attacks": [
      "p",
      "p"
    ],
    "during": [
      "p"
    ],
    "attacker’s": [
      "p",
      "p"
    ],
    "main": [
      "p",
      "p"
    ],
    "goal": [
      "p",
      "p"
    ],
    "elevate": [
      "p"
    ],
    "his": [
      "p"
    ],
    "or": [
      "p",
      "p",
      "p",
      "p",
      "ol",
      "li",
      "p"
    ],
    "her": [
      "p"
    ],
    "privileges": [
      "p"
    ],
    "program": [
      "p",
      "p"
    ],
    "by": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "getting": [
      "p"
    ],
    "starts": [
      "p",
      "p"
    ],
    "submitting": [
      "p",
      "p",
      "ol",
      "li"
    ],
    "malformed": [
      "p"
    ],
    "input": [
      "p",
      "p",
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "pre",
      "pre",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "mainly": [
      "p"
    ],
    "attacker": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p"
    ],
    "submits": [
      "p",
      "ol",
      "ol",
      "li",
      "li"
    ],
    "strings": [
      "p",
      "p",
      "ol",
      "ol",
      "li",
      "li",
      "b",
      "p"
    ],
    "size": [
      "p"
    ],
    "order": [
      "p",
      "p"
    ],
    "cause": [
      "p"
    ],
    "indexing": [
      "p",
      "p",
      "p",
      "p"
    ],
    "once": [
      "p",
      "p"
    ],
    "discovers": [
      "p"
    ],
    "specific": [
      "p"
    ],
    "sized": [
      "p"
    ],
    "string": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "li",
      "li"
    ],
    "causing": [
      "p"
    ],
    "modifies": [
      "p"
    ],
    "include": [
      "p",
      "p"
    ],
    "shellcode": [
      "p",
      "p",
      "p",
      "p",
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li"
    ],
    "then": [
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "triggers": [
      "p",
      "ol",
      "li"
    ],
    "triggered": [
      "p"
    ],
    "able": [
      "p",
      "p"
    ],
    "overwrite": [
      "p"
    ],
    "vulnerable": [
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "with": [
      "p",
      "ol",
      "li",
      "p",
      "p",
      "p"
    ],
    "as": [
      "p",
      "ol",
      "li",
      "p",
      "p",
      "p",
      "ol",
      "li",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "unwinds": [
      "p",
      "ol",
      "li"
    ],
    "controlled": [
      "p",
      "p"
    ],
    "passed": [
      "p"
    ],
    "actual": [
      "p"
    ],
    "detail": [
      "p"
    ],
    "length": [
      "ol",
      "li",
      "p",
      "p",
      "ol",
      "ol",
      "li",
      "li",
      "p"
    ],
    "find": [
      "ol",
      "li"
    ],
    "offset": [
      "ol",
      "li"
    ],
    "upon": [
      "ol",
      "li"
    ],
    "triggering": [
      "ol",
      "li"
    ],
    "overwritten": [
      "ol",
      "li"
    ],
    "transferred": [
      "ol",
      "li"
    ],
    "next": [
      "p",
      "p"
    ],
    "what": [
      "p",
      "p"
    ],
    "how": [
      "p",
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p",
      "p",
      "title"
    ],
    "protect": [
      "p",
      "p"
    ],
    "against": [
      "p",
      "p"
    ],
    "them": [
      "p",
      "p",
      "p",
      "p"
    ],
    "underflows": [
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "are": [
      "p",
      "p",
      "p"
    ],
    "always": [
      "p",
      "p"
    ],
    "caused": [
      "p"
    ],
    "same": [
      "p"
    ],
    "reason": [
      "p"
    ],
    "takes": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "which": [
      "p",
      "p"
    ],
    "lower": [
      "p",
      "p"
    ],
    "than": [
      "p",
      "p"
    ],
    "start": [
      "p",
      "ol",
      "li"
    ],
    "why": [
      "p"
    ],
    "known": [
      "p"
    ],
    "following": [
      "p",
      "p",
      "p",
      "p"
    ],
    "compiled": [
      "p"
    ],
    "windows": [
      "p",
      "p",
      "p",
      "b"
    ],
    "vista": [
      "p"
    ],
    "using": [
      "p",
      "p",
      "p",
      "p"
    ],
    "visual": [
      "p"
    ],
    "indicates": [
      "p"
    ],
    "quantity": [
      "p"
    ],
    "padding": [
      "p",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "strong",
      "strong"
    ],
    "characters": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "asterisks).": [
      "p"
    ],
    "internal": [
      "p",
      "p",
      "p"
    ],
    "display": [
      "p"
    ],
    "copying": [
      "p"
    ],
    "asterisks": [
      "p"
    ],
    "indicated": [
      "p"
    ],
    "gets": [
      "p"
    ],
    "pointer": [
      "p",
      "pre",
      "pre",
      "strong",
      "p",
      "p",
      "i",
      "p",
      "pre",
      "pre"
    ],
    "where": [
      "p",
      "p",
      "p",
      "ol",
      "li"
    ],
    "last": [
      "p"
    ],
    "character": [
      "p",
      "ol",
      "li",
      "b"
    ],
    "was": [
      "p",
      "p"
    ],
    "copied": [
      "p"
    ],
    "concatenates": [
      "p"
    ],
    "rest": [
      "p"
    ],
    "finally": [
      "p",
      "p",
      "p"
    ],
    "prints": [
      "p"
    ],
    "padded": [
      "p"
    ],
    "int": [
      "pre",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "padandprintbufferchar*": [
      "pre",
      "p",
      "pre",
      "pre"
    ],
    "str": [
      "pre",
      "pre",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "index{": [
      "pre"
    ],
    "char*": [
      "pre"
    ],
    "=": [
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "strong",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "strong",
      "strong",
      "p",
      "p",
      "p",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "nullchar": [
      "pre",
      "p",
      "pre",
      "pre"
    ],
    "buffer1000]": [
      "pre",
      "p",
      "pre",
      "pre"
    ],
    "\"\"": [
      "pre"
    ],
    "i": [
      "pre",
      "pre",
      "pre",
      "pre",
      "p",
      "p",
      "pre",
      "pre",
      "pre",
      "pre"
    ],
    "i++buffer[i]": [
      "pre",
      "p",
      "pre",
      "pre"
    ],
    "'*'": [
      "pre"
    ],
    "&bufferindex];lstrcpya(pointer": [
      "pre",
      "p",
      "pre",
      "pre"
    ],
    "str;": [
      "pre"
    ],
    "printf\"%s\\n\",": [
      "pre"
    ],
    "buffer;": [
      "pre"
    ],
    "1}": [
      "pre",
      "p",
      "pre",
      "pre"
    ],
    "&bufferindex];": [
      "strong"
    ],
    "assumes": [
      "p"
    ],
    "will": [
      "p",
      "p"
    ],
    "within": [
      "p",
      "p"
    ],
    "boundaries": [
      "p"
    ],
    "between": [
      "p"
    ],
    "999.": [
      "p"
    ],
    "therefore": [
      "p"
    ],
    "call": [
      "p"
    ],
    "returns": [
      "p"
    ],
    "output": [
      "p",
      "p"
    ],
    "below": [
      "p"
    ],
    "padandprintbuffer\"aaaa\",": [
      "pre",
      "pre"
    ],
    "10;output:": [
      "pre"
    ],
    "*********aaaa": [
      "pre"
    ],
    "however": [
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "if": [
      "p",
      "p",
      "p",
      "strong",
      "ol",
      "ol",
      "li",
      "li",
      "p"
    ],
    "negative": [
      "p",
      "p",
      "p"
    ],
    "actually": [
      "p"
    ],
    "part": [
      "p"
    ],
    "lstrcpya": [
      "p",
      "i"
    ],
    "be": [
      "p",
      "p",
      "p"
    ],
    "stored": [
      "p"
    ],
    "example": [
      "p"
    ],
    "calling": [
      "p"
    ],
    "parameters": [
      "p"
    ],
    "instruction": [
      "p"
    ],
    "eip": [
      "p",
      "p"
    ],
    "filled": [
      "p"
    ],
    "choice": [
      "p"
    ],
    "-92;": [
      "pre"
    ],
    "result": [
      "p"
    ],
    "crashes": [
      "p"
    ],
    "points": [
      "p"
    ],
    "0x41414141": [
      "p"
    ],
    "code": [
      "p",
      "p",
      "p",
      "p",
      "p",
      "p"
    ],
    "must": [
      "p",
      "p",
      "p",
      "p"
    ],
    "padandprintbuffer": [
      "p"
    ],
    "common": [
      "p"
    ],
    "scenario": [
      "p"
    ],
    "happens": [
      "p"
    ],
    "performs": [
      "p"
    ],
    "manipulation": [
      "p"
    ],
    "used": [
      "p",
      "p"
    ],
    "d": [
      "p"
    ],
    "litchfield": [
      "p",
      "p"
    ],
    "proof-of-concept": [
      "p"
    ],
    "on": [
      "p",
      "p",
      "p",
      "b"
    ],
    "defeating": [
      "p"
    ],
    "protection": [
      "p"
    ],
    "mechanisms": [
      "p",
      "p",
      "b"
    ],
    "xpms)": [
      "p",
      "p",
      "b"
    ],
    "i].": [
      "p"
    ],
    "pads": [
      "p"
    ],
    "zero": [
      "p"
    ],
    "before": [
      "p"
    ],
    "displaying": [
      "p"
    ],
    "expects": [
      "p"
    ],
    "less": [
      "p"
    ],
    "passes": [
      "p"
    ],
    "longer": [
      "p"
    ],
    "overrun": [
      "p"
    ],
    "foochar": [
      "pre"
    ],
    "*str{int": [
      "pre"
    ],
    "0int": [
      "pre"
    ],
    "i=0char": [
      "pre"
    ],
    "*p=nullchar": [
      "pre"
    ],
    "buffer33]=\"\";//": [
      "pre"
    ],
    "ooops!padding": [
      "pre"
    ],
    "-": [
      "pre",
      "strong",
      "b"
    ],
    "strlenstr);for(": [
      "pre"
    ],
    "++i": [
      "pre"
    ],
    "buffer[i]": [
      "pre"
    ],
    "'0'//": [
      "pre"
    ],
    "ooops": [
      "pre"
    ],
    "again!p": [
      "pre"
    ],
    "&buffer": [
      "pre",
      "strong"
    ],
    ";lstrcpya(": [
      "pre"
    ],
    "p": [
      "pre",
      "strong"
    ],
    ";printf(\"%s\\n\",buffer);return": [
      "pre"
    ],
    "0}": [
      "pre"
    ],
    "strlenstr);": [
      "strong"
    ],
    ";": [
      "strong"
    ],
    "developers": [
      "p"
    ],
    "add": [
      "p"
    ],
    "checks": [
      "p"
    ],
    "values": [
      "p"
    ],
    "variables": [
      "p"
    ],
    "detect": [
      "p"
    ],
    "case": [
      "p",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "b"
    ],
    "above": [
      "p"
    ],
    "simple": [
      "p"
    ],
    "check": [
      "p",
      "ol",
      "li"
    ],
    "verify": [
      "p"
    ],
    "valid": [
      "p"
    ],
    "range": [
      "p"
    ],
    "would": [
      "p",
      "p"
    ],
    "have": [
      "p"
    ],
    "been": [
      "p"
    ],
    "enough": [
      "p"
    ],
    "mitigate": [
      "p"
    ],
    "index{if": [
      "p",
      "pre",
      "pre"
    ],
    "(index": [
      "p",
      "pre",
      "pre",
      "strong"
    ],
    "||index": [
      "p",
      "pre",
      "pre",
      "strong"
    ],
    "999)return": [
      "p",
      "pre",
      "pre"
    ],
    "0char*": [
      "p",
      "pre",
      "pre"
    ],
    "\"\"for": [
      "p",
      "pre",
      "pre"
    ],
    "'*'pointer": [
      "p",
      "pre",
      "pre"
    ],
    ";printf(\"%s\\n\",": [
      "p",
      "pre",
      "pre"
    ],
    "buffer;return": [
      "p",
      "pre",
      "pre"
    ],
    "999)": [
      "strong"
    ],
    "now": [
      "p"
    ],
    "you’ve": [
      "p"
    ],
    "revised": [
      "p"
    ],
    "theory": [
      "p"
    ],
    "pertaining": [
      "p"
    ],
    "bugs": [
      "p",
      "p",
      "p",
      "p",
      "title"
    ],
    "your": [
      "p",
      "p"
    ],
    "overflows": [
      "p",
      "p",
      "p"
    ],
    "whereas": [
      "p"
    ],
    "tester": [
      "p"
    ],
    "needs": [
      "p"
    ],
    "submit": [
      "p",
      "ol",
      "ol",
      "li",
      "li"
    ],
    "malicious": [
      "p"
    ],
    "different": [
      "p",
      "ol",
      "li",
      "p",
      "p"
    ],
    "modify": [
      "p"
    ],
    "into": [
      "p",
      "ol",
      "ol",
      "li",
      "li"
    ],
    "difficult": [
      "p"
    ],
    "achieve": [
      "p"
    ],
    "without": [
      "p"
    ],
    "knowledge": [
      "p"
    ],
    "application’s": [
      "p"
    ],
    "source": [
      "p"
    ],
    "possible": [
      "p"
    ],
    "way": [
      "p"
    ],
    "create": [
      "p"
    ],
    "shown": [
      "p"
    ],
    "previous": [
      "p"
    ],
    "section": [
      "p"
    ],
    "inappropriate": [
      "p"
    ],
    "recommended": [
      "p",
      "ol",
      "li",
      "p"
    ],
    "attach": [
      "ol",
      "li"
    ],
    "debugger": [
      "ol",
      "ol",
      "ol",
      "ol",
      "li",
      "li",
      "li",
      "li",
      "b"
    ],
    "determine": [
      "ol",
      "li"
    ],
    "data": [
      "ol",
      "ol",
      "li",
      "li",
      "b",
      "p"
    ],
    "you": [
      "ol",
      "ol",
      "li",
      "li",
      "p",
      "p"
    ],
    "single": [
      "ol",
      "li",
      "b"
    ],
    "such": [
      "ol",
      "li",
      "p"
    ],
    "a’s": [
      "ol",
      "li"
    ],
    "any": [
      "ol",
      "li",
      "p",
      "p"
    ],
    "other": [
      "ol",
      "li"
    ],
    "predetermined": [
      "ol",
      "li"
    ],
    "so": [
      "ol",
      "li"
    ],
    "can": [
      "ol",
      "li"
    ],
    "identify": [
      "ol",
      "li",
      "b"
    ],
    "violation": [
      "ol",
      "ol",
      "li",
      "li",
      "p"
    ],
    "see": [
      "ol",
      "ol",
      "li",
      "li"
    ],
    "figure": [
      "ol",
      "li",
      "b"
    ],
    "1.": [
      "ol",
      "li"
    ],
    "breaks": [
      "ol",
      "ol",
      "li",
      "li"
    ],
    "alter": [
      "ol",
      "li"
    ],
    "submitted": [
      "ol",
      "li"
    ],
    "affects": [
      "ol",
      "li"
    ],
    "expected": [
      "p"
    ],
    "results": [
      "p"
    ],
    "changes": [
      "p"
    ],
    "lengths": [
      "p",
      "p"
    ],
    "likely": [
      "p"
    ],
    "since": [
      "p"
    ],
    "accessing": [
      "p"
    ],
    "based": [
      "p"
    ],
    "string.": [
      "p"
    ],
    "x": [
      "table",
      "table",
      "table",
      "table",
      "table",
      "table",
      "table",
      "table",
      "table",
      "table",
      "table",
      "table",
      "table",
      "table",
      "table",
      "tbody",
      "tbody",
      "tbody",
      "tbody",
      "tbody",
      "tbody",
      "tbody",
      "tbody",
      "tbody",
      "tbody",
      "tbody",
      "tbody",
      "tbody",
      "tbody",
      "tbody",
      "tr",
      "tr",
      "tr",
      "tr",
      "tr",
      "tr",
      "tr",
      "tr",
      "tr",
      "tr",
      "tr",
      "tr",
      "tr",
      "tr",
      "tr",
      "td",
      "td",
      "td",
      "td",
      "td",
      "td",
      "td",
      "td",
      "td",
      "td",
      "td",
      "td",
      "td",
      "td",
      "td",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "p",
      "b",
      "p",
      "b",
      "p",
      "b",
      "p",
      "b"
    ],
    "…": [
      "table",
      "tbody",
      "tr",
      "td",
      "p"
    ],
    "max_path": [
      "table",
      "tbody",
      "tr",
      "td",
      "p",
      "b"
    ],
    "+": [
      "table",
      "table",
      "table",
      "table",
      "tbody",
      "tbody",
      "tbody",
      "tbody",
      "tr",
      "tr",
      "tr",
      "tr",
      "td",
      "td",
      "td",
      "td",
      "p",
      "b",
      "p",
      "b",
      "p",
      "b",
      "p",
      "b"
    ],
    "max_lengh": [
      "table",
      "tbody",
      "tr",
      "td",
      "p",
      "b"
    ],
    "max_buffer": [
      "table",
      "tbody",
      "tr",
      "td",
      "p",
      "b"
    ],
    "buffer_size": [
      "table",
      "tbody",
      "tr",
      "td",
      "p",
      "b"
    ],
    "extend": [
      "p"
    ],
    "automation": [
      "p",
      "p",
      "p"
    ],
    "automated": [
      "p",
      "p"
    ],
    "number": [
      "p"
    ],
    "short": [
      "p"
    ],
    "time": [
      "p",
      "p"
    ],
    "amount": [
      "p"
    ],
    "otherwise": [
      "p"
    ],
    "be impossible": [
      "p"
    ],
    "hand": [
      "p"
    ],
    "methods": [
      "p",
      "p"
    ],
    "ones": [
      "p",
      "p"
    ],
    "random": [
      "p"
    ],
    "fuzz": [
      "p"
    ],
    "replacing": [
      "p"
    ],
    "escape": [
      "p"
    ],
    "special": [
      "p"
    ],
    "performing": [
      "p"
    ],
    "bit-wise": [
      "p"
    ],
    "operations": [
      "p"
    ],
    "conclusions": [
      "h1"
    ],
    "dangerous": [
      "p"
    ],
    "they": [
      "p"
    ],
    "allow": [
      "p"
    ],
    "remote": [
      "p"
    ],
    "applications": [
      "p"
    ],
    "well": [
      "p",
      "p"
    ],
    "local": [
      "p"
    ],
    "privileged": [
      "p",
      "p"
    ],
    "from": [
      "p"
    ],
    "low": [
      "p"
    ],
    "learn": [
      "p"
    ],
    "important": [
      "p"
    ],
    "exploit": [
      "p"
    ],
    "countermeasure": [
      "p"
    ],
    "expand": [
      "p"
    ],
    "cover": [
      "p"
    ],
    "i]": [
      "p"
    ],
    "underruns": [
      "p",
      "b"
    ],
    "dep": [
      "p",
      "b"
    ],
    "aslr": [
      "p",
      "b"
    ],
    "improving": [
      "p",
      "b"
    ],
    "exploitation": [
      "p",
      "b"
    ],
    "prevention": [
      "p",
      "b"
    ],
    "platform": [
      "p",
      "b"
    ],
    "david": [
      "p"
    ],
    "wwwngssoftware.com/papers/xpms.pdf": [
      "p",
      "a"
    ]
  },
  "tags": {
    "h1": [
      "Applies to",
      "Summary",
      "Step 1: Understand Attack Scenarios",
      "Step 2: Analyze Causes and Countermeasures",
      "Step 3: Execute Test Cases",
      "Step 4: Execute Additional Testing",
      "Conclusions"
    ],
    "ul": [
      "C++",
      "Step 1: Understand attack scenarios \n    Step 2: Analyze causes and countermeasures \n    Step 3: Execute test cases \n    Step 4: Execute additional testing"
    ],
    "li": [
      "C++",
      "Step 1: Understand attack scenarios",
      "Step 2: Analyze causes and countermeasures",
      "Step 3: Execute test cases",
      "Step 4: Execute additional testing",
      "The attacker submits input of incorrect length to find a buffer underflow.",
      "The attacker submits the shellcode and shellcode offset as input to the application and triggers the buffer underflow. Upon triggering the underflow, a return address in the stack is overwritten with the address of the shellcode.",
      "The stack unwinds and execution control is transferred to the shellcode.",
      "Attach a debugger to the target application.",
      "Determine how to submit test case data.",
      "Start submitting strings of different length. It is recommended that you submit strings of a single character such as a string of A’s or any other predetermined value so that you can identify the test case data in the debugger in case it causes an access violation (see Figure 1).",
      "Check if the application breaks into the debugger.",
      "If the application breaks into the debugger, alter the length of the string submitted in step 3 to see how it affects the memory location where the access violation occurs."
    ],
    "p": [
      "",
      "In software security, a buffer underflow -or underrun- is a programming error that occurs due to incorrect memory handling. This bug occurs when an application uses an index variable to access a memory buffer and lets this variable take an unexpected value, allowing it to reference a memory segment outside of the buffer like a location in the stack. Attackers use buffer underflow conditions to write to critical stack locations like the return address of a function and get execution control of the target application.",
      "Follow these steps to test for buffer underrun vulnerabilities:",
      "",
      "First, it is necessary to understand the anatomy of a buffer underflow vulnerability. Similar to buffer overflow attacks, during this attack the attacker’s main goal is to elevate his or her privileges in the target program by getting execution control of the target.",
      "The attack starts by submitting malformed input to the application. Mainly, the attacker submits input strings of incorrect size in order to cause an indexing variable to take an incorrect value. Once the attacker discovers that a specific sized string is causing a buffer underflow, the attacker modifies the attack string to include the shellcode and the address of the shellcode. Then the attacker triggers the underflow by submitting the attack string to the application. Once the underflow is triggered the attacker is able to overwrite a return address of the vulnerable function with the address of the shellcode. Then, as the stack unwinds, the execution controlled is passed to the actual shellcode.",
      "In detail:",
      "",
      "Next, it is necessary to understand what causes buffer underflow vulnerabilities and how to protect against them.",
      "Buffer underflows are always caused by the same reason: an indexing variable takes an unexpected value which is lower than the address of the start of the buffer; this is why this bug is known as an underflow or underrun.",
      "The following function (compiled in Windows Vista using Visual C++ 2008) takes an input buffer and an index variable that indicates quantity of padding characters (asterisks). The function uses an internal display buffer to which it starts copying the asterisks characters indicated by the index variable. Then the function gets a pointer to the location next to where the last padding character was copied and concatenates the rest of the string to the buffer. Finally the function prints the padded buffer.",
      "The function assumes that the index variable will always within the boundaries of the buffer internal (between 0 and 999). Therefore, the following call returns the output below:",
      "However, if the index variable is negative then the pointer variable takes an address outside of the buffer. It actually takes an address in the lower part of the stack, where the return address for the lstrcpyA function will be stored. For this example, calling the vulnerable function with the following parameters causes the instruction pointer EIP to be filled with an address controlled by the attacker’s choice:",
      "The output result is that the program crashes and EIP points to 0x41414141.",
      "However, in order to use this vulnerable code for a buffer underflow attack, an attacker must control the input to the padAndPrintBuffer function. A common scenario where this happens is when an application performs padding or internal manipulation of strings. The following code was used by D. Litchfield as a proof-of-concept on defeating Execution Protection Mechanisms (XPMs) in Windows [i]. It takes an input string and pads it with zero characters before displaying it. However, the function expects an input string of 32 characters or less. If an attacker passes a string longer than 32 characters the padding variable takes a negative value and the overrun occurs:",
      "To protect against this vulnerability developers must add code that checks the values of indexing variables to detect an index that is outside of the buffer. In the case above, a simple check to verify if the index is within a valid range (0 to 999) would have been enough to mitigate the attack.",
      "int padAndPrintBuffer(char* str, int index){if ((index < 0) ||(index > 999))return 0;char* pointer = NULL;char buffer[1000] = \"\";for (int i = 0; i < index; i++)buffer[i] = '*';pointer = &buffer[index];lstrcpyA(pointer , str );printf(\"%s\\n\", buffer);return 1;}",
      "Now that you’ve revised the theory pertaining to buffer underflow bugs, it is necessary to execute test cases to test for this vulnerability in your application.",
      "Testing for buffer underflows is similar to testing for buffer overflows whereas the tester needs to submit malicious input of incorrect length to the application. However, different to buffer overflow testing, your main goal when testing for underflows is to modify an indexing variable into a negative value, and this is difficult to achieve without knowledge of the application’s source code. However a possible way to create an underflow, as shown in the previous section, is to use input of inappropriate length.",
      "It is recommended to follow these steps to test for underflows:",
      "Expected results: if the location of the access violation changes for different input lengths it is likely that the application is vulnerable to a buffer underflow bug (since the application is accessing memory outside of the buffer based on the length of the input string).",
      "A x 9",
      "A x 13",
      "A x 37",
      "A x 69",
      "A x 133",
      "A x 261",
      "A x 517",
      "A x 1029",
      "…",
      "A x 16389",
      "A x 32773",
      "A x 65541",
      "A x MAX_PATH + 5",
      "A x MAX_LENGH + 5",
      "A x MAX_BUFFER + 5",
      "A x BUFFER_SIZE + 5",
      "",
      "",
      "Finally, it is recommended to extend any test automation to include testing for buffer underflow bugs. Automated testing is able to execute a number of test cases in a short time amount of time that would be otherwise be impossible to execute by hand. The automated testing methods to use for buffer underflow bugs are similar to the ones used in buffer overflow testing such as using random fuzz data, replacing escape or special characters, and performing bit-wise operations.",
      "",
      "Buffer underflows are dangerous as they allow for remote code execution in vulnerable applications as well as local privileged code execution attacks from low privileged attackers. To learn how to test for them it is important to understand how attackers exploit them as well as what causes and how to countermeasure them. Then you must execute test cases similar to the ones when testing buffer overflows using attack strings of different lengths. Finally, you must expand any automation to cover buffer underflow bugs using similar automation methods as when testing for buffer overflows.",
      "",
      "[i] Buffer Underruns, DEP, ASLR and improving the Exploitation Prevention Mechanisms (XPMs) on the Windows platform. David Litchfield. www.ngssoftware.com/papers/xpms.pdf"
    ],
    "ol": [
      "The attacker submits input of incorrect length to find a buffer underflow. \n    The attacker submits the shellcode and shellcode offset as input to the application and triggers the buffer underflow. Upon triggering the underflow, a return address in the stack is overwritten with the address of the shellcode. \n    The stack unwinds and execution control is transferred to the shellcode.",
      "Attach a debugger to the target application. \n    Determine how to submit test case data. \n    Start submitting strings of different length. It is recommended that you submit strings of a single character such as a string of A’s or any other predetermined value so that you can identify the test case data in the debugger in case it causes an access violation (see Figure 1).\n    Check if the application breaks into the debugger. \n    If the application breaks into the debugger, alter the length of the string submitted in step 3 to see how it affects the memory location where the access violation occurs."
    ],
    "b": [
      "",
      "Figure 1 - Use strings of a single character to identify test case data in debugger",
      "A x MAX_PATH + 5",
      "A x MAX_LENGH + 5",
      "A x MAX_BUFFER + 5",
      "A x BUFFER_SIZE + 5",
      "Buffer Underruns, DEP, ASLR and improving the Exploitation Prevention Mechanisms (XPMs) on the Windows platform"
    ],
    "pre": [
      "int padAndPrintBuffer(char* str, int index){ char* pointer = NULL;char buffer[1000] = \"\";      for (int i = 0; i < index; i++)buffer[i] = '*'; pointer = &buffer[index];lstrcpyA(pointer , str); printf(\"%s\\n\", buffer); return 1;}",
      "input: padAndPrintBuffer(\"AAAA\", 10);output: *********AAAA",
      "input: padAndPrintBuffer(\"AAAA\", -92);",
      "int foo(char *str){int padding = 0;int i=0;char *p=NULL;char buffer[33]=\"\";// Ooops!padding = 32 - strlen(str);for( i = 0; i < padding; ++i )buffer[i] = '0';// Ooops, again!p = &buffer[ padding ];lstrcpyA( p , str );printf(\"%s\\n\",buffer);return 0;}",
      "int padAndPrintBuffer(char* str, int index){if ((index < 0) ||(index > 999))return 0;char* pointer = NULL;char buffer[1000] = \"\";for (int i = 0; i < index; i++)buffer[i] = '*';pointer = &buffer[index];lstrcpyA(pointer , str );printf(\"%s\\n\", buffer);return 1;}",
      "int padAndPrintBuffer(char* str, int index){if ((index < 0) ||(index > 999))return 0;char* pointer = NULL;char buffer[1000] = \"\";for (int i = 0; i < index; i++)buffer[i] = '*';pointer = &buffer[index];lstrcpyA(pointer , str );printf(\"%s\\n\", buffer);return 1;}"
    ],
    "br": [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
    ],
    "strong": [
      "pointer = &buffer[index];",
      "padding = 32 - strlen(str);",
      "p = &buffer[ padding ];",
      "if ((index < 0) ||(index > 999))",
      "return 0",
      "",
      ""
    ],
    "i": [
      "index",
      "index",
      "pointer",
      "lstrcpyA",
      ""
    ],
    "h2": [
      "Test for buffer underflow"
    ],
    "em": [
      "Test for buffer underflow"
    ],
    "table": [
      "A x 9 \n          A x 13 \n          A x 37\n          A x 69\n          A x 133\n          A x 261\n          A x 517\n          A x 1029\n          …\n          A x 16389\n          A x 32773\n          A x 65541\n          \n            A x MAX_PATH + 5\n          \n          \n            A x MAX_LENGH + 5\n          \n          \n            A x MAX_BUFFER + 5\n          \n          \n            A x BUFFER_SIZE + 5"
    ],
    "tbody": [
      "A x 9 \n          A x 13 \n          A x 37\n          A x 69\n          A x 133\n          A x 261\n          A x 517\n          A x 1029\n          …\n          A x 16389\n          A x 32773\n          A x 65541\n          \n            A x MAX_PATH + 5\n          \n          \n            A x MAX_LENGH + 5\n          \n          \n            A x MAX_BUFFER + 5\n          \n          \n            A x BUFFER_SIZE + 5"
    ],
    "tr": [
      "A x 9 \n          A x 13 \n          A x 37\n          A x 69\n          A x 133\n          A x 261\n          A x 517\n          A x 1029\n          …\n          A x 16389\n          A x 32773\n          A x 65541\n          \n            A x MAX_PATH + 5\n          \n          \n            A x MAX_LENGH + 5\n          \n          \n            A x MAX_BUFFER + 5\n          \n          \n            A x BUFFER_SIZE + 5"
    ],
    "td": [
      "A x 9 \n          A x 13 \n          A x 37\n          A x 69\n          A x 133\n          A x 261\n          A x 517\n          A x 1029\n          …\n          A x 16389\n          A x 32773\n          A x 65541\n          \n            A x MAX_PATH + 5\n          \n          \n            A x MAX_LENGH + 5\n          \n          \n            A x MAX_BUFFER + 5\n          \n          \n            A x BUFFER_SIZE + 5"
    ],
    "hr": [
      ""
    ],
    "a": [
      "www.ngssoftware.com/papers/xpms.pdf"
    ]
  },
  "links": [
    {
      "href": "http://www.ngssoftware.com/papers/xpms.pdf",
      "text": "www.ngssoftware.com/papers/xpms.pdf"
    }
  ],
  "html": "<h1>Applies to</h1>\n  <ul>\n    <li>C++</li>\n  </ul>\n  <p />\n  <h1>Summary</h1>\n  <p>In software security, a buffer underflow -or underrun- is a programming error that occurs due to incorrect memory handling. This bug occurs when an application uses an index variable to access a memory buffer and lets this variable take an unexpected value, allowing it to reference a memory segment outside of the buffer like a location in the stack. Attackers use buffer underflow conditions to write to critical stack locations like the return address of a function and get execution control of the target application.</p>\n  <p>Follow these steps to test for buffer underrun vulnerabilities:</p>\n  <ul>\n    <li>Step 1: Understand attack scenarios </li>\n    <li>Step 2: Analyze causes and countermeasures </li>\n    <li>Step 3: Execute test cases </li>\n    <li>Step 4: Execute additional testing</li>\n  </ul>\n  <p />\n  <h1>Step 1: Understand Attack Scenarios </h1>\n  <p>First, it is necessary to understand the anatomy of a buffer underflow vulnerability. Similar to buffer overflow attacks, during this attack the attacker’s main goal is to elevate his or her privileges in the target program by getting execution control of the target. </p>\n  <p>The attack starts by submitting malformed input to the application. Mainly, the attacker submits input strings of incorrect size in order to cause an indexing variable to take an incorrect value. Once the attacker discovers that a specific sized string is causing a buffer underflow, the attacker modifies the attack string to include the shellcode and the address of the shellcode. Then the attacker triggers the underflow by submitting the attack string to the application. Once the underflow is triggered the attacker is able to overwrite a return address of the vulnerable function with the address of the shellcode. Then, as the stack unwinds, the execution controlled is passed to the actual shellcode.</p>\n  <p>In detail:</p>\n  <ol>\n    <li>The attacker submits input of incorrect length to find a buffer underflow. </li>\n    <li>The attacker submits the shellcode and shellcode offset as input to the application and triggers the buffer underflow. Upon triggering the underflow, a return address in the stack is overwritten with the address of the shellcode. </li>\n    <li>The stack unwinds and execution control is transferred to the shellcode.</li>\n  </ol>\n  <p>\n    <b>\n    </b>\n  </p>\n  <h1>Step 2: Analyze Causes and Countermeasures</h1>\n  <p>Next, it is necessary to understand what causes buffer underflow vulnerabilities and how to protect against them. </p>\n  <p>Buffer underflows are always caused by the same reason: an indexing variable takes an unexpected value which is lower than the address of the start of the buffer; this is why this bug is known as an underflow or underrun. </p>\n  <p>The following function (compiled in Windows Vista using Visual C++ 2008) takes an input buffer and an index variable that indicates quantity of padding characters (asterisks). The function uses an internal display buffer to which it starts copying the asterisks characters indicated by the index variable. Then the function gets a pointer to the location next to where the last padding character was copied and concatenates the rest of the string to the buffer. Finally the function prints the padded buffer.</p>\n  <pre>int padAndPrintBuffer(char* str, int index)<br />{ <br />char* pointer = NULL;<br />char buffer[1000] = \"\";      <br />for (int i = 0; i &lt; index; i++)<br />buffer[i] = '*'; <br /><strong>pointer = &buffer[index];</strong><br />lstrcpyA(pointer , str); <br />printf(\"%s\\n\", buffer); <br />return 1;<br />}<br /></pre>\n  <p>The function assumes that the <i>index</i> variable will always within the boundaries of the buffer internal (between 0 and 999). Therefore, the following call returns the output below:</p>\n  <pre>input: padAndPrintBuffer(\"AAAA\", 10);<br />output: *********AAAA    </pre>\n  <p>However, if the <i>index</i> variable is negative then the <i>pointer</i> variable takes an address outside of the buffer. It actually takes an address in the lower part of the stack, where the return address for the <i>lstrcpyA</i> function will be stored. For this example, calling the vulnerable function with the following parameters causes the instruction pointer EIP to be filled with an address controlled by the attacker’s choice:</p>\n  <pre>input: padAndPrintBuffer(\"AAAA\", -92);</pre>\n  <p>The output result is that the program crashes and EIP points to 0x41414141. </p>\n  <p>However, in order to use this vulnerable code for a buffer underflow attack, an attacker must control the input to the padAndPrintBuffer function. A common scenario where this happens is when an application performs padding or internal manipulation of strings. The following code was used by D. Litchfield as a proof-of-concept on defeating Execution Protection Mechanisms (XPMs) in Windows [i]. It takes an input string and pads it with zero characters before displaying it. However, the function expects an input string of 32 characters or less. If an attacker passes a string longer than 32 characters the padding variable takes a negative value and the overrun occurs:</p>\n  <pre>int foo(char *str)<br />{<br />int padding = 0;<br />int i=0;<br />char *p=NULL;<br />char buffer[33]=\"\";<br /><br />// Ooops!<br /><strong>padding = 32 - strlen(str);</strong><br />for( i = 0; i &lt; padding; ++i )<br />buffer[i] = '0';<br /><br />// Ooops, again!<br /><strong>p = &buffer[ padding ];</strong><br />lstrcpyA( p , str );<br />printf(\"%s\\n\",buffer);<br />return 0;<br />}<br /></pre>\n  <p>To protect against this vulnerability developers must add code that checks the values of indexing variables to detect an index that is outside of the buffer. In the case above, a simple check to verify if the index is within a valid range (0 to 999) would have been enough to mitigate the attack.</p>\n  <p />\n  <pre>\n    <pre>int padAndPrintBuffer(char* str, int index)<br />{<br /><strong>if ((index &lt; 0) ||(index &gt; 999))</strong><br /><strong>return 0</strong>;<br />char* pointer = NULL;<br />char buffer[1000] = \"\";<br />for (int i = 0; i &lt; index; i++)<br />buffer[i] = '*';<br />pointer = &buffer[index];<br />lstrcpyA(pointer , str );<br />printf(\"%s\\n\", buffer);<br />return 1;<br />}</pre>\n  </pre>\n  <h1>Step 3: Execute Test Cases</h1>\n  <p>Now that you’ve revised the theory pertaining to buffer underflow bugs, it is necessary to execute test cases to test for this vulnerability in your application.</p>\n  <h2>\n    <em>Test for buffer underflow</em>\n  </h2>\n  <p>Testing for buffer underflows is similar to testing for buffer overflows whereas the tester needs to submit malicious input of incorrect length to the application. However, different to buffer overflow testing, your main goal when testing for underflows is to modify an indexing variable into a negative value, and this is difficult to achieve without knowledge of the application’s source code. However a possible way to create an underflow, as shown in the previous section, is to use input of inappropriate length.</p>\n  <p>It is recommended to follow these steps to test for underflows:</p>\n  <ol>\n    <li>Attach a debugger to the target application. </li>\n    <li>Determine how to submit test case data. </li>\n    <li>Start submitting strings of different length. It is recommended that you submit strings of a single character such as a string of A’s or any other predetermined value so that you can identify the test case data in the debugger in case it causes an access violation (see Figure 1).</li>\n    <li>Check if the application breaks into the debugger. </li>\n    <li>If the application breaks into the debugger, alter the length of the string submitted in step 3 to see how it affects the memory location where the access violation occurs.</li>\n  </ol>\n  <p>Expected results: if the location of the access violation changes for different input lengths it is likely that the application is vulnerable to a buffer underflow bug (since the application is accessing memory outside of the buffer based on the length of the input string).</p>\n  <b>Figure 1 - Use strings of a single character to identify test case data in debugger</b>\n  <table>\n    <tbody>\n      <tr>\n        <td>\n          <p>A x 9 </p>\n          <p>A x 13 </p>\n          <p>A x 37</p>\n          <p>A x 69</p>\n          <p>A x 133</p>\n          <p>A x 261</p>\n          <p>A x 517</p>\n          <p>A x 1029</p>\n          <p>…</p>\n          <p>A x 16389</p>\n          <p>A x 32773</p>\n          <p>A x 65541</p>\n          <p>\n            <b>A x MAX_PATH + 5</b>\n          </p>\n          <p>\n            <b>A x MAX_LENGH + 5</b>\n          </p>\n          <p>\n            <b>A x MAX_BUFFER + 5</b>\n          </p>\n          <p>\n            <b>A x BUFFER_SIZE + 5</b>\n          </p>\n        </td>\n      </tr>\n    </tbody>\n  </table>\n  <p>\n    <strong>\n    </strong>&nbsp;</p>\n  <p>\n    <strong>\n    </strong>\n  </p>\n  <h1>Step 4: Execute Additional Testing</h1>\n  <p>Finally, it is recommended to extend any test automation to include testing for buffer underflow bugs. Automated testing is able to execute a number of test cases in a short time amount of time that would be otherwise be&nbsp;impossible to execute by hand. The automated testing methods to use for buffer underflow bugs are similar to the ones used in buffer overflow testing such as using random fuzz data, replacing escape or special characters, and performing bit-wise operations.</p>\n  <p>\n    <i>\n    </i>\n  </p>\n  <h1>Conclusions</h1>\n  <p>Buffer underflows are dangerous as they allow for remote code execution in vulnerable applications as well as local privileged code execution attacks from low privileged attackers. To learn how to test for them it is important to understand how attackers exploit them as well as what causes and how to countermeasure them. Then you must execute test cases similar to the ones when testing buffer overflows using attack strings of different lengths. Finally, you must expand any automation to cover buffer underflow bugs using similar automation methods as when testing for buffer overflows.</p>\n  <p />\n  <br />\n  <hr />\n  <p>[i] <b>Buffer Underruns, DEP, ASLR and improving the Exploitation Prevention Mechanisms (XPMs) on the Windows platform</b>. David Litchfield. <a href=\"http://www.ngssoftware.com/papers/xpms.pdf\">www.ngssoftware.com/papers/xpms.pdf</a></p>"
}