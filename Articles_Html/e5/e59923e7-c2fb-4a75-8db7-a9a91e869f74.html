<h2>Applies To</h2>
<ul>
<li>ASP.NET 4.0+</li>
</ul>
<h2>Solution Example</h2>
<ol>
<li>
<p><strong>Enforce numeric range constraints.</strong> Use the RangeValidator control to ensure any numeric values are constrained to a specific, acceptable range. Here is an example that declares an integer field in an ASP page that has a valid range from 1 to 50:</p>
<pre><code>&lt;td&gt;
  &lt;asp:RangeValidator id=&quot;Range1&quot;
		   ControlToValidate=&quot;txtState&quot;
		   MinimumValue=&quot;1&quot;
		   MaximumValue=&quot;50&quot;
		   Type=&quot;Integer&quot;
		   EnableClientScript=&quot;false&quot;
		   Text=&quot;The value must be from 1 to 10!&quot;
		   runat=&quot;server&quot;&gt;
  &lt;/asp:RangeValidator&gt;&lt;/td&gt;
&lt;td&gt;State:&lt;/td&gt;
&lt;td&gt;&lt;input type=text runat=server id=txtState&gt;&lt;/td&gt;
</code></pre>
</li>
<li>
<p><strong>Validate verification fields.</strong> Fields such as password entry are often verified by having the user re-type them to ensure they are correct. Use the CompareValidator control to make the comparisons and ensure validity/integrity. Here is an example that declares two password fields in an ASP page that must match in order to validate properly:</p>
<pre><code>&lt;asp:CompareValidator runat=server
			ControlToValidate=txtRePWord
			ControlToCompare=txtPWord
			ErrorMessage=&quot;Passwords do not match.&quot; /&gt;
</code></pre>
<p>In this case, the two fields being compared are &quot;txtPWord&quot; and &quot;txtRePWord&quot;. If they do not match, validation fails with the error message, &quot;Passwords do not match.&quot;.</p>
</li>
<li>
<p><strong>Enforce type constraints on string fields.</strong> String fields are the most difficult type of input to effectively validate because the range of acceptable characters is much larger than numeric and enumerated types. Regular expressions provide a flexible mechanism for dictating valid patterns and characters. Use the RegularExpressionValidator to perform a variety of checks on string-based fields such as zip codes and phone numbers. Here is an example that declares a text field in an ASP page that should represent a five digit zip code, consisting entirely of numeric digits, and a validator to enforce those constraints:</p>
<pre><code>&lt;input type=text runat=server id=txtZip&gt;
	  &lt;asp:RegularExpressionValidator runat=server
			 ControlToValidate=&quot;txtZip&quot;
			 ErrorMessage=&quot;Zip code must be 5 digits, all numbers.&quot;
			 ValidationExpression=&quot;[0-9]{5}&quot;&gt; 
	  &lt;/asp:RegularExpressionValidator&gt;&lt;td&gt;Zip code:&lt;/td&gt;
&lt;td&gt;&lt;input type=text runat=server id=txtZip&gt;&lt;/td&gt;
</code></pre>
</li>
<li>
<p><strong>Use the Regex class to validate other sources.</strong> Most Web applications accept input from various sources, including HTML controls, server controls, query strings, and cookies. Validate input from all of these sources to help prevent injection attacks. Use regular expressions to help validate input. The following example shows how to use the Regex class.</p>
<pre><code>using System.Text.RegularExpressions;
// Instance method:Regex reg = new Regex(@&quot;^[a-zA-Z'.\s]{1,40}$&quot;);
Response.Write(reg.IsMatch(Request.QueryString[&quot;Name&quot;]));
// Static method:if (!Regex.IsMatch(Request.QueryString[&quot;Name&quot;],@&quot;^[a-zA-Z'.\s]{1,40}$&quot;))
{
   // Name does not match expression
}
If you cannot cache your regular expression for frequent use, you should use the static IsMatch method where possible for performance reasons, to avoid unnecessary object creation.
</code></pre>
</li>
</ol>
<h2>Guideline</h2>
<ul>
<li><a href="11a15f3a-7fe8-4e4c-be5e-309ab7227b3d">Validate All Input</a></li>
</ul>
