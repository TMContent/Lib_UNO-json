<h1>What to Check For</h1>
  <p>Verify that your application does not store user credentials when impersonating users. Ensure that LogonUser API is called only if the users are asked for their credentials. Otherwise, ensure that your application uses the &lt;<strong>identity</strong>&gt; element in web.config or Kerberos to impersonate users.</p>
  <h1>Why</h1>
  <p>Using the LogonUser API forces your application to handle Windows authentication credentials. Although LogonUser is an acceptable way of impersonating an user, improper handling of Windows credentials could lead to a breach in your company's IT infrastructure.</p>
  <h1>How to Check</h1>
  <ol>
    <li>
      <p>
        <strong>Identify all code that impersonates users. </strong>Review your application's code base and locate all places that perform impersonation. Common ways to identify impersonation include:</p>
      <ul>
        <li>&lt;<strong>identity</strong>&gt; element inside your application's web.config <li>Use of the <strong>WindowsIdentity.Impersonate</strong> method </li></li>
      </ul>
      <li>
        <p>
          <strong>Verify the impersonation method that is used. </strong>For each impersonation instance, examine the adopted impersonation method. Keep in mind the following ways of impersonating users:</p>
        <ul>
          <li>
            <p>
              <strong>Permanent</strong>: If your application needs to permanently impersonate users, verify that the <strong>impersonate</strong> attribute inside the &lt;identity&gt; element is set to <strong>true</strong>:</p>
            <pre>&lt;identity impersonate="true" /&gt;</pre>
            <p>For example, if your application uses Windows authentication, the following&nbsp;will allow ASP.NET to impersonate the IIS user when executing your application's code:</p>
            <pre>&lt;authentication mode="Windows" /&gt;<br />&lt;identity impersonate="true" /&gt;</pre>
            <p>The &lt;identity&gt; element can also&nbsp;allow your application to impersonate a specific user. Example:</p>
            <pre>&lt;identity impersonate="true"<br /> userName="registry:HKLM\Software\MyApp\Identity\ASPNET_SETREG,userName"<br /> password="registry:HKLM\Software\MyApp\Identity\ASPNET_SETREG,password" /&gt;</pre>
            <li>
              <p>
                <strong>Temporary</strong>: If your application needs to temporarily impersonate users, verify that it uses the WindowsIdentity.Impersonate method.</p>
              <blockquote>
                <pre>WindowsImpersonationContext ctx = winIdentity.Impersonate();</pre>
              </blockquote>
              <p>Your application can obtain a WindowsIdentity object through one of the following methods:</p>
              <ul>
                <li>
                  <p>
                    <strong>IIS</strong>: If your application uses Windows authentication, IIS will automatically provide the WindowsIdentity object. Example:</p>
                  <pre>WindowsIdentity winId = (WindowsIdentity)HttpContext.Current.User.Identity;</pre>
                  <li>
                    <p>
                      <strong>Kerberos</strong>: If your application uses an Active Directory, your code can create a WindowsIdentity object based on a valid UPN. Example:</p>
                    <pre>WindowsIdentity winIdentity = new WindowsIdentity("username&#64;domainName");</pre>
                    <li>
                      <p>
                        <strong>LogonUser</strong>: If your application asks its users for their credentials, your code can create a WindowsIdentity object based on the security token that LogonUser returns. Ensure that this method is used if and only if your application asks the users for their credentials. Example:</p>
                      <pre>IntPtr token;bool result;<br />result = LogonUser("user", "domain", "pass",<br /> LogonTypes.Batch, LogonProviders.Default, out token);<br />if (result)<br />&#123;<br />    WindowsIdentity winIdentity = new WindowsIdentity(token);<br />    CloseHandle(token);<br />    ...<br />&#125;</pre>
                    </li>
                  </li>
                </li>
              </ul>
            </li>
          </li>
        </ul>
        <li>
          <p>
            <strong>Check for common mistakes.</strong>
          </p>
          <ul>
            <li>
              <p>Ensure that your application impersonates users as close as possible to the code that requires impersonation.</p>
              <li>
                <p>Ensure that your application impersonates its users for as&nbsp;little code&nbsp;as possible and verify that each impersonation instance has a finally block associated with it to ensure that impersonation is always terminated:</p>
                <pre>WindowsIdentity winIdentity = new WindowsIdentity(<a href="mailto:username&#64;domainName">username&#64;domainName</a>);<br />WindowsImpersonationContext ctx = winIdentity.Impersonate();<br />try<br />&#123;<br />  // Do work<br />&#125;<br />catch(Exception ex)<br />&#123;<br />  // Stop impersonating<br />  ctx.Undo();<br />&#125;<br />finally<br />&#123;<br />  // Stop impersonating<br />  ctx.Undo();<br />&#125;</pre>
                <li>
                  <p>Using the <a href="/article/f28f80e5-814a-4e3b-9475-9cbb1da901b4">Exceptions are Not Propagated while Impersonating</a> checklist, verify that exceptions do not get propagated while your application is impersonating a user.</p>
                </li>
              </li>
            </li>
          </ul>
        </li>
      </li>
    </li>
  </ol>
  <h1>Problem Example</h1>
  <p>MyApp is the HR application at MyCorp. Although MyCorp's IT network is operated using an Active Directory, MyApp performs a certificate-based single sign-on. MyApp operates under the ASP.NET local system account. However, certain actions, such as file uploads, are performed using the users' Windows accounts. To do this, the application stores the users' credentials into its own credential repository and uses LogonUser to impersonate its users. An attacker compromises MyApp credential repository and valid users in MyCorp's Active Directory.</p>
  <pre>HttpClientCertificate cert = HttpContext.Current.Request.ClientCertificate;<br />if (cert.IsPresent)<br />&#123;<br />    IntPtr token;<br />    bool result;<br />    string cn = cert.Get("SUBJECT CN");<br />    string username = MyApp.GetUsername(cn);<br />    string password = MyApp.GetPassword(username);<br />    string domain = "NTDOMAIN";<br />    result = LogonUser(username, domain, password, LogonTypes.Batch, LogonProviders.Default, out token);<br />    if (result)<br />    &#123;<br />        WindowsIdentity winIdentity = new WindowsIdentity(token);<br />        CloseHandle(token);<br />        WindowsImpersonationContext ctx = winIdentity.Impersonate();<br />        // Store the uploaded file<br />    &#125;<br />&#125;</pre>
  <h1>Related Guideline</h1>
  <ul>
    <li>
      <a href="/article/97dfd32f-deb6-4016-b3ff-24147a959521">Guideline: Do Not Use the LogonUser API&nbsp;</a>
    </li>
  </ul>
  <hr />
  <p>Adapted from Microsoft patterns & practices guidance. </p>