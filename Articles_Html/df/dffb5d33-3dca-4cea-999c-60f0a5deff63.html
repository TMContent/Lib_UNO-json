<h1>What to Check For</h1>
  <p>Ensure that communication&amp;nbsp;links are encrypted when interacting with other software across the network.</p>
  <h1>Why</h1>
  <p>Encrypting the communication links allows the application to preserve the&amp;nbsp;confidentiality and integrity of the transmitted data.</p>
  <h1>How to Check</h1>
  <p>Use the following steps to ensure your application's communication links are encrypted:</p>
  <ol>
    <li>
      <p>
        <strong>Identify the connections used for transmitting sensitive data. </strong>Enumerate all connections between different entities. Identify the sensitive data that is sent over the network and the respective connections that are used for such communications.</p>
      <p>Common methods for identifying network connections include:</p>
      <ul>
        <li>
          <p>Enumerating all connection strings identified in the <strong>connectionStrings</strong> element inside web.config. Using the name of each connection string, identify the places inside your application where a connection string is used:</p>
          <pre>&lt;configuration&gt;<br />  &lt;connectionStrings&gt;<br />    ...</pre>
        </li>
        <li>
          <p>Identifying all requests made to web services. Example:</p>
          <blockquote>
            <pre>[System.Web.Services.Protocols.SoapDocumentMethodAttribute(<br />       "https://serv02.example.com/myapp/GetJobState",<br />        RequestNamespace="https://serv02.example.com/myapp/",<br />        ResponseNamespace="https://serv02.example.com/myapp/",<br />        Use=System.Web.Services.Description.SoapBindingUse.Literal,<br />        ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]<br /><br />public JobState GetJobState(string jobID)<br /> {<br />    object[] results = this.Invoke("GetJobState", new object[] { jobID });<br />    return ((JobState)(results[0]));<br /> }</pre>
          </blockquote>
        </li>
        <li>
          <p>Identifying all uses of any of the following common .NET classes:</p>
          <ul>
            <li>System.Data.Common.DbConnection </li>
            <li>System.Data.Odbc.OdbcConnection </li>
            <li>System.Data.OleDb.OleDbConnection </li>
            <li>System.Data.OracleClient.OracleConnection </li>
            <li>System.Data.SqlClient.SqlConnection </li>
            <li>System.Data.SqlServerCe.SqlCeConnection </li>
            <li>System.Net.HttpListener </li>
            <li>System.Net.HttpWebRequest </li>
            <li>System.Net.WebClient </li>
            <li>System.Net.WebRequest </li>
            <li>System.Net.Sockets.Socket </li>
            <li>System.Net.Sockets.TcpClient </li>
            <li>System.Net.Sockets.TcpListener </li>
            <li>System.Net.Sockets.UdpClient</li>
          </ul>
        </li>
        <li>
          <p>Enumerating any uses of DCOM or RPC. Examine your application's requirements and design for any instances where using DCOM is required. Examine the system documentation and look at objects which the application links against.</p>
        </li>
      </ul>
    </li>
    <li>
      <p>
        <strong>Verify that connections are secured. </strong>Verify your application uses standard encryption technologies such as IPSec, TLS/SSL, or secure SMB/DCOM to secure the communication links. Then using a network sniffer, verify your application utilizes IPSec, TLS/SSL, or encrypted SMB/DCOM properly.</p>
    </li>
    <ul>
      <li>
        <p>
          <strong>IPSec: </strong>Examine the configurations of all connection endpoints and ensure that they are configured to require IPSec for all relevant connections and to fail instead of degrading security. Check if all packets from your sniffed traffic between the specified hosts contain an Authentication Header (AH) and Encapsulating Security Payload (ESP) fields after the IP headers. Ensure that payloads are encrypted. Attempt to connect to the service without encryption and ensure that unencrypted connections are rejected. As IPSec use is a host level configuration, its use cannot be determined from inside the code base, but an automatic check can be scripted via WMI for verifying security during deployment.</p>
      </li>
      <li>
        <p>
          <strong>TLS/SSL: </strong>Ensure that all endpoints are configured to connect via SSL with appropriately strong algorithms. Check if your sniffed traffic between the specified hosts contains an SSL handshake. Verify that the payloads are encrypted. Ensure that servers reject connections which do not use SSL and that the protocol cannot be forced to degrade to inappropriately weak ciphers. When looking at the code, ensure that all URLs and protocols used for communication are specified to use SSL. As this is enforced entirely within the application, it can be verified via code inspection alone, except&amp;nbsp; for connections made by binary-only third party components. Ideally, any time a configurable URL is used, the code should check that SSL will be used in the connection and refuse to make plaintext connections. Keep in mind the following considerations when verifying your application's use of SSL: </p>
        <ul>
          <li>
            <p>
              <strong>Certificate Validity</strong>: Verify that your application's SSL certificate has not reached its expiration date. </p>
          </li>
          <li>
            <p>
              <strong>Certificate Version</strong>: Verify that your application uses SSL version 3.0 certificate. </p>
          </li>
          <li>
            <p>
              <strong>Domain Name</strong>: Verify that the domain name for your application's administrative interface is the same as the domain name listed in the SSL certificate. </p>
          </li>
          <li>
            <p>
              <strong>Chain of Trust</strong>: Verify that your application's users can verify your application's SSL certificate based on the root certificates that are stored in their browsers. If your application uses self-signed SSL certificates, ensure that your organization's root certificate is securely imported into the users' browsers </p>
          </li>
          <li>
            <p />
            <strong>Web Server Configuration</strong>: Verify that your application's environment has enabled HTTPS. Verify that transactions of sensitive nature are transmitted only over HTTPS connections. Check if IIS is configured to require SSL for the appropriate parts of your application: <ol><li><p>Start the <strong>IIS management console</strong>. To do this, click on <strong>Control Panel</strong> -&gt; <strong>Administrative Tools</strong> -&gt; <strong>Internet Information Services</strong>. </p></li><li><p>Right click on the resources that require SSL. </p></li><li><p>Select the <strong>Directory Security</strong> tab. If the resource is a file, select <strong>File Security</strong>. </p></li><li><p>Locate the <strong>Secure communications</strong> section, and click <strong>Edit</strong>. </p></li><li><p>Verify that <strong>Require secure channel (SSL)</strong> is checked. </p></li><li><p>Repeat steps 2 through 5 for all resources that require SSL.</p></li></ol></li>
        </ul>
      </li>
      <li>
        <p>
          <strong>Windows Networking (SMB/DCOM): </strong>If DCOM, RPC, SMB, or NTLM authentication within HTTP are used for communications, ensure that the SMB protocol is operating in a secure and encrypted mode. Check the settings on all endpoints and ensure that they will not release information to anonymous users, that appropriately strong algorithms are used, that strong keys are required, and that authentication levels and session security are set to the maximum available settings. Confirm that your sniffed traffic between hosts contains only encrypted SMB traffic, and ensure that the systems will not degrade their security levels based on a remote client request. As SMB/DCOM security is a host-level configuration, its use cannot be determined from inside the code base, but an automatic check can be scripted via WMI for verifying security during deployment.</p>
      </li>
    </ul>
  </ol>
  <h1>Problem Example</h1>
  <p>The following code snippet establishes a connection to a remote host without using encryption. As a result, an attacker can eavesdrop on the connection and steal any sensitive data in transit. </p>
  <pre>public NetworkStream Connect(String remoteHost, int remotePort)<br />{<br />    TcpClient client = new TcpClient (remoteHost, remotePort);<br />    NetworkStream stream = client.GetStream();<br />    return stream;<br />}</pre>
  <h1>Related Guideline</h1>
  <ul>
    <li>
      <a href="/article/b070122f-f1d1-47da-a378-57f845d5db61">Guideline: Encrypt Communication Links (ASP.NET)</a>
    </li>
  </ul>
  <hr />
  <p>Adapted from Microsoft patterns &amp; practices guidance. </p>