<h2>Applies To</h2>
<ul>
<li>ASP.NET 4.0 and Higher</li>
</ul>
<h2>Summary</h2>
<p>This How to shows a number of ways to help protect your ASP.NET application from SQL injection attacks. SQL injection can occur when an application uses input to construct dynamic SQL statements. Successful SQL injection attacks enable malicious users to execute arbitrary queries on the application's database.</p>
<p>Countermeasures include validating input, using parameterized SQL for data access, and using a least privileged account that has restricted permissions in the database. Using stored procedures with parameterized SQL is the recommended approach because SQL parameters are type safe. Type-safe SQL parameters can also be used with dynamic SQL.</p>
<h2>Overview</h2>
<p>A successful SQL injection attack enables a malicious user to execute queries on your application's database by using the privileges granted to your application's login. The problem is more severe if your application uses an over-privileged account to connect to the database. For example, if your application's login has privileges to eliminate a database, then without adequate safeguards, an attacker might be able to perform this operation.</p>
<p>Common vulnerabilities that make your data access code susceptible to SQL injection attacks include:</p>
<ul>
<li>Weak input validation.</li>
<li>Dynamic construction of SQL statements without the use of type-safe parameters.</li>
<li>Use of over-privileged database logins.</li>
</ul>
<h3>Step 1. Constrain Input</h3>
<p>You should validate all input to your ASP.NET applications for type, length, format, and range. By constraining the input used in your data access queries, you can protect your application from SQL injection.</p>
<p>Note: When constraining input, it is a good practice to create a list of acceptable characters and use regular expressions to reject any characters that are not on the list. The potential risk associated with using a list of unacceptable characters is that it is always possible to overlook an unacceptable character when defining the list; also, an unacceptable character can be represented in an alternate format to pass validation.</p>
<h3>Constrain Input in ASP.NET Web Pages</h3>
<p>Start by constraining input in the server-side code for your ASP.NET Web pages. Do not rely on client-side validation because it can be easily bypassed. Use client-side validation only to reduce round trips and to improve the user experience.</p>
<p>If you use server controls, use the ASP.NET validator controls, such as the <code>RegularExpressionValidator</code> and <code>RangeValidator</code> controls to constrain input. If you use regular HTML input controls, use the Regex class in your server-side code to constrain input.</p>
<p>If in the previous code example, the SSN value is captured by an ASP.NET TextBox control, you can constrain its input by using a <code>RegularExpressionValidator</code> control as shown in the following.</p>
<pre><code>&lt;%@ language=&quot;C#&quot; %&gt;
&lt;form id=&quot;form1&quot; runat=&quot;server&quot;&gt;
	&lt;asp:TextBox ID=&quot;SSN&quot; runat=&quot;server&quot;/&gt;
	&lt;asp:RegularExpressionValidator ID=&quot;regexpSSN&quot; runat=&quot;server&quot;         
		 ErrorMessage=&quot;Incorrect SSN Number&quot; 
		 ControlToValidate=&quot;SSN&quot;         
		 ValidationExpression=&quot;^\d{3}-\d{2}-\d{4}$&quot; /&gt;
&lt;/form&gt;  
</code></pre>
<p>If the SSN input is from another source, such as an HTML control, a query string parameter, or a cookie, you can constrain it by using the <code>Regex</code> class from the <code>System.Text.RegularExpressions</code> namespace. The following example assumes that the input is obtained from a cookie.</p>
<pre><code>using System.Text.RegularExpressions;

if (Regex.IsMatch(Request.Cookies[&quot;SSN&quot;], &quot;^\d{3}-\d{2}-\d{4}$&quot;))
{
	// access the database
}
else
{
	// handle the bad input
}  
</code></pre>
<h3>Constrain Input in Data Access Code</h3>
<p>In some situations, you need to provide validation in your data access code, perhaps in addition to your ASP.NET page-level validation. Two common situations where you need to provide validation in your data access code are:</p>
<ul>
<li>Untrusted clients. If the data can come from an untrusted source or you cannot guarantee how well the data has been validated and constrained, add validation logic that constrains input to your data access routines.</li>
<li>Library code. If your data access code is packaged as a library designed for use by multiple applications, your data access code should perform its own validation, because you can make no safe assumptions about the client applications.</li>
</ul>
<p>The following example shows how a data access routine can validate its input parameters by using regular expressions prior to using the parameters in a SQL statement.</p>
<pre><code>using System;
using System.Text.RegularExpressions;

public void CreateNewUserAccount(string name, string password)
{
	// Check name contains only lower case or upper case letters, 
	// the apostrophe, a dot, or white space. Also check it is 
	// between 1 and 40 characters long
	if ( !Regex.IsMatch(userIDTxt.Text, @&quot;^[a-zA-Z'./s]{1,40}$&quot;))
	  throw new FormatException(&quot;Invalid name format&quot;);

	// Check password contains at least one digit, one lower case 
	// letter, one uppercase letter, and is between 8 and 10 
	// characters long
	if ( !Regex.IsMatch(passwordTxt.Text, 
		@&quot;^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$&quot; ))
	  throw new FormatException(&quot;Invalid password format&quot;);

	// Perform data access logic (using type safe parameters)
	...
}
</code></pre>
<h3>Step 2. Use Parameters with Stored Procedures</h3>
<p>Using stored procedures does not necessarily prevent SQL injection. The important thing to do is use parameters with stored procedures. If you do not use parameters, your stored procedures can be susceptible to SQL injection if they use unfiltered input as described in the &quot;Overview&quot; section of this document.</p>
<p>The following code shows how to use <code>SqlParameterCollection</code> when calling a stored procedure.</p>
<pre><code>using System.Data;
using System.Data.SqlClient;

using (SqlConnection connection = new SqlConnection(connectionString))
{
  DataSet userDataset = new DataSet();
  SqlDataAdapter myCommand = new SqlDataAdapter( 
			 &quot;LoginStoredProcedure&quot;, connection);
  myCommand.SelectCommand.CommandType = CommandType.StoredProcedure;
  myCommand.SelectCommand.Parameters.Add(&quot;@au_id&quot;, SqlDbType.VarChar, 11);
  myCommand.SelectCommand.Parameters[&quot;@au_id&quot;].Value = SSN.Text;

  myCommand.Fill(userDataset);
}  
</code></pre>
<p>In this case, the @au_id parameter is treated as a literal value and not as executable code. Also, the parameter is checked for type and length. In the preceding code example, the input value cannot be longer than 11 characters. If the data does not conform to the type or length defined by the parameter, the <code>SqlParameter</code> class throws an exception.</p>
<h3>Review Your Application's Use of Parameterized Stored Procedures</h3>
<p>Because using stored procedures with parameters does not necessarily prevent SQL injection, you should review your application's use of this type of stored procedure. For example, the following parameterized stored procedure is unsafe:</p>
<pre><code>CREATE PROCEDURE dbo.RunQuery(@var ntext) AS
exec sp_executesql @var;
</code></pre>
<p>This stored procedure ultimately concatenates data passed to it into SQL syntax, thus negating parameterization. Consider the @var variable being set to: <code>DROP TABLE ORDERS;</code> In this case, the ORDERS table will be dropped. The main principle for preventing SQL injection is never concatenating untrusted data into SQL syntax or in other words never treating data as SQL syntax. In this example, data is being treated as SQL syntax.</p>
<h3>Step 3. Use Parameters with Dynamic SQL</h3>
<p>If you cannot use stored procedures, you should still use parameters when constructing dynamic SQL statements. The following code shows how to use the <code>SqlParametersCollection</code> with dynamic SQL.</p>
<pre><code>using System.Data;
using System.Data.SqlClient;

using (SqlConnection connection = new SqlConnection(connectionString))
{
  DataSet userDataset = new DataSet();
  SqlDataAdapter myDataAdapter = new SqlDataAdapter(
		 &quot;SELECT au_lname, au_fname FROM Authors WHERE au_id = @au_id&quot;, 
		 connection);                
  myCommand.SelectCommand.Parameters.Add(&quot;@au_id&quot;, SqlDbType.VarChar, 11);
  myCommand.SelectCommand.Parameters[&quot;@au_id&quot;].Value = SSN.Text;
  myDataAdapter.Fill(userDataset);
}
</code></pre>
<h3>Using Parameter Batching</h3>
<p>A common misconception is that if you concatenate several SQL statements to send a batch of statements to the server in a single round trip, you cannot use parameters. However, you can use this technique if you make sure that parameter names are not repeated. You can easily do this by making sure that you use unique parameter names during SQL text concatenation, as shown here.</p>
<pre><code>using System.Data;
using System.Data.SqlClient;
...
using (SqlConnection connection = new SqlConnection(connectionString))
{
  SqlDataAdapter dataAdapter = new SqlDataAdapter(
	   &quot;SELECT CustomerID INTO #Temp1 FROM Customers &quot; +
	   &quot;WHERE CustomerID &gt; @custIDParm; SELECT CompanyName FROM Customers &quot; +
	   &quot;WHERE Country = @countryParm and CustomerID IN &quot; +
	   &quot;(SELECT CustomerID FROM #Temp1);&quot;,
	   connection);
  SqlParameter custIDParm = dataAdapter.SelectCommand.Parameters.Add(
										  &quot;@custIDParm&quot;, SqlDbType.NChar, 5);
  custIDParm.Value = customerID.Text;

  SqlParameter countryParm = dataAdapter.SelectCommand.Parameters.Add(
									  &quot;@countryParm&quot;, SqlDbType.NVarChar, 15);
  countryParm.Value = country.Text;

  connection.Open();
  DataSet dataSet = new DataSet();
  dataAdapter.Fill(dataSet);
}
...  
</code></pre>
<h3>Avoid Disclosing Error Information</h3>
<p>Use structured exception handling to catch errors and prevent them from propagating back to the client. Log detailed error information locally, but return limited error details to the client.</p>
<p>If errors occur while the user is connecting to the database, be sure that you provide only limited information about the nature of the error to the user. If you disclose information related to data access and database errors, you could provide a malicious user with useful information that he or she can use to compromise your database security. Attackers use the information in detailed error messages to help deconstruct a SQL query that they are trying to inject with malicious code. A detailed error message may reveal valuable information such as the connection string, SQL server name, or table and database naming conventions.</p>
<hr>
<p>Adapted from Microsoft patterns &amp; practices guidance.</p>
