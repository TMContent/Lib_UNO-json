<h1>What to Check For</h1>
  <p>Ensure that your application handles exceptions properly during impersonation. Verify that all impersonation blocks contain a global exception handler of type <strong>System.Exception</strong> to prevent any exceptions from propagating to other parts of your application. </p>
  <h1>Why</h1>
  <p>If exceptions occur while impersonating, it is possible for malicious code higher in the call stack to run using the impersonated identity. This can present security issues, particularly if you impersonate a highly privileged account. </p>
  <h1>How to Check</h1>
  <ol>
    <li>
      <p>
        <strong>Identify all code that impersonates users. </strong>Review your application's code base and identify all blocks of code where user impersonation takes place. Such code can be identified by the use of the <strong>WindowsIdentity.Impersonate</strong> method.</p>
      <li>
        <p>
          <strong>Ensure the use of structured exception handling. </strong>Review the <a href="/article/bc10306c-f37c-4780-a096-847070ae67da">Structured Exception Handling is Used</a> checklist to ensure the proper use of exception handling while impersonating.</p>
        <li>
          <p>
            <strong>Ensure the use of global exception handling. </strong>Ensure that all impersonation blocks use a global exception handler of type <strong>System.Exception</strong>. This prevents any uncaught exceptions from propagating to other exception handlers in the call stack. Furthermore, ensure that only CLR-compliant exceptions (those derived from the <strong>Exception</strong> class) will be generated by the impersonation code. This can be accomplished via two methods:</p>
          <pre>catch (Exception e)<br /> &#123;<br />    ctx.Undo();<br />    throw;<br /> &#125;</pre>
          <p>or </p>
          <pre>catch<br /> &#123;<br />    ctx.Undo();<br />    throw;<br /> &#125;</pre>
          <li>
            <p>
              <strong>Verify that impersonation is reverted upon encountering an exception.&nbsp;</strong>Ensure that <strong>WindowsImpersonationContext.Undo</strong> is called when an exception occurs. If your application needs to propagate the exception details to another exception handler in the call stack, verify that your application terminates the impersonation before passing the exception details:</p>
            <pre>WindowsImpersonationContext ctx = winIdentity.Impersonate();<br />try<br /> &#123;<br />    ...<br />&#125;<br />catch (Exception e)<br /> &#123;<br />    ctx.Undo();<br />    throw;<br />&#125;</pre>
            <li>
              <p>
                <strong>Verify that finally is used. </strong>Verify that all impersonation instances end with a <strong>finally</strong> block, which invokes <strong>WindowsImpersonationContext.Undo</strong>.</p>
              <pre>WindowsImpersonationContext ctx = winIdentity.Impersonate();<br />try<br />&#123;<br />    ...<br />&#125;<br />catch (Exception e)<br />&#123;<br />    ...<br />&#125;<br />finally<br />&#123;<br />    ctx.Undo();<br />&#125;</pre>
            </li>
          </li>
        </li>
      </li>
    </li>
  </ol>
  <h1>Problem Example</h1>
  <p>MyApp is the HR application at MyCorp. As part of its security requirements, the application uses the company's Active Directory for its authentication needs. Although MyApp operates under the ASP.NET local system account, certain actions, such as file uploads, are performed using the users' Windows accounts. Unfortunately, the application does not handle the exceptions that are generated within the impersonated context properly.</p>
  <pre>// This code assumes the following is true:<br />// - fileInfo represents a valid filename<br />// - fileBuff represents valid contents that will be stored<br />// into the file represented by fileInfo<br />// - username represents a valid user in the company's Active Directory<br />WindowsIdentity winIdentity = new WindowsIdentity(username &#43; "&#64;MyCorp");<br />try <br />&#123;<br />    CallStoreFile(fileInfo, fileBuff, winIdentity);<br />&#125;<br />catch (IOException ioe) <br />&#123;<br />    // Add the appropriate logging and exception handling mechanisms<br />    // This code will execute within the context of the impersonated user&#33;<br />&#125;<br /><br />...<br /><br />public void CallStoreFile(FileInfo fileInfo, byte&#91;&#93; fileBuff, WindowsIdentity winIdentity) <br />&#123;<br />    WindowsImpersonationContext ctx = winIdentity.Impersonate();<br />    StoreFile(fileInfo, fileBuff);<br />    ctx.Undo();<br />&#125;</pre>
  <p>An exception is thrown while a privileged user uses the feature. Because of the improper exception handling, the code calling the impersonation will execute within the context of the impersonated user. </p>
  <h1>Additional Resources</h1>
  <ul>
    <li>To learn more about exception handling in the .NET framework, visit: <a href="http://msdn2.microsoft.com/en-us/library/s7fekhdy(VS.80).aspx">Exception Handling Statements (C# Reference)</a>&nbsp;on MSDN.</li>
  </ul>
  <h1>Related Guideline</h1>
  <ul>
    <li>
      <a href="/article/5b6c71b0-cb89-4435-b30e-2fd76347078e">Guideline: Do Not Propagate Exceptions While Impersonating </a>
    </li>
  </ul>
  <hr />
  <p>Adapted from Microsoft patterns & practices guidance. </p>